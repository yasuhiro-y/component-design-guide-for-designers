Figmaで描けたものが、そのまま実装できるとは限らない。

レイアウトではコンポーネントの配置と空間を扱いました。ここからは、コンポーネントに組み込まれるもうひとつの要素——ビジュアルアセットの管理に移ります。

コンポーネントやトークンに加えて、アイコン、イラストレーション、アニメーションといったビジュアルアセットもデザインシステムの重要な構成要素です。

これらはデザイナーが作って終わりではなく、実装に組み込まれ、長期的にメンテナンスされ続けるものです。ファイル形式の選択、命名規則、色の制御方法など、デザインと実装の接点で押さえるべきポイントが多くあります。

# コード実装か画像埋め込みか: 再現手段の選択

Figma上で描けたからといって、それがそのままCSSやコードで再現できるとは限りません。複雑なグラデーション、不規則な形状、繊細なテクスチャ表現などは、コードでの再現がむずかしく、手間もかなり大きくなります。

そのような場合、無理にコードで再現するよりも、SVGやWebPなどの画像として埋め込むほうが合理的です。

なぜこの判断が重要か。この選択は一度決めると覆しにくいからです。

コードで実装したビジュアルは、後からトークンで色を変えたり、アニメーションを追加したり、柔軟に制御できます。一方、画像として埋め込んだものは、変更のたびにデザイナーが書き出し直してエンジニアに渡す手順が発生します。

つまり、コード実装は変更コストが低く、画像埋め込みは初期コストが低い。この表現は今後変わる可能性があるかを軸に判断します。

たとえば、ライトモードで黒、ダークモードで白に切り替わるアイコンはコード実装が必須です。画像として埋め込んでいると、モード切り替えのたびにファイルを差し替える手間が発生します。一方、一度作ったら長期間変わらない装飾的なイラストは画像埋め込みで構いません。

コードで再現するか、アセットとして埋め込むかは、早い段階で実装方針をすり合わせておきたい論点です。

![コード実装かアセット埋め込みかの判断フロー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-09.png)

# アイコン管理: 既存ライブラリと独自制作のトレードオフ

アイコンはUIの中でよく使われるグラフィックのひとつです。まず考えるべきは、世の中にあるアイコンライブラリを使うのか、自社でゼロから作るのかという戦略です。

## 既存ライブラリを使う

実装コストがほぼゼロなのが大きな強みです。ライブラリを導入して名前を指定するだけで画面に配置できます。一貫性が保たれており、アイコンが足りなくて困ることもありません。

反面、ブランドの独自性は薄れます。どこかで見たことがあるアプリという印象になりがちですし、自社特有の概念を表現するアイコンがない場合、結局一部だけ自作することになります。

## 独自アイコンを制作する

ブランドの世界観を細部までコントロールでき、プロダクト独自のドメイン知識を視覚的に正しく伝えることが可能です。ただし、制作とメンテナンスのコストは大きいです。SVGのパスをきれいに掃除し、書き出し設定を整え、実装で使える形式で管理し続ける必要があります。

これらはハイブリッド運用することも可能です。矢印やゴミ箱などの汎用的なアイコンは既存のライブラリに頼り、プロダクトを象徴する重要なアイコンだけを自作する構成です。ただし、この場合は線の太さや角丸のルールをライブラリ側に寄せる配慮が欠かせません。統一感がないとここだけ浮いて見えるという問題が起きるためです。

![既存ライブラリ vs 独自アイコン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-21.png)

# ベクターアイコンの活用: SVGとアイコンフォント

アイコンの管理にどんな形式を選ぶかは、日々の開発効率に影響する選択です。

意外と多いのが、アイコンをPNGやJPGなどのラスター画像で管理しているパターンです。この方式だと、色違いが必要になるたびに別ファイルを書き出す必要がありますし、ダークモード対応では同じアイコンの白版・黒版が倍々で増えていきます。さらに拡大表示でぼやけるという根本的な問題もあります。

現在の開発現場では、アイコンはSVGまたはアイコンフォントとして管理するのが標準です。こうした形式であれば、個別の画像ファイルを保存・呼び出しする必要がなく、アイコン名を指定するだけで表示できます。色やサイズもコードから自由に制御でき、ほとんどのケースではこの方式で十分です。

具体的にどれほどの違いがあるかを見てみましょう。

![名前指定によるアイコン呼び出し](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-49.png)

Figmaでの管理方法としては、アイコンそれぞれを個別のコンポーネントとして作成する方法と、Component Setでバリアントとしてまとめる方法があります。チームの規模やアイコンの数に応じて選択してください。

以下では、アイコンをSVGとして実装に渡す際に知っておきたい技術的仕様を紹介します。

# 色の制御: アイコンの色を自動で合わせるしくみ

Figma上でアイコンの色を変えるとき、塗りの色を直接変更しますよね。コードの世界でも同じことをしたいのですが、Figmaから書き出したSVGファイルの中身を覗くと、色が `#1A1A1A`（ほぼ黒のカラーコード）のような固定値で埋め込まれていることがあります。

この状態だと、ボタンの中に置いたアイコンの色をボタンの色に合わせて自動で切り替える、といったことができません。

ダークモードを導入した際にこの問題にぶつかるチームは少なくありません。ライトモードでは黒いアイコンがきちんと見えていたのに、ダークモードに切り替えた瞬間、黒い背景に黒いアイコンで何も見えない。原因は、SVGに色が固定値で埋め込まれていたことです。

## 色を親に委ねる

理想は、SVGの中の色を固定値にせず、周囲のテキスト色に自動で合わせるという指定にしておくことです。CSSでは `currentColor` という値でこれを実現します。白いテキストのボタンの中に置けば白に、青いリンクの中に置けば青に、と自動で色が変わります。Figmaでいえば、Variablesでアイコンの色をテキスト色トークンに紐づけておくのと近い考え方です。

![SVGの色制御: 固定色 vs currentColor](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-30.png)

運用ルールとしておすすめなのは、Figma上でアイコンコンポーネントを最初から黒一色で作ることです。コード側で色を上書きする前提にしておけば、Figma上ではカジュアルに色をあてることができます（こうしたとき、デザイントークンによる規律が有効です）。

チームによっては、書き出し時に自動で色を除去するビルドスクリプトを用意しているケースもあります。チームで運用方法をすり合わせておきましょう。
