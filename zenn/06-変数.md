Figmaのプロパティパネルは、コードの設計図そのものです。パネルに並ぶトグルやドロップダウン、あの一つひとつに型があることを意識したことはありますか？　この章を読むと、エンジニアに「このプロパティ、`Boolean`ですか`Enum`ですか？」と自分から確認できるようになります。型の会話ができるだけで、認識のズレによる手戻りが激減します。

# プロパティの型を解剖する: Figmaのパネルはコードの設計図

![Figma プロパティパネルとコードの対応関係](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-18.png)

ここからは、コンポーネントが外側から受け取る設定値——プロパティ——をくわしく見ていきます。Figmaのコンポーネントプロパティパネルに並んでいるトグルスイッチ、テキストフィールド、バリアントの切り替え。これらはコード上の変数と対応しています。

> **Notice:** この章で「変数」「プロパティ」と呼んでいるのは、コンポーネントに渡す設定値のことです。FigmaのVariables機能（デザイントークンを管理するしくみ）とは別の概念です。混同しやすいので注意してください。

Figmaのプロパティパネルを整理することは、コードの設計図を書くことでもあります。この設計図はAIコード生成の精度にも直結します。型が明確に定義されていれば、AIに渡したときに自社のルールに沿った精度の高いコードが返ってきやすくなります。

プロパティには型（Type）があります。Figmaのプロパティパネルで、トグルスイッチなのか、テキスト入力なのか、バリアントの切り替えなのか——その入力方式の違いが、コードでは型として定義されています。

Notionのデータベースを思い浮かべてください。カラムを作るとき、テキスト・数値・チェックボックス・セレクト・日付……と種別を選びます。
あのカラムの種別が、ここでいう型にあたります。

Figmaのプロパティパネルでも同じことが起きています。トグルスイッチは`Boolean`、バリアント切り替えは`Enum`、テキスト入力は`String`です。Figmaのプロパティパネルではテキスト入力欄に何でも自由に入れられますが、コードの世界では数値の 24 とテキストの "24" は別物です。このプロパティに入る値はテキストなのか、数字なのか、ON/OFFなのかを意識して設計すると、コードとの対応関係が明確になります。

ここでは、`Boolean`、`Enum`、`String`、`Number`、`Date`といった基本の型に加え、配列やオブジェクトといったデータの構造についても解説します。聞き慣れない用語もありますが、ひとつずつFigmaの操作に対応づけていきます。

型の選択を間違えると、Figmaのプロパティパネルは使いにくくなり、実装者は意図を汲み取れず、このコンポーネント、使い方がわからないという声が上がります。型は地味ですが、コンポーネントの使い心地を決定的に左右します。

![プロパティの型: Figma での見え方とコードの対応](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-17.png)

以下の表は全体像です。まずはざっと眺めてみましょう。


| 型        | コードでの書き方（参考）                        | Figmaでの表現           | 設計時に自問すべきこと           | よくある落とし穴                 |
| --------- | ----------------------------------------------- | ----------------------- | -------------------------------- | -------------------------------- |
| `Boolean` | `isDisabled: boolean`（ON/OFFの値）             | トグルスイッチ          | 本当に2択か？将来3択にならないか | 3つ以上並んだら`Enum`を検討        |
| `Enum`    | `size: 'S' \| 'M' \| 'L'`（3つの中から1つ選ぶ） | バリアント（Variant）   | 選択肢は網羅されているか         | 追加は安全、削除は破壊的変更     |
| `String`  | `label: string`（自由なテキスト）               | テキスト入力            | 空・長文・改行時の振る舞いは？   | 選択肢があるなら`Enum`にできないか |
| `Number`  | `count: number`（数値）                         | テキスト入力            | 上限・下限・0のときの扱いは？    | 表示フォーマットの定義を忘れない |
| `Date`    | `deadline: Date`（日付）                        | テキスト入力            | フォーマットは誰が決める？       | タイムゾーンの扱いを確認         |
| `Array`   | `items: Item[]`（データの一覧）                 | `Auto Layout`内の繰り返し | 0件・1件・大量のときどうなる？   | 端のケースも含めてデザインする   |
| `Object`  | `user: User`（データのまとまり）                | 複数プロパティの集合    | 個別の値か、まとまりか？         | 汎用コンポーネントには向かない   |
| `Element` | `icon: ReactNode`（別の部品を差し込む）         | `Instance Swap`         | テキストだけで本当に十分か？     | 将来UIのかたまりが必要になるか   |

## プロパティと値の命名: Figmaとコードの対応をスムーズにする

個々の型に入る前に、プロパティ名と値の命名ルールを整理しておきます。Figmaのプロパティパネルでの命名がそのままコードの変数名になるため、ここでの判断がチーム全体の語彙を決めます。

まず、否定形は避けます。Figmaでいえば、トグルスイッチの名前を「無効ではない」にするか「無効」にするかの違いです。`isNotDisabled` ではなく `isDisabled`。二重否定は読み手を混乱させるだけです。

`Boolean`（トグル）は動詞で始めるのが一般的。`showIcon`、`hasBorder` のように。`is` は状態（`isDisabled`）、`has` はあるかないか（`hasBorder`）、`show` は表示するかどうか（`showIcon`）を表します。

`Enum`の選択肢は、見た目ではなく意味で名付けます。`size` なら `S` / `M` / `L` のように体系的に、`variant` なら `primary` / `danger` のように役割で。`size: default` は曖昧で後から意味がわからなくなりますし、`variant: red` は色が変わった瞬間に破綻します。

表示位置のように複数の選択肢を切り替えたい場合は、`Boolean` を複数並べるよりも`Enum`ひとつにまとめます。Figmaのプロパティパネルに「左アイコン表示」「右アイコン表示」の2つのトグルが並んでいて両方ONにできてしまう状態を想像してください。`hasLeftIcon` と `hasRightIcon` を別々に持つとこの矛盾が生じます。これを1つのドロップダウン `iconPosition: 'left' / 'right' / 'none'` にまとめれば、常にひとつだけが選ばれます。これが`Enum`化です。

選択肢の命名で広く使われているのがTシャツサイズです。`small` / `medium` / `large` という呼び方で、省略形なら `s` / `m` / `l`。基準となるサイズを `medium` に置き、そこから上下に展開していきます。

拡張が必要になったとき、上方向は `x-large` → `2x-large`（`xl` → `2xl`）、下方向は `x-small` → `2x-small`（`xs` → `2xs`）と伸ばせます。最初から全段階を用意する必要はありませんが、この拡張パスを頭に入れておくだけで、命名の破綻を防げます。

もうひとつ意識しておきたいのが、最も代表的な値をスケールの中に正しく位置づけることです。いま選択肢がひとつしかなくても、その値がスケールのどこにあるかを考えておく。

よくある失敗は、最初に作ったサイズを `size = Default` と名付けてしまうパターンです。1年後には `Default` / `Small` / `Smaller` / `Tiny` の4段階に膨れ上がり、`Default`が`Large`なのか`Middle`なのか答えられない——こうした事態は珍しくありません。

対策はシンプルです。最初に作るものがひとつであっても、スケールの中での位置を決めて`medium`や`large`と名付けます。`Default`はスケール上の位置を表さない名前です。だからこそ、最も代表的な値には`medium`という明確な位置づけを与えておきましょう。

色についても同じことが言えます。`variant` = `Blue` としてしまうと、ブランドカラーが変わったときやダークモードに対応したときに名前と実際の色が矛盾します。

色は意味で名付けると堅牢です。`variant` = `Primary` や `variant` = `Danger` のように、その色が果たす役割で呼ぶことで、中身の色が変わっても名前が壊れません。ボタンもバッジもタグも、同じセマンティックカラー体系に基づいて名付けることで、コンポーネント間の一貫性が保たれます。

![プロパティ命名: 4つの判断パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-58.png)

## `Boolean`: 真偽値

スイッチのON/OFF、はい/いいえの2択です。コードでは`true`/`false`という値が入ります。

Figmaではプロパティパネルにあるトグルスイッチで指定するプロパティです。アイコンを表示するかどうか、読み込み中かどうか、といった存在や状態のオンオフを管理します。

たとえば、`isRequired`（必須かどうか）、`isDisabled`（操作できない状態かどうか）、`showIcon`（アイコンを表示するかどうか）。名前の通り、はい/いいえで答えられる性質をそのままプロパティにしたものです。

`Boolean`はシンプルで使いやすい反面、トグルが3つ以上並んだら設計を見直すサインです。トグルが3つあればON/OFFの組み合わせは8通り。そのほとんどは、ありえない状態や矛盾する状態を含んでいます。

たとえば、ボタンのサイズを `isSmall` と `isLarge` という2つの`Boolean`で管理したとします。どちらもOFFなら通常サイズ。では両方ONになったら？ 小さくて大きいボタンは存在しません。こうした矛盾が生まれる時点で、サイズは最初から`Enum`（`Small` / `Medium` / `Large` の選択式）にすべきだったということです。

![Boolean の矛盾: 2つのトグルより1つの Enum](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-42.png)

`Boolean`を追加するときは、以下を確認してみてください。

- そのON/OFFは本当に2択か？ 将来3択以上に増える可能性はないか
- 他の`Boolean`と組み合わせたとき、ありえない状態が生まれないか
- Figmaのバリアント（`Enum`）で表現したほうがシンプルにならないか
- ひとつのコンポーネントに`Boolean`が3つ以上並んでいないか

もうひとつ知っておきたいのは、`Boolean`には「まだ決まっていない」がないということです。Figmaのトグルスイッチと同じで、ONかOFFか、必ずどちらかの状態にあります。だからこそ、コンポーネントを新しく作ったとき、そのトグルの初期状態をONにするかOFFにするかをあらかじめ決めておく必要があります。

## `Enum`: 列挙型

あらかじめ用意された選択肢の中からひとつだけ選ぶ形式です。Notionデータベースのセレクトカラムと同じ考え方です。

FigmaのVariant（バリアント）がこれにあたります。たとえば、`size` なら `small` / `medium` / `large` のどれか、`variant` なら `primary` / `secondary` のどれか、というように選択肢をあらかじめ定義しておきます。Figmaのバリアントでサイズ = `S` / `M` / `L`を選ぶ操作を思い浮かべてください。プロパティパネルのドロップダウンから選ぶあの操作そのものが、`Enum`の概念です。

`Enum`の価値は、あえて制約することにあります。

`String`型は何でも入力できますが、自由すぎるとチームのなかでバラつきが生まれます。`Enum`にして選択肢を絞ることで、迷う場面が減り本質に集中できるようになる。選択肢の体系そのものが、コンポーネントの使い方を暗に伝えてくれます。

制約は、急いでいるときにこそ効きます。デッドライン直前、人は最も簡単な道を選びがちです。選択肢が自由すぎると「とりあえず」の判断が積み重なり、一貫性が崩れていく。あらかじめ`Enum`で選択肢を整えておくことは、正しい選択を最も簡単にする環境設計です。

たとえば、余白を`Number`型の自由入力にすると、14px、16px、18px…と微妙に違う値が画面ごとに増えていきます。これをSpacing Tokenにして `Small` / `Medium` / `Large` しか選べなくすれば、誰が組んでもリズムが整います。トークン化前は画面ごとに5種類以上の余白値が混在していたのが、トークン化後は3種類だけ——余白に関する議論が大幅に減るのは、デザインシステム導入のわかりやすい成功指標です。

`Enum`を設計するときの確認ポイントです。

- 選択肢の名前は見た目ではなく意味で付けているか（`Red` ではなく `Danger`）
- 将来の拡張を見越した命名になっているか（新しい選択肢を追加しても既存の名前が不自然にならないか）
- 選択肢の数は適切か（7つ以上あるなら設計を見直すサイン。選択肢が多すぎると使う側が迷い、管理も煩雑になります）
- 同じ意味の選択肢が別の名前で重複していないか

`Enum`の力が特に発揮されるのが、`Tag`、`Badge`、`Callout` のように色とサイズの組み合わせをまとめて管理するコンポーネントです。

実際のライブラリでも、`Enum`の設計が見た目の似たコンポーネントを整理する武器になっています。Figmaでいえば、`Badge`と`Tag`の両方に`size`（`S` / `M`）と`colorScheme`（`info` / `success` / `warning` / `error`）というバリアント軸を揃えておき、`Tag`にだけ「×ボタン表示」のトグルを追加する設計です。

[Chakra UI](https://chakra-ui.com/)はまさにこの構造で、[`Badge`](https://chakra-ui.com/docs/components/badge)と[`Tag`](https://chakra-ui.com/docs/components/tag)が同じ色の体系（`colorScheme`）と表現の種類（`variant`）——塗りつぶし（`solid`）、薄い背景色（`subtle`）、枠線のみ（`outline`）——を共有しつつ、`Tag`にだけ閉じるボタンの有無を切り替える`Boolean`が加わっています。

色と強度の軸は共通の設計言語で揃え、機能の違いだけを`Boolean`で表現する。このパターンは自社のコンポーネント設計でもそのまま応用できます。

![Chakra UI: Badge と Tag の colorScheme バリエーション](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-16.png)

たとえば、`Tag`コンポーネントを考えてみてください。情報の種類を表す色（`info`: 青、`success`: 緑、`warning`: 黄、`error`: 赤）と、表示サイズ（`small` / `medium`）の掛け算になります。

これを色とサイズの2つの`Enum`で管理すれば、Figmaのバリアントは2軸のマトリクスになり、構造が明快です。

## `String`: 文字列

ボタンのラベルや入力欄のプレースホルダーなど、画面に表示されるテキストデータです。

ここでデザイナーが考えるべきはデータの不在です。もし文字列が空だったら、その領域は詰めるのか、あるいはプレースホルダーを出すのか。ユーザー名が極端に長かった場合、… で省略するのか、折り返すのか。これらはすべてプロパティの仕様として定義しておきたいところです。

文字列型のプロパティを追加するときに確認しておきたいことがあります。

- 空のとき何が起きるか決めたか（領域を詰める？ プレースホルダーを出す？）
- 最大文字数を超えたときの処理を決めたか（省略記号、折り返し、スクロール）
- 改行を含む可能性はあるか（1行テキストか複数行テキストか）
- 本当に自由入力が必要か（選択肢が決まっているなら`Enum`にできないか）

日本語だけでデザインしていると見落としがちですが、同じ意味のテキストでも英語になると幅が1.5〜2倍に膨らむことがあります。たとえば、日本語で「確認」と表示していたボタンが、英語では「Confirm」になります。横幅が固定されたボタンでは、テキストが溢れるか省略されて読めなくなります。

多言語対応の予定がなくても、テキストの長さが変動する前提でコンポーネントを組んでおくことは、堅牢な設計につながります。

たとえば、アイコンとテキストが横に並ぶボタンで、テキストが長くなったときにどうするか。アイコンを非表示にしてテキストを優先するのか、テキストを省略記号で切るのか、折り返して高さを広げるのか。これはコンポーネントの仕様として事前に決めておきたい判断です。

もうひとつ気をつけたいのが、テキストの縦方向の振る舞いです。Figmaのテキストボックスは `Auto Height` に設定すれば中身に合わせて高さが変わりますが、コードでも同じ挙動になるかはフレームワークや実装方法によって異なります。行の高さ（Line Height）がコンポーネント全体の縦幅にどう影響するかは、デザインとコードで差が出やすいポイントです。

![String型: テキストの振る舞い6パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-33.png)

## `Number`: 数値

バッジのカウント数（通知が3件あるときの「3」）や評価スコア（星4.5）など、数値を示すデータです。

文字列と数値の違いは、スプレッドシートを思い浮かべるとわかりやすいでしょう。

セルに数字を入れると右寄せになり、テキストを入れると左寄せになります。あの挙動が示すとおり、数字と文字列は根本的に異なるデータ型です。数値は合計や比較、フォーマット変換などの計算ができるのに対し、文字列はあくまで文字の並びにすぎません。

999+ のように上限を超えた場合の表示ルールや、0のときに非表示にするかどうかといった仕様も、数値型のプロパティに付随する重要な設計判断です。

数値型のプロパティを扱うときに確認しておきたいことです。

- 上限・下限を超えたときの表示を決めたか（999+、0件のときなど）
- 0のとき非表示にするか、0と表示するか
- マイナスの値はありえるか（ポイント残高、差分表示など）
- 単位の表示はコンポーネントの責任か、外から渡すか（円、件、%）

![Number型: 数値の表示ルール](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-45.png)

## `Date`: 日付と時刻

カレンダーの予定日、メッセージのタイムスタンプ、クーポンの有効期限。日付や時刻を扱うデータです。
これはFigmaでは表現することができないため、Stringのプロパティで扱うことになるでしょう。

私たちが画面上で見ている 2月17日 や 3日前 といった表示は、裏側では 2026-02-17T14:00:00Z のような機械が読む形式のデータを変換したものです。スプレッドシートでも、セルに日付を入れるとカレンダー形式で表示されますが、中身は表示を変えても意味が維持される日付データですよね。それと同じで、日付データには裏側のデータと画面に出す見た目という二層構造があります。

日付型のプロパティを設計するときの確認ポイントです。

- 日付のフォーマットはコンポーネント内部で決めるか、外部で決めてテキストとして渡されるか
- タイムゾーンの考慮は必要か（海外ユーザーがいるサービスでは要注意）
- 相対表示（3日前）と絶対表示（2月17日）のどちらを使うか、切り替えるか
- 未来の日付と過去の日付で表示を変える必要はあるか（締め切りのカウントダウン、イベント開始までの残り時間など）

ここまでの5つの型（`Boolean` / `Enum` / `String` / `Number` / `Date`）で、コンポーネント設計に必要な基礎は揃いました。以降の`Array`・`Object`・`Element`は、複雑なデータを扱うときに必要になる発展的な型です。今すぐ必要でなければ次の章に進んでも構いません。読み進める方のために、ここからはデータの構造（まとまり方）に関する型を見ていきます。

ひとつ実践的なコツを補足します。たとえば、更新日: 2026/01/01 と表示するUIがあるとき、Figma上のプロパティは 2026/01/01 のテキストだけにし、更新日というラベルはコンポーネント内に固定しておくと、実装との対応が明確になります。

![Date型: 日付の表示形式と設計判断](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-46.png)

## `Array`: 配列（リスト）

同じ種類のデータが複数あるとき、コンポーネントにはそのリストをまるごとプロパティとして渡します。タグの一覧、通知リスト、メニューの項目——こうしたケースです。

Figmaでいえば、同じコンポーネントを`Auto Layout`内に繰り返し配置する操作にあたります。コードではこれを配列として扱います。

同じ器に異なるデータを流し込む——これが配列型のUIの特徴です。各要素のテキストの内容、`Tag`の有無、ステータスの色はそれぞれ異なりますが、コンポーネント自体は同じものが使い回されます。

ただし、Figmaでは3件分のデータを置くと3件で固定されますが、実際のアプリでは0件になったり100件になったりします。デザイナーが意識しておきたいのは、0件・1件・大量にあるときのそれぞれの見え方です。

- 0件のとき何を表示するか（空状態のデザインは用意したか）
- 上限はあるか（無限に増えるのか、最大表示件数を設けるか）
- 大量にあるとき、無限スクロールかページネーションか
- 並び順は固定か、ユーザーが変えられるか

![Array型: リストの4つの状態](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-34.png)

## `Object`: オブジェクト（データのまとまり）

名前・アイコン・ステータスのような、複数の情報がひとかたまりになっているケースです。

Notionでいえば、データベースの1行がこれにあたります。ユーザーという1行に、名前・アイコン画像・ステータスがセットで入っているイメージです。

たとえば、ユーザーカードに渡すユーザーというデータを考えてみてください。名前、アイコン画像、ステータス。これらをバラバラのプロパティとして渡すこともできますが、ドメインコンポーネントではユーザーの情報一式としてまとめて渡すほうが自然です。

Figmaのプロパティパネルでは、こうしたデータのまとまりを直接表現する方法がありません。名前・アイコン・ステータスをバラバラのプロパティとして並べるしかないのです。しかし、コード側ではユーザーというひとつのまとまり（オブジェクト）として渡せます。

デザイナーが意識しておきたいのは、このコンポーネントに渡すデータは、個別の値なのか、まとまりなのか、という点です。`Avatar`なら画像URLだけで十分（個別の値）。`UserCard`ならユーザーの情報一式が前提（まとまり）。この判断が、コンポーネントを汎用にするかドメイン専用にするかの分かれ道です。

Figmaのプロパティパネルで見比べてみると、この違いがはっきりします。`Avatar`のパネルには`image`、`altText`の2項目だけ。一方`UserCard`には`userName`、`userImage`、`rating`、`status`、`isVerified`とずらりと並びます。

プロパティが20個並んだコンポーネントは、使う側にとって何をどう設定すればいいかわからないものになります。逆に粒度が粗すぎると汎用性がなくなります。

いま手元のFigmaで、プロパティが10個を超えているコンポーネントを探してみてください。それはドメイン専用として認識すべきサインかもしれません。

オブジェクトの中で特に気をつけたいのは、データの一部が欠けているケースです。ユーザー名はあるけどアイコン画像がない、評価スコアがまだ付いていない。こうした歯抜けのデータにどう対応するかを、コンポーネントの仕様として決めておく必要があります。

また、オブジェクトをまるごと受け取る設計は、そのコンポーネントが特定のドメインに紐づいていることを意味します。コンポーネント分割の章で触れたように、汎用コンポーネントは個々の値をバラバラに受け取り、ドメインコンポーネントはデータ一式をまとめて受け取るのが基本です。

`Object`を受け取るコンポーネントを作ろうとしているなら、それはドメインコンポーネントとして位置づけるのが自然でしょう。

![Object型: 個別の値 vs データのまとまり](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-47.png)

## `Element`: 要素

ここまでの型（`Boolean`、`Enum`、`String`、`Number`など）はすべて、テキストや数値といったデータを渡すものでした。しかし、プロパティに渡したいのがデータではなく、別のコンポーネントそのものというケースがあります。

Figmaで考えるとわかりやすいです。`Instance Swap Property`を使って、ある箇所にアイコンを差し込んだり、`Avatar`に差し替えたりします。

コードの世界ではこれを`Element`型と呼びます。好きなものを差し込める口を設けておく設計で、スロットとも呼ばれます。

たとえば、カードの説明文を表示する箇所を考えてみてください。通常はテキストを渡せば十分です。しかし、テキストの一部をリンクにしたい場合はどうでしょうか。`String`型ではここからここまでがリンクという情報を表現できません。リンクを含んだUIのかたまりをまるごと渡す必要があります。

あるいは、リストアイテムの左側に置くものが、ある画面ではアイコン、別の画面では`Avatar`。こうした場合にスロット（`Element`型のプロパティ）があれば、何を差し込むかは利用者に委ねられます。

スロットの威力がもっともわかりやすいのは、バリアントの爆発を防げる点です。

アイコン付きボタンの例で考えてみましょう。デザイナーは `LeftIcon` / `RightIcon` / `BothIcons` / `NoIcon` という4つのバリアントを作りがちです。しかし、スロットの発想を使えば、ボタンの左右に好きなものが入るエリアを用意するだけで済みます。アイコンでも、バッジでも、何も入れなくてもよい。

![Button のスロット構造: 差し込み口を設けることでバリアント爆発を防ぐ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-04.png)

Figmaでは、`Instance Swap Property`を使ってスロットを表現します。設計のポイントは2つです。

- 何も入れないを選択肢に含める。空のプレースホルダーコンポーネントを候補に入れておけば、アイコン不要な場面でも対応できる
- 差し込める対象を制約する。`Instance Swap Property`で差し替え候補を同じカテゴリに限定し、意図しない使い方を防ぐ

設計時に考えておきたいのは、その箇所にテキストを渡すだけで本当に十分か、それとも将来的にUIのかたまりを渡す必要が出てこないか、という点です。最初はStringで足りていても、後からリンクやアイコン付きテキストが必要になるケースは少なくありません。

![`Element`型（スロット）: 差し込み口で中身を自由に](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-48.png)

コンポーネントを柔軟にする方法は2つあります。プロパティ（設定値）をどんどん増やす方法と、スロットのように小さな部品を差し替える方法です。前者をConfiguration（設定型）、後者をComposition（組み合わせ型）と呼びます。プロパティが10個、20個と膨らんできたら、それはスロット（Composition）への切り替えどきです。

![Configuration vs Composition: 設定の山か、組み合わせか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-50.png)

ここまで個々の型を見てきました。ここからは、複数のプロパティが組み合わさったときにどう振る舞うかを考えます。

# プロパティの直交性: 組み合わせが壊れない設計

Figmaでバリアントを追加したとき、既存の組み合わせが意図しない見た目になった経験はないでしょうか。サイズを増やしたら色との組み合わせが崩れた。新しいプロパティを足したら、既存のプロパティとの関係が曖昧になった。

それはプロパティ同士が暗黙に依存していることが原因かもしれません。

ここまで個々の型を見てきましたが、実際のコンポーネントではプロパティが複数組み合わさって使われます。このとき大事になるのが、プロパティ同士が互いに干渉しないという考え方です。これを直交性と呼びます。

あるプロパティの値を変えたとき、他のプロパティの意味や振る舞いまで変わってしまうなら、そのプロパティ同士は独立していません。独立したプロパティは、どんな組み合わせでもそれぞれが決まり通りにはたらきます。Figmaでバリアントを設計するとき、この感覚があると組み合わせの破綻を未然に防げます。

`Boolean`の章で、小さいと大きいのトグルを別々に持つと矛盾するという話をしました。これは直交性が崩れた典型例です。ここではもう少し踏み込んで、`Enum`同士の設計でこの考え方がどう効いてくるかを見ていきます。

たとえば`Button`に`size`と`variant`の2つのプロパティがあるとします。`size`は`S`・`M`・`L`の3段階、`variant`は`primary`・`secondary`・`destructive`の3種類。この2つが直交していれば、どの組み合わせでもそれぞれが決まり通りにはたらきます。

![直交性: size と variant の組み合わせがすべて成立する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-05.png)

Radix UIの実装例を見ると、この違いがさらに明確になります。`Toggle`は押すたびにON/OFFが切り替わるボタン、`Switch`は設定の有効/無効を切り替えるコントロール。見た目は似ていますが、ユーザーの操作意図が異なるため、別コンポーネントとして設計されています。

![Radix UI: Toggle vs Switch の実装例](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-15.png)

`size`を`S`から`L`に変えても`variant`の見た目は変わらない。`variant`を`destructive`に変えても`size`は影響を受けない。3×3＝9通りすべてが成立します。

もし「`destructive`のときは`S`が使えない」「`secondary`の`L`だけ角丸が変わる」といった暗黙の制約があったら、組み合わせるたびにルール確認が必要になります。

Notionのデータベースで考えるとわかりやすいです。優先度と担当者という2つのカラムがあるとして、優先度を高に変えても、担当者のリストは何も変わりませんよね。これが独立している状態です。もし優先度を変えた瞬間に担当者の選択肢が勝手に絞り込まれたら、使う人は混乱します。コンポーネントのプロパティも同じです。

たとえば、タグの部品に色の種類と色の強さの2つのプロパティがあるとします。色の種類は情報・成功・警告・エラーといった意味を表し、色の強さは塗りつぶし・薄い背景・背景なしといった濃度を表します。この2つは独立しています。種類を変えても強さの振る舞いは変わらないし、強さを変えても種類の意味は変わりません。

![直交性: colorScheme と variant の組み合わせマトリクス](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-28.png)

## 直交性が壊れるとき

ここで、背景なしを色の強さではなく形状のプロパティに入れてしまうとどうなるでしょうか。形状を変えただけなのに背景色が消え、色の種類と強さの組み合わせで決まるはずの配色システムが無効化されます。形状のプロパティが、色のシステムに暗黙的に優先してしまう。これが直交性の崩れです。

背景なしを色の強さ側に置いておけば、背景はないけど角丸はついているように、それぞれのプロパティが独立して動いた結果がそのまま反映されます。視覚的に意味が薄い組み合わせが生まれることはありますが、プロパティ間に暗黙の依存が生まれるよりもずっと健全です。

プロパティを設計するときに意識したいのは、この問いです。

- このプロパティの値を変えたとき、他のプロパティの意味や動きまで変わらないか
- 2つのプロパティの組み合わせに暗黙の優先順位が生まれていないか
- ひとつのプロパティが複数の関心事をまとめて扱っていないか

直交性が保たれていると、プロパティを追加するたびに既存の組み合わせを紐解く必要がありません。逆に、プロパティ間に暗黙の依存があると、機能を足すたびに優先順位の整理が必要になり、そのルールは時間とともにチーム内で忘れられていきます。

Figmaの[Propstar](https://www.figma.com/community/plugin/1116018586739867857/propstar)というプラグインを使うと、コンポーネントのすべてのプロパティ組み合わせを一覧表示できます。直交性が保たれているかの確認や、プロパティのヌケモレの発見に便利です。

# トークンの共有: 複数コンポーネントの一貫性を保つ

ここまでは個々のコンポーネントのプロパティ設計を見てきました。もう一歩引いて、複数のコンポーネントにまたがる設計について触れておきます。

色やサイジングの体系は、複数のコンポーネントで使い回せるように設計しておくと便利です。こうした共通の値に名前をつけて一元管理する仕組みをトークンと呼びます。Figmaでいえばスタイルやバリアブルに近い概念です。

Figmaでは、`Tag`の色を変えたければ`Tag`のスタイルを編集し、`Callout`の色も変えたければ`Callout`のスタイルも別途編集する——というコンポーネントごとの作業になりがちです。

しかしコードの世界では、共通のトークンを参照する仕組みがあれば、トークンの値をひとつ変えるだけですべてのコンポーネントに反映されます。

たとえば、`Tag`の info と `Callout` の info が同じセマンティックカラーを参照していれば、色を変えたいときに一箇所の修正で両方に反映されます。バラバラに定義していると、デザイナーが個別に色を選ぶたびに微妙なズレが蓄積し、`Tag`は青いのに`Callout`は水色、という不一致がいつの間にか生まれます。

![トークンの共有: 複数コンポーネントの一貫性を保つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-06.png)

色だけの話ではありません。兄弟関係にあるコンポーネント（`Button` / `IconButton` / `CopyButton`など）では、縦幅やアイコンのサイズも共通のトークンを参照しておくと一貫性を保ちやすくなります。

こうしたトークンを一元管理しておけば、`Tag`の配色を微調整したいときに、共通構造を持つすべてのコンポーネントに変更が波及します。トークンを使わず個別のコンポーネントに値を直接書き込んでいたら、ひとつずつ直すことになります。

Figma上でデザイントークンを管理するプラグインとしては、[Tokens Studio](https://tokens.studio/)が広く使われています。JSONベースでトークンを定義でき、コードとの同期にも対応しています。

# UIスタック: コンポーネントが取りうる5つの状態

ここまでプロパティの型と組み合わせについて見てきました。ここからは、コンポーネントが取りうる状態の設計に移ります。

デザインするとき、データが完璧に入った理想的な状態を中心に描くのは自然なことです。しかし、コンポーネントを実装するときに必要になるのは、すべての状態の定義です。

こうしたものは往々にしてエンジニアがヌケモレを教えてくれることが多いのですが、リリース直前であまりきちんとデザインできなかったという経験はよくあるのではないかと思います。

[Scott Hurff](https://www.scotthurff.com/posts/why-your-user-interface-is-awkward-youre-ignoring-the-ui-stack/)（UIデザイナー・著述家）が提唱したUIスタックという概念では、UIには以下の5つの状態があるとされています。

1. `Ideal State`: データが完璧に入った状態。Figmaで最初にデザインする状態
2. `Empty State`: データが空の状態。リストが0件のとき、`Avatar`の画像がないとき
3. `Loading State`: 読み込み中。スケルトンスクリーンやスピナー
4. `Partial State`: データが不完全な状態。ユーザー名はあるけどアイコンがない、商品情報はあるが画像が未登録、など
5. `Error State`: 読み込み失敗やバリデーションエラー

新しいコンポーネントを設計するとき、以下の5つの状態をすべて定義してから実装に渡してください。

この5つの状態の区別は、見た目が似たコンポーネントを分離する根拠にもなります。

MUIでは、ユーザーへのフィードバックという同じ目的を持ちながら、[`Alert`](https://mui.com/material-ui/react-alert/)（ページ内に常駐するお知らせ欄）、[`Snackbar`](https://mui.com/material-ui/react-snackbar/)（画面下部に一瞬だけ出る通知。トーストとも呼ばれます）、[`Dialog`](https://mui.com/material-ui/react-dialog/)（操作を中断して確認を求めるモーダル）を別々のコンポーネントとして提供しています。

`Alert`は`Error State`や`Partial State`の表示手段、`Snackbar`は操作完了後の一時通知、`Dialog`は操作前の確認。見た目が似ていても、UIスタックのどの層で使われるかが違えば、コンポーネントとして分けるのが自然です。

- `Ideal State` — データが揃った理想の見た目
- `Empty State` — データが0件のとき。「まだ○○がありません」のような案内を添える
- `Loading State` — 読み込み中。スケルトンかスピナーかを指定する
- `Partial State` — 一部のデータが欠けている場合の見た目（アイコン未設定、評価なし等）
- `Error State` — 読み込み失敗時。ユーザーが次に何をすればいいかを示す



これら5つの状態は、以下のように遷移します。

![UIの5つの状態と遷移](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-07.png)

ユーザーカードや求人リストなどのドメインコンポーネントでは、これらの状態をあらかじめ定義しておく必要があります。読み込み中、データが空、エラーといった状態ごとの見た目をFigmaのバリアントとしてデザインしておきます。たとえば、`state` というバリアント軸に `ideal` / `empty` / `loading` / `error` を用意する方法が一般的です。

成功したときの理想的な画面だけでなく、失敗時やデータ欠損時の見た目もコンポーネントの仕様に含めておくと、実装時にこの状態のデザインがないという差し戻しがなくなります。
そして、用意されているにしてもコンポーネントや画面ごとに明確な基準なく揺れがちなポイントです。コンポーネント設計のチェックリストに組み込んだり、パターンを策定しておくとよいでしょう。

## `Partial State`: もっとも見落としやすい状態

特に`Partial State`はデザイナーが最も見落としやすい状態です。`Ideal State`と`Empty State`は意識しやすい——データがあるか、ないか。しかし現実のデータはある/ないの二択ではなく、一部だけあることのほうが圧倒的に多いのです。

たとえば、ユーザープロフィールカードで考えてみてください。ユーザー名はあるがプロフィール画像を登録していない。評価スコアはあるがレビュー件数が0件。自己紹介文は入力されているが、スキルタグが未設定。

これらの組み合わせは膨大です。すべてをデザインするのは現実的ではありませんが、少なくとも各データ項目が欠けたとき、その領域をどう扱うかのルールは決めておく必要があります。

実践的な対処としては、データ項目ごとにフォールバック（代替表示）を定義しておくことです。

![Partial State: データ欠損時のフォールバック](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-35.png)

| データ項目       | 欠損時の代替表示   |
| ---------------- | ------------------ |
| プロフィール画像 | イニシャルアイコン |
| 評価スコア       | 「—」を表示        |
| 自己紹介文       | 領域ごと詰める     |
| スキルタグ       | セクション非表示   |

こうしたルールがコンポーネントの仕様に含まれていれば、データが欠けても画面が壊れません。

## プロパティと状態の違い

ここでひとつ、デザイナーが混乱しやすいポイントがあります。

UIスタックで扱っている `Loading` や `Error` は、コンポーネントの状態です。これは前の章で扱った外から渡す設定値（プロパティ）とは性質が異なります。

違いを日常に置き換えてみます。信号機でいえば、この信号機は車道用であるというのが外から設定されるプロパティです。一方、いま赤か青かはその信号機自身が切り替える状態です。

Figma上では、プロパティもバリアントとして表現されます。しかしコードでは、外から渡す設定値（`props`）とコンポーネント自身が管理する状態（`state`）は明確に区別されます。

この区別をFigma上でも見分けやすくするために、状態を表すプロパティに目印をつけておくのが有効です。たとえば、`_state` や `_isLoading` のように `_` プレフィックスをつけて命名しておけば、外から渡す設定値なのかコンポーネント内部の状態なのかが一目でわかり、デザインと実装の間の認識のズレを防げます。

ここまで扱った `Loading` や `Error` はシステム側の状態——データの有無やAPIの成否によって決まるものでした。コンポーネントにはもうひとつ、ユーザーの操作に伴う見た目の変化があります。これもまた状態の一種ですが、性質が異なるので分けて整理します。

# インタラクション状態: ユーザーの操作に応じた見た目の変化

ボタンの上にマウスカーソルを乗せたとき、押し込んでいるとき、操作できない状態のとき。これらはそれぞれ `Hover`、`Pressed`、`Disabled` と呼ばれます。Figmaでは `Interactive Components` の機能で表現できます。

ボタンのインタラクションには「弧（arc）」があります。default → hover → focused → pressed → waiting（[Curtis, 2016](https://medium.com/eightshapes-llc/buttons-in-design-systems-eac3acf7e23)）。この一連の流れを切れ目なくデザインすることが、ボタンのインタラクション品質を決めます。

ここで大事なのは、こうしたインタラクション状態のルールをコンポーネントごとに個別に決めないことです。`Hover`時は現在の背景色に対してオーバーレイを8%重ねる、`Disabled`時は`opacity`を38%に下げる——こうしたルールをトークンとして一元管理しておけば、新しいコンポーネントを作るときにゼロから設計する必要がなくなります。[Material Design 3のState Layers](https://m3.material.io/foundations/interaction/states/state-layers)がこの考え方の参考になります。

デザイナーが見落としがちなのがフォーカス状態です。マウスを使わずキーボードのTabキーで画面を操作するユーザーにとって、いまどの要素にフォーカスがあるかを示すフォーカスリング（枠線）は不可欠な手がかりです。フォーカスリングの色、太さ、オフセットをコンポーネント横断で統一しておくことが重要です。

すべてのインタラクティブなコンポーネントに対して、`Hover`、`Pressed`、`Disabled`、`Focus`の見た目を定義しておくと、実装の抜け漏れが減り、操作方法を問わず一貫した体験を提供できます。

![インタラクション状態: 5つの見た目を統一ルールで管理する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-29.png)

## アクセシビリティ: コンポーネントに組み込む

アクセシビリティを個々の画面で毎回対応していくのは、現実的に大変です。だからこそ、コンポーネントに吸収できるところは吸収しておきたい。コンポーネントレベルで組み込んでおけば、使うだけで基準を満たせる状態が作れます。

たとえば、色のコントラスト比をトークンレベルで保証しておけば、そのトークンを使うすべてのコンポーネントが自動的に[WCAG](https://www.w3.org/WAI/standards-guidelines/wcag/)基準を満たします。前述のフォーカスリングも同じです。コンポーネント横断で統一しておけば、個別に対応する必要がなくなります。

アイコンやイラストに代替テキスト用のプロパティ（`altText` / `ariaLabel`）を設けておくことも、コンポーネントへの吸収のひとつです。スクリーンリーダーを使うユーザーにとって、この情報がなければアイコンは存在しないのと同じです。

こうした対応をコンポーネントの仕様に含めておくと、利用する側が個別に対応する手間がなくなり、プロダクト全体のアクセシビリティが底上げされます。

ただし、アクセシビリティはコンポーネント単体ですべて担保できるわけではありません。ページ全体の構造、読み上げ順序、ランドマークの設計など、コンポーネントの外で決まる要素も多くあります。コンポーネントに吸収できるところを吸収しつつ、プロダクト全体としてのアクセシビリティ方針は別途チームで議論しておく必要があります。

UIスタックとインタラクション状態でコンポーネントの状態設計を扱いました。ここからは、Figmaでは表現しきれないコードとの差分に踏み込みます。

# Figmaだけでは伝わらない変数の性質: コードとの差分を知る

ここまで紹介した型はFigmaのプロパティパネルでもある程度表現できます。しかし、コードの変数にはFigmaだけでは伝えきれない性質がいくつかあります。

知っておくだけで、エンジニアとの会話がぐっとスムーズになるポイントです。

## 必須と任意: デフォルト値で使いやすさが決まる

なぜこの区別が重要なのか。コンポーネントのプロパティが10個あるとき、そのすべてが毎回指定必須だとしたら、使うたびに10項目を埋める手間がかかります。

逆に、ほとんどが任意でデフォルト値を持っていれば、使う側は変えたいところだけを指定すればよい。必須と任意の設計は、コンポーネントの使いやすさを直接的に決めます。

必須を最小限にとどめ、よく使われる値をデフォルトに設定しておくことで、8割のユースケースは何も指定しなくてもそのまま使える状態を目指します。

コードでは、変数が必ず渡さなければならないか、省略してもよいかが明確に定義されます。省略できる変数には通常、デフォルト値が設定されています。

たとえば、ボタンコンポーネントの `size` が任意で、デフォルト値が `Medium` であれば、利用者が `size` を指定しなくても中サイズのボタンが表示されます。一方、`label` が必須であれば、テキストなしでボタンを使うことはできません。

Figmaのプロパティパネルには、必須かどうかや省略時のデフォルトを表現する仕組みがありません。すべてのプロパティに常に何らかの値が入った状態で表示されます。

そのため、何がデフォルトで何が意図的な指定なのかが区別できないのです。

これを補うには、Description欄に「デフォルト: Medium」のように明記しておくのがもっともシンプルです。また、何も指定しなかったときの見た目を最初のバリアントとして配置しておくと、利用者がこれがデフォルトかと直感的に理解できます。

ただし、デフォルト値は一度決めたら簡単には変えられません。コードの世界では、デフォルト値を変更すると、明示的に値を指定していなかったすべての箇所で表示が変わります。

`size`のデフォルトを`Medium`から`Small`に変えれば、何も指定していないボタンがすべて小さくなる。影響範囲が広いぶん、デフォルト値の決定はかなり慎重におこなう必要があります。

![必須と任意: デフォルト値で使いやすさが決まる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-36.png)

## 条件付き表示: Figmaとコードでプロパティの数がズレる理由

Figmaでコンポーネントを作るとき、ある要素を表示/非表示にするためにトグルを追加した経験はないでしょうか。エンジニアに「このトグル、コード側では要らないんですよ」と言われて戸惑ったことがあるかもしれません。Figmaの制約とコードの表現力の違いが現れる場面です。

たとえば、カードにサブタイトルを出すかどうかを切り替えたいケースを考えてみます。実はコード側では、この挙動をもっとシンプルに実現できます。

コード側ではサブタイトルのテキストというプロパティが1つあれば十分です。テキストが渡されれば表示し、渡されなければ領域ごと消える。1つのプロパティで中身と表示/非表示を同時に制御できます。

しかしFigmaでは、この挙動を再現するためにサブタイトルを表示するかどうかのトグルとサブタイトルのテキストという2つのプロパティが必要です。コードでは1つで済むことが、Figmaでは2つに分かれるわけです。

こうしたFigmaと実装のプロパティ数のズレは避けられません。大切なのは、このズレがあることをチームで認識し、ルール化しておくことです。

認識が共有されていないと「Figmaと実装でプロパティの数が合わない」という無駄な議論が繰り返されるためです。

![条件付き表示: Figmaでは2つ、コードでは1つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-37.png)

ここまで、コンポーネントが何を受け取るかを扱いました。次はどこにどう置くか——レイアウトの設計です。
