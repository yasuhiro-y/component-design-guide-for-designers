長い記事にお付き合いいただき、ありがとうございます。

この記事では、デザインシステムのコンポーネント設計を、原則から具体的な変数の型まで段階的に掘り下げてきました。

![本書の構成と知識の積み上げ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-10.png)

一貫しているのは、コンポーネントは単なるUIの見た目ではなく、チームの共通言語であるということです。命名ひとつ、変数の型ひとつが、デザインと実装の間の翻訳コストを左右します。

Figmaとコードの構造を揃える究極の理由は、ツールの一致ではなく認知の一致——チームの脳内モデルを一致させることにあります。

コンポーネント名、プロパティの型、レイヤーの階層がFigmaとコードで対応していれば、会議で「あのコンポーネントのあのプロパティ」と言ったとき、全員が同じものを思い浮かべられます。

この「メンタルモデルの同期」こそが、デザインシステムがコミュニケーションコストを下げる本質的なメカニズムです。

![メンタルモデルの同期: Figma・コード・チームの認知が一致する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-52.png)

# この記事のKey Takeaway

## 原則

- **再利用性（SSOT）**: 一箇所を直せば全部直る。マスターコンポーネントを1つ持ち、全画面でインスタンスを使う
- **変更のしやすさ**: 変更コストを下げる設計を最初から意識する。後から変えるコストは想像以上に高い
- **拡張のしやすさ**: 既存を壊さずに新しいバリアントやプロパティを追加できる設計にする
- **経路依存性**: 初期の選択が未来を縛る。命名・ディレクトリ構造・ライブラリ選択——すべてに同じ力学が働く
- **関心の分離**: コンポーネントは中身だけに責任を持ち、配置は親に任せる

## コンポーネント分割

- コンポーネント化の判断基準は「一箇所を直せば全部直る状態にしたいか」
- Atomic Design（大きさで分ける）、FSD（目的で分ける）、フラット配置の3つのアプローチがある
- Atomic Designではmolecules/organismsの境界が人によってバラバラになりがち
- FSDの依存方向は一方通行: 上位レイヤーは下位を使えるが、逆はNG。`Button`が`UserCard`に依存してはいけない
- コンポーネント数が20〜30を超えたら階層化を検討する

## 汎用とドメインの分離

- **汎用コンポーネント**: 特定のデータ構造に依存しない。別のサービスでもそのまま使えるかが判断基準
- **ドメインコンポーネント**: 特定のデータ構造（オブジェクト）に特化する。データの表示ルールをコンポーネント内部に閉じ込められる
- 汎用コンポーネントにはビジネスロジックを含めない。表示テキストは呼び出し側が渡す
- 境界は一意に決まらないこともある。チームで判断基準を議論し、ケーススタディを積み重ねてナレッジにする
- オブジェクトをまるごと受け取る設計なら、ドメインコンポーネントとして位置づけるのが自然

## 早すぎる共通化の罠

- 見た目が似ていることと、目的やドメインが同じことは別の話
- 無理に統合すると互いに無関係なプロパティが混在し、複雑なコンポーネントになる
- 共通化の判断は、同じパターンが繰り返し現れてからでも遅くない（AHA原則）

## 命名

- **名前は設計の一部**: 最初につけた名前がコード・ドキュメント・チームの会話に定着する。後から変えるコストは高い
- 状態やバリエーションを名前に含めない。`RedButton`ではなく`Button`にして、バリアントで切り替える
- ドメインコンポーネントの名前はAPIのデータモデル名と揃える（`ShiftCard`など）
- 汎用コンポーネントにはデータモデル名を入れない（`UserAvatar`ではなく`Avatar`）
- 命名規則が整っているとAIコード生成ツールも自社の命名体系に沿った補完をする

## 変数の型

- **`Boolean`**: ON/OFFの2値。排他的な状態（`Small`/`Large`）を`Boolean`で分けると矛盾が生じる
- **`Enum`**: 決まった選択肢から1つ選ぶ。追加は安全、削除や名称変更は破壊的変更
- **`String`**: 自由入力テキスト。空文字列のケースを必ず定義する
- **`Number`**: 数値。上限・下限やステップを明示する
- **`Array`**: 配列。0件・1件・多数の3パターンを考慮する
- **`Object`**: 複数の情報のまとまり。ドメインコンポーネントはデータ一式をまとめて受け取る
- **`Element`（スロット）**: 差し込み口を設けてバリアント爆発を防ぐ。Instance Swap Propertyで表現する

## プロパティの直交性

- プロパティ同士が互いに干渉しない設計が重要
- あるプロパティの値を変えても、他のプロパティの意味や振る舞いが変わらないようにする
- 関心が異なるなら、見た目が似ていても別コンポーネントにする（例: Toggle vs Switch）
- ひとつのプロパティに複数の関心事をまとめて扱わない

## UIスタック: 5つの状態

- **Ideal / Empty / Loading / Partial / Error** の5状態をすべて定義してから実装に渡す
- **Partial Stateが最も見落としやすい**: データは「ある/ない」の二択ではなく、「一部だけある」ことのほうが多い
- データ項目ごとにフォールバック（代替表示）を定義しておく
- 外から渡す設定値（props）とコンポーネント自身が管理する状態（state）は区別する
- 状態を表すプロパティには `_` プレフィックスなど目印をつけると認識のズレを防げる

## インタラクション状態

- **Hover / Pressed / Disabled / Focus** の見た目をすべてのインタラクティブなコンポーネントに定義する
- ルールをトークンで一元管理し、コンポーネントごとに個別に決めない
- フォーカスリングの色・太さ・オフセットはコンポーネント横断で統一する

## Figmaとコードの差分

- **必須と任意**: デフォルト値で使いやすさが決まる。8割のユースケースは何も指定しなくても使える状態を目指す
- **条件付き表示**: Figmaではトグル＋テキストの2操作、コードでは値の有無で1つで制御。このズレを認識し、ルール化しておく
- デフォルト値は一度決めたら簡単に変えられない。影響範囲が広いため慎重に決定する

## レイアウト

- コンポーネントは自分の中身だけに責任を持ち、どこに置くかは親に任せる
- **外側の余白（margin）はコンポーネントに含めない**: 親のAuto Layout / gapで制御する
- **区切り線**: `showDivider`（`Boolean`）で制御するか、親のループで挿入するか方針を決める
- **幅の振る舞い**: Fill（親に合わせる）/ Hug（中身に合わせる）/ Fixed（固定）の3パターンをデフォルトとして明示する

## トークンの共有

- 色・サイズをトークンとして一元管理し、複数コンポーネントの一貫性を保つ
- セマンティックカラーを兄弟コンポーネント間で共有すれば、一箇所の修正で全体に反映される
- トークンを使わず個別に値を書き込むと、微妙なズレが蓄積する

## アクセシビリティ

- コンポーネントに組み込めるところは組み込む。使うだけで基準を満たせる状態を作る
- コントラスト比をトークンレベルで保証する
- アイコンやイラストに代替テキスト用のプロパティ（`altText` / `ariaLabel`）を設ける
- コンポーネント単体で全て担保できるわけではない。ページ構造や読み上げ順序は別途議論する

## アセット管理

- **コード実装 vs 画像埋め込み**: 今後変わる可能性があるかで判断する。変更が想定されるならコード実装
- アイコンはSVGまたはアイコンフォントで管理する。PNG/JPGは色違いのたびに別ファイルが増える
- SVGの色は固定値ではなく `currentColor` で親のテキスト色に自動追従させる
- 既存ライブラリ＋独自アイコンのハイブリッド運用では、線の太さや角丸のルールを統一する

## 安全な変更と破壊的変更

- **増やすのは簡単、変えるのは大変**: 新しいバリアント追加は安全、プロパティ名の変更は破壊的
- Figmaではプロパティを自由に変更でき、インスタンスは自動追従するが、コードではそうはいかない
- この非対称性を意識するだけで、変更の提案のしかたや移行計画の立て方が変わる

## ライフサイクル管理

- コンポーネントは作ることより、**終わらせることのほうが難しい**
- [Deprecated] マークで非推奨を明示し、代替コンポーネントを説明欄に記載する
- 方針がないと使われなくなったコンポーネントがゾンビのように残り続ける

## 例外の許容と現実的な対処

- 100%準拠を目指さない。90%の定型と10%の例外を最初から織り込む
- Detach（コンポーネント解除）の前に4つの選択肢を検討する: 組み合わせ → バリアント追加 → 新規作成 → 例外許容
- デザインシステムから外れた実装を「失敗」ではなく「データ」と見なし、フィードバックループを回す
- FigmaとコードのUIが完全一致している必要はない。インターフェース（プロパティの名前と型）が一致していることのほうが重要

## AI時代の設計

- 命名規則・型定義・UI状態の定義が整ったデザインシステムは、AIコード生成の精度を引き上げる
- デザイナーが仕組みを理解し、エンジニアと共通言語を持つことの価値は、AI時代にさらに高まる

デザインシステムのコンポーネント設計は、一度読んで完全に理解できるような分野ではありません。実際のプロダクト開発の中で議論し、手を動かし、失敗し、直していく中で少しずつ身についていくものです。

実装とデザインで会話が通じた瞬間や、Figmaのプロパティ設計がそのままコードに反映されたのを見た瞬間——そうした小さな手応えの積み重ねが、視野を広げてくれます。

この記事は、そのときに立ち返れるリファレンスとして使ってもらえればと思っています。全部を一気に取り入れる必要はありません。

いま自分のチームで課題になっている章から読み直してみる、チームの会話で、これ記事に書いてあったなと思い出す。そういった使い方で十分です。

そしていま、AIがコードを書く時代に入りつつあります。命名規則が整い、型が明確で、設計意図が言語化されたデザインシステムは、人間の開発者だけでなくAIにとっても最良のインプットになります。
