FigmaやSketchのおかげで、デザイナーもコンポーネントの概念には馴染んできたのではないでしょうか。

コンポーネントという言葉は広い意味で使われます。ソフトウェアのモジュール、ハードウェアの部品、ビジネスプロセスの構成要素——いずれも「コンポーネント」と呼ばれることがあります。
この記事では、UIを構成する再利用可能な部品に限定して扱います。Figmaのコンポーネント機能で作るマスターコンポーネントとインスタンスの関係や、コードの関数コンポーネントがこれにあたります。

なぜ私たちはコンポーネントという単位で考えるのでしょうか。

それは、プロダクトを変更しやすくし、一貫性を保つためです。

Kevin Muldoonは[What Design Systems Actually Do](https://www.designsystemscollective.com/what-design-systems-actually-do-ea8a3daba32a)の中で、デザインシステムが提供する価値を間接化・カプセル化・制約・意味の符号化・合成・慣習という6つの抽象化で整理しています。この章では、その6つに経路依存性を加えた7つの原則を紹介します。これらを押さえておくと、後の章で登場するプラクティスの背景が見通せるようになります。

# 間接化（Indirection）: 一箇所を直せば全部直る

トークンやマスターコンポーネントを介して、変更を一箇所に集約する仕組み。これが間接化です。「再利用性」と「変更のしやすさ」は、同じメカニズムの表と裏です。

同じものを何度も作らない。一度作った品質をどこでも再現できることは、ユーザー体験の安定につながります。Figmaでマスターコンポーネントを更新すれば、すべてのインスタンスに変更が反映されます。コードでも同様です。ボタンの押し心地やエラーの表示方法が画面ごとにバラバラだと、ユーザーは使うたびに学び直す必要があります。

組織の視点で見れば、コンポーネント化はデザインと実装のコスト削減につながります。共通のコンポーネントがなければ、同じUIを作るたびにデザイナーごとの判断が入り、品質のばらつきを引き起こします。組織として決めたデザインをコンポーネントに落とし込んでおけば、誰が使っても同じ品質が再現でき、特定のデザイナーに依存せずに一貫性を維持できます。

たとえば、ブランドカラーを青から赤に変更するとします（別の意味で大変ですね！）。バラバラに実装されていたら、ボタンのある画面すべてをひとつずつ直さなければなりません。コンポーネントで管理されていれば、トークンの値をひとつ書き換えるだけで済みます。

実際にはブランドカラーの全面変更より、プライマリボタンの角丸を8pxから12pxに統一する、フォントサイズのベースを14pxから16pxに上げるといった地味な変更のほうが頻繁に起こります。こうした変更も、コンポーネント化されていれば一箇所の修正で全画面に反映できます。

デザイナーが少人数でも大規模なプロダクトを運用できるのは、このレバレッジが効いているからです。同じUIを1から作り直す工数が減り、新しい機能の開発に時間を使えるようになります。

![間接化: 1箇所の変更がすべてに届く](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-23.png)

# カプセル化（Encapsulation）: 複雑さを隠す

内部の複雑さを隠し、使う側にはシンプルなインターフェースだけを見せる。これがカプセル化です。ひとことで言えば、**ひとつの部品にひとつの責任を持たせること**でもあります。

たとえば、`UserCard`コンポーネントの中に、ユーザーデータを取得するロジックが埋め込まれていたとします。画面上ではきれいに動きます。しかし、同じカードを別の画面で「お気に入り一覧」に使いたくなったとき、データ取得先が決め打ちになっているので使い回せません。見た目だけ欲しいのに、データ取得のロジックがくっついてくるからです。

結果として、ほぼ同じ見た目の`UserCard2`が生まれます。この種の「似て非なるコンポーネント」の増殖は、カプセル化が崩れている兆候です。

もし`UserCard`が「受け取ったデータを表示する」ことだけに責任を持ち、「どこからデータを取ってくるか」を呼び出す側に任せていれば、どの画面でもそのまま使い回せます。Figmaでいえば、マスターコンポーネントが見え方を決め、インスタンス側がテキストや画像を差し替える関係と同じです。

この考え方があると、Figmaで修正したとき何に影響するかが予測でき、エンジニアに聞く前に安全な変更範囲を判断できます。バグ修正の影響範囲が局所化され、ある画面を直したら別の画面が壊れた、という事故を防げます。

## 3つの分離レイヤー

カプセル化は、コンポーネント設計のさまざまな場面で顔を出します。この記事では、以下の3つのレイヤーを順番に扱っていきます。

- **見た目とデータの分離**: コンポーネントは表示に専念し、どんなデータを取ってきて渡すかは呼び出す側が担う
- **構造とスタイルの分離**: 骨組みと見た目の装飾を切り離す。後述するHeadless UIの思想。[Shadcn/ui](https://ui.shadcn.com/)はこの分離をライブラリレベルで体現した実例で、[Radix UI](https://www.radix-ui.com/primitives)が提供する骨組み（振る舞い＋アクセシビリティ）に[Tailwind CSS](https://tailwindcss.com/)で見た目を上書きする構成になっている
- **汎用とドメインの分離**: どこでも使える部品（`Button`や`Avatar`）と、特定の機能に特化した部品（`JobCard`）を混ぜない。コンポーネント分割の章でくわしく扱う

![カプセル化: 3つの分離レイヤー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-24.png)

`UserCard`ひとつをとっても、3つの分離が見えます。見た目（レイアウトや色）とデータ（ユーザー名やアイコンURL）は分離すべきですし、骨組み（`Auto Layout`の構造）とスタイル（色・角丸）も分けられます。`UserCard`自体はドメインコンポーネントですが、その中で使う`Card`（枠）や`Avatar`（アイコン）は汎用コンポーネントです。

責任を分けておくからこそ、片方だけを変えたり、別の組み合わせで再利用したりできます。レイアウトの章で扱う、コンポーネントの中身（`padding`）と配置（`margin`）を分ける話も、カプセル化そのものです。

# 制約（Constraint）: 選択肢を絞り、判断の負荷を下げる

レストランで「10品のコース」と「何でもお作りします」のどちらが注文しやすいでしょうか。選択肢を意図的に絞ることで、判断の負荷を下げる。これが制約の原則です。

色を例にとりましょう。ディスプレイが表現できる色は約1680万色です。しかし、プロダクトで使う色が1680万色あったら、誰もデザインの一貫性を保てません。10色程度のセマンティックカラーに絞ることで、どの画面でも意味のある配色が再現できるようになります。

スペーシングも同じです。`margin`や`padding`に「好きな数字を入れてよい」とすると、14px, 17px, 23pxのような半端な値が乱立します。4/8/12/16/24/32のスケールに制約すれば、誰が作っても整ったリズムが生まれます。

![制約: 選択肢を絞り、判断の負荷を下げる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-53.png)

変数の章で扱うプロパティの型も制約の一形態です。`Boolean`は2択、`Enum`はN択、`String`は自由入力。型が厳しいほど誤用が減り、型がゆるいほど柔軟性が増します。

この考え方は、行動経済学でいうチョイスアーキテクチャ（選択の設計）に近い発想です。デッドライン下で正しい選択を最も簡単にする環境をつくること。デザインシステムにおける制約は、自由を奪うものではなく、正解へのショートカットです。

ただし、制約が強すぎると例外的なユースケースに対応できなくなります。制約と柔軟性のバランスをどうとるか——この問いへの答えのひとつが、次の合成です。

# 意味の符号化（Semantic Encoding）: 見た目ではなく意味で名付ける

Figmaで赤い塗りの四角形を描いたとします。これは「エラー表示」なのか「セール価格の強調」なのか、見た目だけでは判断できません。赤いボタンが「削除」を表す場合もあれば「エラー」を表す場合もある。

コンポーネントを設計するとき、「視覚的に正確か」と同じくらい「このコンポーネントが表現する意味は何か」を言語化しておくことが大切です。

この視点は、命名の章で扱う「色は意味で名付ける」原則にもつながります。

好例がRadix UIの[`Dialog`](https://www.radix-ui.com/primitives/docs/components/dialog)と[`AlertDialog`](https://www.radix-ui.com/primitives/docs/components/alert-dialog)です。どちらもオーバーレイ付きのモーダルウィンドウで、ピクセル単位ではほぼ同じ外観です。

しかし`Dialog`は背景クリックで閉じられる汎用モーダルであるのに対し、`AlertDialog`は「本当に削除しますか？」のような確認用で、背景クリックでは閉じられません。見た目ではなく、ユーザーに強制する操作の意味が違うから別コンポーネントになっています。

アクセシビリティの国際標準規格（WAI-ARIA）でも、スクリーンリーダーに「通常のダイアログ」と「警告ダイアログ」を区別して伝える仕組みが用意されており、この設計判断はその規格に基づいています。意味を正しく符号化することは、アクセシビリティにも直結します。

![Radix UI: Dialog と AlertDialog の違い](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-11.png)

# 合成（Composition）: 小さな部品を組み合わせる

レゴブロックを思い出してください。同じブロックの組み合わせで、家もロボットも作れます。コンポーネント設計でも同じことが起こります。

4つの小さな部品——`Avatar`、`Text`、`Badge`、`Button`——があるとします。これらを組み合わせるだけで、`UserCard`（Avatar + Text + Badge）にも`NotificationItem`（Badge + Text + Button）にもなります。部品そのものを増やさなくても、配置を変えるだけでバリエーションが生まれるのです。

![合成: 小さな部品を組み合わせて大きなUIを構築する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-54.png)

Figmaのコンポーネントネスト（コンポーネントの中にコンポーネントを入れること）は、まさに合成そのものです。

コンポーネントを柔軟にする方法には、設定値を増やすConfiguration（設定型）と、差し込み口を設けるComposition（合成型）の2つのアプローチがあります。設定値を増やしすぎるとプロパティが肥大化しますが、差し込み口を設ければ利用者が自由に中身を入れ替えられます。この2つのアプローチの違いは、変数の章で`Element`型（スロット）として詳しく扱います。

部品を増やさずにバリエーションを増やせること。これが合成の力であり、デザインシステムのスケーラビリティを支える考え方です。

# 慣習（Convention）: 暗黙知を形式化する

あなた以外の誰かが、安全に拡張できるか。見落とされがちですが、チームの暗黙知を形式化したルール——命名規則やディレクトリ構造——がその土台をつくります。

プロダクトは成功するほど大きくなります。機能が増え、画面が増え、関わる人が増えます。

コンポーネント、トークン、プロパティの選択肢——これらはすべて、プロダクトの歴史とともに誰かが増やしていくものです。

たとえば、ボタンのデザインを変える`variant`に`primary`と`secondary`しかない状態で、新しいデザイナーが「警告用のボタンが欲しい」と思ったとします。命名規則が明確であれば`destructive`や`warning`を自然に追加できます。ルールが曖昧であれば、`red-button`や`btn-alert`のような名前が生まれ、体系が崩れていきます。

体系がない場合、次のような時系列を辿るでしょう。`variant`名が色名・略称・英語混在でバラバラです。

1. `variant`: `primary` / `secondary` が存在する
2. 警告用が欲しい → `red-button` を追加
3. 控えめなボタンも欲しい → `btn-light` を追加
4. 半年後、`primary` / `secondary` / `red-button` / `btn-light` / `outline-gray` が混在し、新メンバーが `red-button` と `btn-light` の違いは何ですか？と聞く。答えられる人がいない

最初の2人目が正しく拡張できたかどうかは、10人目の生産性を大きく左右します。新メンバーが既存の仕組みに沿って迷わず貢献でき、チームが大きくなっても生産性が落ちにくい。これが慣習のビジネスインパクトです。

![慣習: ルールの有無が半年後の品質を決める](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-41.png)

拡張するために参照する体系をルール化することに加え、実装やFigmaファイルから類推可能であることが重要です。これはコンポーネントに限らず、トークンの命名体系、`Enum`の選択肢、ディレクトリ構造、あらゆる設計判断に通じる問いです。

# 経路依存性（Path Dependency）: 初期の選択が未来を縛る

経路依存性（path dependency）とは、初期に選んだ道がその後の選択肢を制約し、後戻りが難しくなる現象のことです。Figmaでたとえるなら、最初に`Auto Layout`なしで画面を作り始めてしまい、50画面できたところで`Auto Layout`に移行しようとしたら、全画面を作り直す羽目になるようなものです。

この現象はライブラリの選択、命名、ディレクトリ構造——デザインシステムのあらゆる要素に関連します。いくつか例を見てみましょう。

たとえば、立ち上げ期に[MUI](https://mui.com/)を採用して管理画面を作ったケースを考えてみてください。最初は開発スピードが出て順調でした。

ところが1年後、ユーザー向け画面にも独自のデザインを入れたくなったとき、`MUI`のスタイル上書きがいたるところに広がっていて、Headless UIに乗り換えようにも影響範囲が大きすぎて踏み切れない。

命名も同じです。初期に`Card`と名付けたコンポーネントが50画面で使われたあとに「やっぱり`Tile`のほうが適切だった」と気づいても、Figma・コード・ドキュメント・チームの会話すべてに染みこんだ名前を変えるコストは、最初に決めるコストとは比べものになりません。

こうした構造は、デザインシステムのあらゆる層に潜んでいます。ディレクトリ構造、プロパティ設計、どれも時間が経つほど方向転換が難しくなります。

だからこそ初期の設計判断は慎重に決める価値がありますが、完璧な判断を最初から下せるわけでもありません。後半の「現実的な問題への対処」で、経路依存性に対する具体的な防御策を扱います。

![経路依存性: 初期の選択が未来を縛る](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-39.png)

---

以上の7つの原則——間接化・カプセル化・制約・意味の符号化・合成・慣習・経路依存性——は、後の章で登場する具体的なプラクティスの土台になります。すべてを一度に実現する必要はありません。自分たちのシステムがどの原則をカバーしていて、どこが手薄かを把握しておくと、次に投資すべきポイントが見えてきます。

デザインシステムは、チームの認知リソースを再配分します。ボタンの色やサイズで悩む時間がなくなった分、ユーザーの課題解決や情報設計に集中できる。工数の削減だけでなく、思考の質が上がることも大きな効果です。

この7つの原則を押さえたうえで、次はこの原則をどんな戦略で実現するかの選択肢を見ていきます。
