変数の章ではコンポーネントが何を受け取るかを扱いました。ここからは、コンポーネントをどう配置するかという別の設計軸に移ります。

冒頭の原則で紹介した関心の分離が、もっとも具体的に効いてくる領域です。コンポーネントの中身と置き方を分離する——余白、区切り線、幅の振る舞いをどう設計するか。FigmaのAuto Layoutの設定をイメージしながら読むと理解しやすいでしょう。

核心はシンプルです。コンポーネントは自分の中身だけに責任を持ち、どこに置くかは親に任せる。

この分離が曖昧だと、ボタンをここに置いたら余白がおかしい、カードの幅が想定と違うという問題が再利用のたびに発生します。逆に、この原則が徹底されていれば、同じコンポーネントがどんなレイアウトの中に置かれても意図通りに振る舞います。

システム設計や通信における原則のひとつに「受け取るものには寛容に、送り出すものには厳密に」（ポストルの法則）という考え方があります。コンポーネントに当てはめると、どんな入力（長いテキスト、空データ、想定外の画像比率）が来ても壊れずに受け止めること。一方で、外に提供するレイアウト——marginを持たない、幅の振る舞いが予測可能——は厳密であるべきです。この章で扱う設計判断の多くは、この「入力に寛容、出力に厳密」の実践です。

# 外側の余白: コンポーネントに含めない

コンポーネントの外側にmarginを含めるか含めないか。このひとつの判断で、再利用するたびに余白を手動で調整する手間がなくなります。

Figmaでコンポーネントを作るとき、ボタンの下に24pxの空白を含めた状態でコンポーネント化するケースは珍しくありません。Figma上では使いやすいのですが、コードに反映されると、別の場所で使うたびに余白の上書きが必要になります。

ここで大事な区別があります。コンポーネントの内側の余白（padding）は問題ありません。ボタンの中でテキストと枠の間に16pxの余白を取ること、カードの中でコンテンツと境界線の間に24pxの余白を取ること。これらはコンポーネント自身の見た目の一部です。

問題になるのは外側の余白（margin）です。実装の世界では、コンポーネントは自立した箱の中身であり、箱と箱の距離を決めるのは、それらを並べる親要素の仕事です。FigmaでいうAuto Layoutの間隔設定がまさにこれにあたります。

コンポーネントに外側の余白を持たせてしまうと、再利用のたびに余白が大きすぎる、もっと詰めたいという問題が起き、再利用性が失われます。

たとえば、ボタンコンポーネントに `margin-bottom: 24px` を含めて作ったとします。フォーム画面ではぴったりです。しかし、ダイアログの中に同じボタンを置いたら余白が広すぎる。カードの中に置いたら今度は間隔が合わない。

結局、3つの画面でそれぞれmarginを上書きすることになり、ボタンの余白が画面ごとに違うというバグチケットが1ヶ月で5件も上がりました。

外側の余白をコンポーネントから剥がして、親のAuto Layoutで `gap: 16px` を設定する方式に切り替えた日に、この種のバグは一掃されました。どこに置いても親が間隔を決めるので、ボタン側で上書きする必要がなくなったのです。

原則は、コンポーネントの内側のデザイン（padding、背景色、枠線など）はコンポーネントが責任を持ち、外側の配置（margin、隣の要素との距離、画面上の位置）はレイアウトを担当する親が決定する、という役割分担です。

- コンポーネントの責任: padding（内側の余白）、背景色・枠線、コンテンツの配置
- 親（レイアウト）の責任: margin（外側の余白）、要素間の間隔（gap）、画面上の位置

![padding（内側）と margin（外側）の責任分離](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-19.png)

# 下線（区切り線）: コンポーネントに含めるか？

余白と同じくらい議論になるのが、リストアイテムの下に引く区切り線の扱いです。

たとえば、リストの各行の間に薄いグレーの線を入れるデザインを考えてみてください。設定画面のメニューリストでも、チャットの会話一覧でも、同じ問題が発生します。この線をリストアイテムのコンポーネントに含めるべきか、それともリストアイテムの外側で制御すべきか。

コンポーネントに下線を含めると、リストの最後の行にも下線がついてしまいます。あるいは、区切り線なしのレイアウトで使いたいときに線が消せません。余白の問題とまったく同じ構造です。

![区切り線: コンポーネントに含めるか、親が制御するか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-38.png)

一方で、リストの中での区切り線はほぼセットで使うものなので、コンポーネントに含めたほうが配置の手間が減る、という判断もあります。

実務的な落としどころとしては、下線の表示を `Boolean` のプロパティ（showDivider: ON/OFF）として持たせる方法が有効です。デフォルトはONにしておき、最後の行や区切り線が不要な文脈ではOFFにできるようにします。

実装では、最後の要素だけshowDivider: falseにするのが一般的です。最後の要素の下に線があると、リストの終端がわかりにくくなるためです。

# 幅の振る舞い: Fill・Hug・Fixedの3パターン

もうひとつ、レイアウトに深く関わるのがコンポーネントの幅の扱いです。コンポーネントは、どんな幅の枠の中に置かれるかわかりません。サイドバーの狭いスペースかもしれないし、画面いっぱいの幅かもしれません。このとき、コンポーネントがどう振る舞うかを決めておく必要があります。

幅の振る舞いは、大きく3つのパターンがあります。

- 親の幅いっぱいに広がる（Fill）: 置かれた枠に合わせてコンポーネントの幅が変わる。FigmaでいうFill Containerの設定。テキスト入力フィールド、カード、`Divider`など、文脈に応じて幅が変わるべきコンポーネントはこれが基本
- 中身に合わせて自動で伸縮する（Hug）: テキストやアイコンの量に応じて幅が決まる。FigmaでいうHug Contentsの設定。ボタン、`Tag`、`Badge`など、内容量に幅が比例するコンポーネントに適している
- 固定幅（Fixed）: 特定のピクセル値で幅が決まっている。アイコン、`Avatar`、サムネイルなど、サイズが一定であるべきコンポーネントに適している

![Fill / Hug / Fixed の3パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-08.png)

デザイナーがFigmaでコンポーネントを作るとき、見た目は思い通りでも、そのまま実装すると画面サイズが変わったときに想定外の見た目をすることがあります。`Button`のデフォルトを Fixed Width にしてしまうと、利用者が画面幅いっぱいのボタンを作りたいときにいちいち設定を変えなければなりません。

ただし、同じコンポーネントでも文脈によって振る舞いが変わることがあります。ボタンはふだんは中身に合わせて伸縮するけれど、モバイルのフォーム画面では画面幅いっぱいに広げたい。

こうしたケースでは、コンポーネント自体は Hug をデフォルトにしておき、親のAuto Layout側で Fill に切り替える、というのが自然な設計です。コンポーネントの幅は自分では決めない、置かれた場所の枠が決める。これも余白の原則と同じ考え方です。

仕様として、このコンポーネントのデフォルトの幅の振る舞いは何かを明示しておくと、実装のブレが減ります。
