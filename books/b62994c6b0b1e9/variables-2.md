---
title: "変数(2): プロパティの組み合わせと運用"
---

個々の型を知ったうえで、次に問われるのは「型をどう組み合わせ、どう運用するか」です。プロパティ同士の直交性、トークンによる一貫性の担保、Figmaとコードのギャップへの対処を扱います。

# プロパティの直交性: 組み合わせが壊れない設計

実際のコンポーネントではプロパティが複数組み合わさって使われます。このとき大事になるのが、プロパティ同士が互いに干渉しないという性質です。これを直交性と呼びます。

あるプロパティの値を変えたとき、他のプロパティの意味や振る舞いまで変わってしまうなら、そのプロパティ同士は独立していません。Figmaでバリアントを設計するとき、この感覚があると組み合わせの破綻を未然に防げます。

## 直交している状態

`Button`に`size`（`S`・`M`・`L`）と`variant`（`primary`・`secondary`・`destructive`）の2つのプロパティがあるとします。`size`を`S`から`L`に変えても`variant`の見た目は変わらない。`variant`を`destructive`に変えても`size`は影響を受けない。3×3＝9通りすべてが成立します。これが直交している状態です。

![直交性: size と variant の組み合わせがすべて成立する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-05.png)

もし「`destructive`のときは`S`が使えない」「`secondary`の`L`だけ角丸が変わる」といった暗黙の制約があったら、組み合わせるたびにルール確認が必要になります。

もう一つの例を見ます。タグの部品に`colorScheme`（情報・成功・警告・エラー）と`variant`（塗りつぶし・薄い背景・背景なし）の2つのプロパティがあるとします。`colorScheme`は意味を表し、`variant`は濃度を表します。種類を変えても濃度の振る舞いは変わらないし、濃度を変えても種類の意味は変わりません。この2つは独立しています。

![直交性: colorScheme と variant の組み合わせマトリクス](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-28.png)

## 1つの組み合わせに2つの意味を持たせると何が起きるか

直交性が壊れるのは、1つのプロパティが複数の関心事をまとめて引き受けてしまうときです。

たとえば、ボタンの見た目を`style`というプロパティひとつで管理しているケースを考えます。選択肢は `primary`・`secondary`・`danger`・`ghost`。最初の3つは色の種類（意味）を表していますが、`ghost`だけは「背景なし」という色の強さを表しています。1つのプロパティに「色の種類」と「色の強さ」という2つの関心が混在しています。

この設計では、`ghost`のエラー色はどうなるのかという問いに答えられません。`style: ghost`は背景がないのだから、`danger`の赤い背景は出せない。「`ghost`のときはエラー表示に対応していません」という例外が生まれ、その例外はドキュメントに書かれ、やがて忘れられます。

`variant`（`solid` / `subtle` / `ghost`）と`colorScheme`（`primary` / `secondary` / `danger`）を分ければ、`colorScheme: danger` × `variant: ghost`の組み合わせは自然に成立します。赤いテキストだけのボタンが、マトリクスの1セルとして生まれる。例外のないシステムは、ドキュメントなしでも正しく使えます。

![直交性の崩れ: 1つのプロパティに混ぜる vs 分離する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-67.png)

## 設計時のチェックポイント

プロパティを設計するとき、次の3つを確認します。

- このプロパティの値を変えたとき、他のプロパティの意味や動きまで変わらないか
- 2つのプロパティの組み合わせに暗黙の優先順位が生まれていないか
- ひとつの値が複数の関心事（色の種類と色の強さ、サイズと形状など）をまとめて扱っていないか

直交性が保たれていると、プロパティを追加するたびに既存の組み合わせを紐解く必要がありません。逆に、プロパティ間に暗黙の依存があると、機能を足すたびに優先順位の整理が必要になり、そのルールは時間とともにチーム内で忘れられていきます。

Figmaの[Propstar](https://www.figma.com/community/plugin/1116018586739867857/propstar)というプラグインを使うと、コンポーネントのすべてのプロパティ組み合わせを一覧表示できます。直交性が保たれているかの確認や、プロパティのヌケモレの発見に便利です。

# トークンの共有: 複数コンポーネントの一貫性を保つ

ここまでは個々のコンポーネントのプロパティ設計を見てきました。もう一歩引いて、複数のコンポーネントにまたがる設計について触れておきます。

色やサイジングの体系は、複数のコンポーネントで使い回せるように設計しておくと便利です。こうした共通の値に名前をつけて一元管理する仕組みをトークンと呼びます。Figmaでいえばスタイルやバリアブルに近い概念です。

![トークンの共有: 複数コンポーネントの一貫性を保つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-06.png)

Figmaでは、`Tag`の色を変えたければ`Tag`のスタイルを編集し、`Callout`の色も変えたければ`Callout`のスタイルも別途編集する——というコンポーネントごとの作業になりがちです。

しかしコードの世界では、共通のトークンを参照する仕組みがあれば、トークンの値をひとつ変えるだけですべてのコンポーネントに反映されます。

たとえば、`Tag`の info と `Callout` の info が同じセマンティックカラーを参照していれば、色を変えたいときに一箇所の修正で両方に反映されます。バラバラに定義していると、デザイナーが個別に色を選ぶたびに微妙なズレが蓄積し、`Tag`は青いのに`Callout`は水色、という不一致がいつの間にか生まれます。

色だけの話ではありません。兄弟関係にあるコンポーネント（`Button` / `IconButton` / `CopyButton`など）では、縦幅やアイコンのサイズも共通のトークンを参照しておくと一貫性を保ちやすくなります。

こうしたトークンを一元管理しておけば、`Tag`の配色を微調整したいときに、共通構造を持つすべてのコンポーネントに変更が波及します。トークンを使わず個別のコンポーネントに値を直接書き込んでいたら、ひとつずつ直すことになります。

![トークン変更の波及: 1箇所の変更が全コンポーネントに届く](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-78.png)

Figma上でデザイントークンを管理するプラグインとしては、[Tokens Studio](https://tokens.studio/)が広く使われています。JSONベースでトークンを定義でき、コードとの同期にも対応しています。

# Figmaだけでは伝わらない変数の性質: コードとの差分を知る

ここまで紹介した型はFigmaのプロパティパネルでもある程度表現できます。しかし、コードの変数にはFigmaだけでは伝えきれない性質がいくつかあります。知っておくだけで、エンジニアとの会話がぐっとスムーズになるポイントです。

## 必須と任意: デフォルト値で使いやすさが決まる

なぜこの区別が重要なのか。コンポーネントのプロパティが10個あるとき、そのすべてが毎回指定必須だとしたら、使うたびに10項目を埋める手間がかかります。

逆に、ほとんどが任意でデフォルト値を持っていれば、使う側は変えたいところだけを指定すればよい。必須と任意の設計は、コンポーネントの使いやすさを直接的に決めます。

![必須と任意: デフォルト値で使いやすさが決まる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-36.png)

必須を最小限にとどめ、よく使われる値をデフォルトに設定しておくことで、8割のユースケースは何も指定しなくてもそのまま使える状態を目指します。

コードでは、変数が必ず渡さなければならないか、省略してもよいかが明確に定義されます。省略できる変数には通常、デフォルト値が設定されています。

たとえば、ボタンコンポーネントの `size` が任意で、デフォルト値が `Medium` であれば、利用者が `size` を指定しなくても中サイズのボタンが表示されます。一方、`label` が必須であれば、テキストなしでボタンを使うことはできません。

Figmaのプロパティパネルには、必須かどうかや省略時のデフォルトを表現する仕組みがありません。すべてのプロパティに常に何らかの値が入った状態で表示されます。

そのため、何がデフォルトで何が意図的な指定なのかが区別できないのです。

これを補うには、Description欄に「デフォルト: Medium」のように明記しておくのがもっともシンプルです。また、何も指定しなかったときの見た目を最初のバリアントとして配置しておくと、利用者がこれがデフォルトかと直感的に理解できます。

ただし、デフォルト値は一度決めたら簡単には変えられません。コードの世界では、デフォルト値を変更すると、明示的に値を指定していなかったすべての箇所で表示が変わります。

`size`のデフォルトを`Medium`から`Small`に変えれば、何も指定していないボタンがすべて小さくなる。影響範囲が広いぶん、デフォルト値の決定はかなり慎重におこなう必要があります。

## 条件付き表示: Figmaとコードでプロパティの数がズレる理由

Figmaでコンポーネントを作るとき、ある要素を表示/非表示にするためにトグルを追加した経験はないでしょうか。エンジニアに「このトグル、コード側では要らないんですよ」と言われて戸惑ったことがあるかもしれません。Figmaの制約とコードの表現力の違いが現れる場面です。

たとえば、カードにサブタイトルを出すかどうかを切り替えたいケースを考えてみます。実はコード側では、この挙動をもっとシンプルに実現できます。

コード側ではサブタイトルのテキストというプロパティが1つあれば十分です。テキストが渡されれば表示し、渡されなければ領域ごと消える。1つのプロパティで中身と表示/非表示を同時に制御できます。

しかしFigmaでは、この挙動を再現するためにサブタイトルを表示するかどうかのトグルとサブタイトルのテキストという2つのプロパティが必要です。コードでは1つで済むことが、Figmaでは2つに分かれるわけです。

こうしたFigmaと実装のプロパティ数のズレは避けられません。大切なのは、このズレがあることをチームで認識し、ルール化しておくことです。

認識が共有されていないと「Figmaと実装でプロパティの数が合わない」という無駄な議論が繰り返されるためです。

![条件付き表示: Figmaでは2つ、コードでは1つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-37.png)

## プロパティ名の先読み: icon問題

ボタンにアイコンを付けられるようにしたいとします。左側にアイコンを1つ置くだけなので、プロパティ名を `icon` にしました。しばらくは問題なく使えます。

ところが数ヶ月後、右側にもアイコンを置きたいという要件が出てきます。右側用のプロパティを追加しようとして手が止まります。`icon` はすでに左側に使ってしまっている。右側を `iconRight` にすると、左が `icon` で右が `iconRight` という非対称な名前になります。かといって既存の `icon` を `iconLeft` にリネームすれば、すでにこのプロパティを使っているすべての箇所を修正しなければなりません。

最初から `iconLeft` と名付けていれば、`iconRight` を足すだけで済んだ話です。将来もう一方が増える可能性を予見できていたかどうかで、後の変更コストが大きく変わります。これは原則の章で触れた経路依存性の力学そのものです。

この「先読み」はアイコンに限りません。ヘッダーだけ作ったあとにフッターが必要になるケース、画像用のプロパティを作ったあとに背景画像との区別が必要になるケースなど、1つだけに見えたものが対になる場面はよくあります。対になる可能性がある要素には、最初から位置や役割を含んだ名前をつけておくと安全です。

さらに、位置を表す語の選び方にも注意が要ります。left / right は物理的な方向を指すため、2つの前提を含んでいます。1つは水平方向であるという前提、もう1つは左から右に読む言語圏であるという前提です。

アラビア語やヘブライ語のように右から左に書く言語では、UIの配置が左右反転します。`iconLeft` と名付けたプロパティが、実際には右側に表示されることになり、名前と見た目が矛盾します。また、レスポンシブデザインでレイアウトの方向が変わる場合にも、left / right は意味を失います。

こうした理由から、物理方向ではなく論理方向で名付ける慣習があります。left / right の代わりに start / end、あるいは leading / trailing を使う方法です。CSSやSwiftUIにもこの考え方に基づいた仕組みが用意されています。

多言語対応の予定がないプロダクトでも、start / end で名付けておくことにデメリットはほとんどありません。将来の可能性を閉じない命名として、頭の片隅に置いておく価値があります。

ここまで、コンポーネントが受け取る設定値——プロパティ——の型と組み合わせを扱いました。次いで、コンポーネントが取りうる状態の設計について考察します。
