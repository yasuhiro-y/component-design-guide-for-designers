---
title: "構築戦略: どう作るかを選ぶ"
---

コンポーネント設計の具体に入る前に、デザインシステムの構築戦略のパターンをおさえます。

しばしば、プロダクトが生まれる際、それをどう構築するかの検討は入念におこなわれない場合があります。立ち上げの状況では、やはりそれ以上に重要と思われる事情があります。

ある構築方法を選んだ日が、2年後のリブランドの可否を決めていた——そんなことが起こりえます。構築戦略の選択は、その後の自由度や拡大効率を大きく左右します。

ここで紹介する戦略の違いは、デザイナーの日々のワークフローにも影響します。汎用コンポーネントライブラリを採用するなら既存テンプレートのカスタマイズが中心になり、Headless UIベースなら全状態を自分でデザインする責任が生まれます。どちらを選ぶかで、あなたの仕事の範囲が変わります。

自社のフェーズやリソースに合わせて適切な戦略を選ぶ必要があります。

![構築戦略の4パターン: コストと自由度のトレードオフ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-25.png)

# 汎用ライブラリの活用: MUIやChakra UIを土台にする

外部公開されているライブラリをそのまま活用する方法です。[Material UI](https://mui.com/)、[Chakra UI](https://chakra-ui.com/)、[Ant Design](https://ant.design/)などがこれにあたります。どんなサービスにも使える汎用のコンポーネント群です。

すでにひと通りのコンポーネントがそろっているため、すぐに開発を始められるのが強みです。`Button`、`Input`、`Modal`、`Table`など、基本的なUI部品はすべて用意されています。とくに初期フェーズのスタートアップや、管理画面のような機能性重視のプロダクトでは、採用するメリットが大きいです。

一方で、どこかで見たことのあるデザインになりがちです。ライブラリの設計思想に強く依存するため、そこから外れた独自のUIを実現しようとすると、かえって実装コストが高まる場合があります。独自性のあるデザインや機能をもつToCサービスでは、カスタマイズの限界がネックになることがあります。

汎用ライブラリがコードとして提供されている場合、対応する言語やフレームワークはライブラリごとに異なります。Webでは`React`が多いですが、[Material Design](https://m3.material.io/)は[Jetpack Compose](https://developer.android.com/compose)、[Flutter](https://flutter.dev/)、[Angular](https://angular.dev/)などさまざまな環境向けに頒布されています。汎用ライブラリの採用は自社の技術スタックに深く依存します。

また、こうした外部ライブラリへの依存にはいくつか技術的なリスクもあります。

- **アップデート追従コスト**: 大きなバージョンアップで互換性のない変更が含まれると、自社のコード全体を見直す必要が出てきます。カスタマイズしていた部分が動かなくなることもあります
- **ライブラリ自体の存続リスク**: オープンソースのライブラリはメンテナーの運営に依存します。開発が停滞したり、サポート終了になったりすれば、別のライブラリへ移行する大がかりな作業が発生します

とはいえ、上記のリスクは見通しが不明瞭なプロダクト開発において、短期的なメリットを優先できるのであれば有力な選択肢です。

# フルスクラッチでの構築: 自社専用をゼロから作る

自社専用のデザインシステムをゼロから構成するパターン。

[SmartHR UI](https://github.com/kufu/smarthr-ui)や、[デジタル庁デザインシステム](https://design.digital.go.jp/)などがよい例です。たとえば、SmartHR UIでは、コンポーネント名やプロパティ名を日本語の業務用語に合わせて設計しており、ドメインとの一致を優先する判断が見られます。自社の設計思想を100%反映でき、事業領域に特化したコンポーネントを最適化して、ユーザー体験の質を追求できます。

ただし、作るのにも維持するのにもコストがかかります。ボタンひとつとっても、マウスを乗せたときの変化、キーボードで選択したときの枠線、アクセシビリティ対応など、考えるべき点は山ほどあります。これらをすべて自社でメンテナンスし続ける心づもりが必要です。

後ほど言及しますが、すでに稼働中のプロダクトに後からデザインシステムを適用する場合、BtoCのサービスの場合はこのパターンに至ることも少なくありません。

# Headless UIの活用: 見た目を持たないライブラリ

ここ数年で注目されているのがHeadless UI（Headless = 頭のない、つまり見た目の層を持たないという意味）です。Radix UI、[React Aria](https://react-aria.adobe.com/)、[Headless UI](https://headlessui.com/)といったライブラリがあり、多くのプロダクトで採用が進んでいます。

これらは見た目を持たず、機能だけを提供するライブラリです。Figmaでたとえるなら、`Auto Layout`の構造だけが用意されていて、色・フォント・角丸は一切ついていない状態のコンポーネント集です。見た目は自分たちで自由にデザインします。

たとえば、ドロップダウンメニューやモーダル、`Combobox`といったコンポーネントは、アクセシビリティへの対応がとても複雑です。これを自社でゼロから正しく実装するのは大変です。Headless UIを使えば、この複雑な裏側のロジックはライブラリに任せつつ、見た目だけを自社のスタイルで自由にあてることができます。車輪の再発明を防ぎながら、自由度を確保できます。

Headless UIの設計思想がよく表れているのが、見た目が似たコンポーネントの分類です。

Radix UIには、いずれもドロップダウン的な見た目の[`Select`](https://www.radix-ui.com/primitives/docs/components/select)、[`DropdownMenu`](https://www.radix-ui.com/primitives/docs/components/dropdown-menu)、[`ContextMenu`](https://www.radix-ui.com/primitives/docs/components/context-menu)が別々のコンポーネントとして存在します。`Select`はリストから値を選ぶUI、`DropdownMenu`はメニューからアクションを実行するUI、`ContextMenu`は右クリックで開く操作メニュー。

Headless UIライブラリも同様に、[`Listbox`](https://headlessui.com/react/listbox)はドロップダウンで1つ選ぶUI、[`Combobox`](https://headlessui.com/react/combobox)は入力しながら候補が絞られる検索付き選択UI、[`Menu`](https://headlessui.com/react/menu)はアクション一覧、というように分離しています。ポップオーバーが開いて項目が並ぶという見た目は共通しているのに、なぜ分けるのか。それはユーザーが何をしたいか——値を選ぶのか、アクションを実行するのか、検索してから選ぶのか——が違うからです。

見た目ではなくインタラクションの目的でコンポーネントを分ける。これがHeadless UIの設計思想であり、後述する「汎用とドメインの分離」にも通じる考え方です。

![Radix UI: 見た目が似た3つのコンポーネント](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-14.png)

スタイリングは自分たちでおこなう必要があるため、MUIなどの完結型ライブラリに比べれば初期の手間はかかります。しかし、長期的な運用のしやすさを考えれば、初期コストを払う価値は十分にあります（コンポーネント間の一貫性を保ちながら各コンポーネントをスタイリングするのはAIが得意そうです）。

デザイナーにとっては、MUIのように既成のFigmaテンプレートをカスタマイズするのではなく、骨組みに対して自分たちでゼロからスタイルを設計することになります。自由度は高い反面、すべての状態（`Hover` / `Pressed` / `Disabled` / `Focus`）を自分たちで定義する責任が生まれます。また、公開されているFigmaテンプレートを自社に合うように加工することになりますが、テンプレートが部分的に実装に足りていない場合がよくあります。必要な分だけ最低限取り入れるという割り切りも有効です。

# ハイブリッド戦略: 組み合わせて使う

いくつかのパターンを紹介しましたが、現実的にはこれらを組み合わせることが有力です。

たとえば、`Button`、`Input`、`Checkbox`といった部品はHeadless UIをベースに自社スタイルをあてて構築し、ドメイン固有の部品は自社で独自に開発する。あるいは、プラットフォームが分かれていれば、管理画面はMUIをそのまま使い、ユーザー向けアプリはフルスクラッチで作るなど、組み合わせ方はさまざまです。

また、ベースはフルスクラッチでありながら、一部の実装が複雑なコンポーネントについてはHeadless UIや汎用ライブラリから拝借するという実装方法も存在します（その場合、実装方法の乖離が少ない選択肢が検討されます）。

なんとなく作るのではなく、短期・長期両面でリソースと目的を天秤にかけ、ここはライブラリに頼る・ここは自社の独自性を追求する、という線引きをなるべく初期に議論することが望ましいです。後になるほど方針転換のコストが大きくなるためです。

# 後発導入: 稼働中のプロダクトにシステムを入れる

すでにデザインシステムなしで開発が進んでいるプロダクトに、後からシステムを導入するケースも少なくありません（いや、ほとんどそうだから大変なのです）。

なぜ後発導入が難しいのかを理解しておくと、戦略を立てやすくなります。ゼロから作るプロダクトなら最初からコンポーネントを揃えられますが、稼働中のサービスにはすでに動いているUIが資産として存在しているからです。

ユーザー影響や改修範囲などを考えると、この資産を壊さずに、新しい仕組みに段階的に置き換えていく必要があります。一度に変えると、QA（品質確認）の範囲が爆発し、リグレッション（意図しない既存機能の破壊）が起きやすくなるためです。

このため、再現性や段階的移行の負荷の観点から、フルスクラッチに近い構築になることが多いです。

ただし、中長期的なメリットを見据えたHeadless UIや既存ライブラリの活用も含めて、エンジニアリングチームと早い段階で議論しましょう。技術スタックや既存コードとの相性によって、最適な戦略は大きく変わります。

後発導入で実践的なのは、以下の3ステップです。

1. トークンから入る。 コンポーネントの前に、色・フォントサイズ・余白のトークンを定義して既存コードに適用する。見た目はほぼ変わらないが、後からの一括変更が可能になる。これがもっとも低リスクで効果の高い出発点です
2. 新規画面から準拠する。 既存画面は触らず、新しく作る画面だけをデザインシステムに沿って設計する。新規画面は100%準拠というルールを置くことで、デザインシステムの利用実績が自然に積み上がります
3. 既存画面は優先度をつけて段階的に移行する。 ユーザーの利用頻度が高い画面や、変更が予定されている画面から置き換えていきます

![後発導入: 稼働中プロダクトへの3ステップ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-44.png)

古いUIと新しいUIが一時的に混在する状態は、どのプロダクトでも起こりうるものです。

混在期間は避けられないと受け入れたうえで、その期間を管理することに意識を向けましょう。全部揃うまで出せないではなく、揃ったところから価値を出すという方針が現実的です。

# 戦略を選ぶ前に: ボトルネックはどこか

構築戦略を決める前に、自分たちのチームで何が本当のボトルネックなのかを診断することが重要です。従来、ボトルネックはUIの実装スピードにありました。しかしAIがコードを書く時代には、事情が変わりつつあります。

実装スピード以上に、フィードバックループの速度——良い決定をするために必要な情報がチーム内で時間内に集まるか、変更の影響を正確に把握できるか——といった「決定の質」が、より大きなレバレッジを持つようになってきていると考えます。

たとえば、コンポーネントの分割方針を変えたいとき、影響範囲を30分で把握できるチームと3日かかるチームでは、意思決定の速度が桁違いです。

デザインシステムへの投資も、この視点で優先度を判断すると、自社にとって最も効果的な出発点が見えてきます。有名なデザインシステムの構成をそのまま真似たくなりますが、他社の正解が自社の正解とは限りません。色の不一致、命名の混乱、手戻りの多さ——いま自分たちが何に困っているかを起点に、具体的な痛みから解決していく姿勢が、長く機能するデザインシステムにつながります。

構築戦略と土台の話はここまで。
以降からひとつひとつのコンポーネントをどう設計するか？の具体的な議論に入ります。
