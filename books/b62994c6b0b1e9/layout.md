---
title: "レイアウト: コンポーネントの中身と置き方を分離する"
---

変数の章ではコンポーネントが何を受け取るかを扱いました。ここからは、コンポーネントをどう配置するかという別の設計軸に移ります。

# 中身と配置の分離

冒頭の原則で紹介したカプセル化（Encapsulation）が、もっとも具体的に効いてくる領域です。コンポーネントの中身と置き方を分離する——余白、区切り線、幅の振る舞いをどう設計するか。Figmaの`Auto Layout`の設定と対応づけながら見ていきます。

核心はシンプルです。コンポーネントは自分の中身だけに責任を持ち、どこに置くかは親に任せる。

この分離が曖昧だと、ボタンをここに置いたら余白がおかしい、カードの幅が想定と違うという問題が再利用のたびに発生します。逆に、この原則が徹底されていれば、同じコンポーネントがどんなレイアウトの中に置かれても意図通りに振る舞います。

システム設計や通信における原則のひとつに「受け取るものには寛容に、送り出すものには厳密に」（ポストルの法則）という考え方があります。コンポーネントに当てはめると、どんな入力（長いテキスト、空データ、想定外の画像比率）が来ても壊れずに受け止めること。一方で、外に提供するレイアウト——marginを持たない、幅の振る舞いが予測可能——は厳密であるべきです。この章で扱う設計判断の多くは、この「入力に寛容、出力に厳密」の実践です。

# 外側の余白: コンポーネントに含めない

コンポーネントの外側にmarginを含めるか含めないか。このひとつの判断で、再利用するたびに余白を手動で調整する手間がなくなります。

Figmaでコンポーネントを作るとき、ボタンの下に24pxの空白を含めた状態でコンポーネント化するケースは珍しくありません。Figma上では使いやすいのですが、コードに反映されると、別の場所で使うたびに余白の上書きが必要になります。

ここで大事な区別があります。コンポーネントの内側の余白（`padding`）は問題ありません。ボタンの中でテキストと枠の間に16pxの余白を取ること、カードの中でコンテンツと境界線の間に24pxの余白を取ること。これらはコンポーネント自身の見た目の一部です。

問題になるのは外側の余白（`margin`）です。実装の世界では、コンポーネントは自立した箱の中身であり、箱と箱の距離を決めるのは、それらを並べる親要素の仕事です。Figmaでいう`Auto Layout`の間隔設定がまさにこれにあたります。

コンポーネントに外側の余白を持たせてしまうと、再利用のたびに余白が大きすぎる、もっと詰めたいという問題が起き、再利用性が失われます。

たとえば、ボタンコンポーネントに `margin-bottom: 24px` を含めて作ったとします。フォーム画面ではぴったりです。しかし、ダイアログの中に同じボタンを置いたら余白が広すぎる。カードの中に置いたら今度は間隔が合わない。

結局、3つの画面でそれぞれmarginを上書きすることになり、ボタンの余白が画面ごとに違うというバグチケットが1ヶ月で5件も上がるようなことがおきます。

外側の余白をコンポーネントから剥がして、親の`Auto Layout`で `gap: 16px` を設定する方式に切り替えれば、この種のバグはなくなります。どこに置いても親が間隔を決めるので、ボタン側で上書きする必要がなくなるのです。

原則は、コンポーネントの内側のデザイン（`padding`、背景色、枠線など）はコンポーネントが責任を持ち、外側の配置（`margin`、隣の要素との距離、画面上の位置）はレイアウトを担当する親が決定する、という役割分担です。

- コンポーネントの責任: `padding`（内側の余白）、背景色・枠線、コンテンツの配置
- 親（レイアウト）の責任: `margin`（外側の余白）、要素間の間隔（`gap`）、画面上の位置

![padding（内側）と margin（外側）の責任分離](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-19.png)

# 下線（区切り線）: コンポーネントに含めるか？

余白と同じくらい議論になるのが、リストアイテムの下に引く区切り線の扱いです。

たとえば、リストの各行の間に薄いグレーの線を入れるデザインを考えてみてください。設定画面のメニューリストでも、チャットの会話一覧でも、同じ問題が発生します。この線をリストアイテムのコンポーネントに含めるべきか、それともリストアイテムの外側で制御すべきか。

コンポーネントに下線を含めると、リストの最後の行にも下線がついてしまいます。あるいは、区切り線なしのレイアウトで使いたいときに線が消せません。

余白の問題とまったく同じ構造です。

![区切り線: コンポーネントに含めるか、親が制御するか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-38.png)

一方で、リストの中での区切り線はほぼセットで使うものなので、コンポーネントに含めたほうが配置の手間が減る、という判断もあります。

実務的な落としどころとしては、下線の表示を Boolean のプロパティ（`showDivider`: ON/OFF）として持たせる方法が有効です。デフォルトはONにしておき、最後の行や区切り線が不要な文脈ではOFFにできるようにします。

実装では、最後の要素だけ`showDivider: false`にするのが一般的です。最後の要素の下に線があると、リストの終端がわかりにくくなるためです。

# 幅の振る舞い: Fill・Hug・Fixedの3パターン

もうひとつ、レイアウトに深く関わるのがコンポーネントの幅の扱いです。コンポーネントは、どんな幅の枠の中に置かれるかわかりません。

サイドバーの狭いスペースかもしれないし、画面いっぱいの幅かもしれません。このとき、コンポーネントがどう振る舞うかを決めておく必要があります。

幅の振る舞いは、大きく3つのパターンがあります。

- 親の幅いっぱいに広がる（`Fill`）: 置かれた枠に合わせてコンポーネントの幅が変わる。Figmaでいう`Fill Container`の設定。テキスト入力フィールド、カード、`Divider`など、文脈に応じて幅が変わるべきコンポーネントはこれが基本
- 中身に合わせて自動で伸縮する（`Hug`）: テキストやアイコンの量に応じて幅が決まる。Figmaでいう`Hug Contents`の設定。ボタン、`Tag`、`Badge`など、内容量に幅が比例するコンポーネントに適している
- 固定幅（`Fixed`）: 特定のピクセル値で幅が決まっている。アイコン、`Avatar`、サムネイルなど、サイズが一定であるべきコンポーネントに適している

![Fill / Hug / Fixed の3パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-08.png)

デザイナーがFigmaでコンポーネントを作るとき、見た目は思い通りでも、そのまま実装すると画面サイズが変わったときに想定外の見た目をすることがあります。`Button`のデフォルトを `Fixed Width` にしてしまうと、利用者が画面幅いっぱいのボタンを作りたいときにいちいち設定を変えなければなりません。

ただし、同じコンポーネントでも文脈によって振る舞いが変わることがあります。ボタンはふだんは中身に合わせて伸縮するけれど、モバイルのフォーム画面では画面幅いっぱいに広げたい。

こうしたケースでは、コンポーネント自体は `Hug` をデフォルトにしておき、親の`Auto Layout`側で `Fill` に切り替える、というのが自然な設計です。コンポーネントの幅は自分では決めない、置かれた場所の枠が決める。これも余白の原則と同じ考え方です。

仕様として、このコンポーネントのデフォルトの幅の振る舞いは何かを明示しておくと、実装のブレが減ります。

## 最小幅・最大幅: 振る舞いに制限をかける

Fill・Hug・Fixed の3パターンだけでは対処しきれないケースがあります。Fill で親の幅に追従するコンポーネントが、極端に狭い画面で潰れてしまう。Hug で中身に合わせて伸びるコンポーネントが、長いテキストによって画面幅を突き破る。こうした問題を防ぐのが最小幅（min-width）と最大幅（max-width）です。高さについても同様に min-height / max-height が使えます。

Figma では Auto Layout の子要素に Min Width / Max Width を設定できます。コードでは CSS の `min-width` / `max-width` がそのまま対応します。

たとえば、テキスト入力フィールドは Fill で親の幅に追従するが、最小幅を 200px に設定しておけばそれ以下には縮まない。モーダルダイアログは max-width を 640px にしておけば、大画面でも間延びしない。`Avatar` は固定サイズだから min / max は不要。

この制約はレスポンシブデザインでとくに重要です。画面幅が変わっても壊れないコンポーネントを作るには、Fill / Hug / Fixed のデフォルトに加えて、どこまで縮めてよいか・どこまで広げてよいかの限界値をセットで定義しておく必要があります。

# オーバーフロー: はみ出したコンテンツの扱い

コンポーネントの枠に対してコンテンツが収まりきらないとき、何が起きるか。この問いに答えておかないと、実装時にエンジニアが都度判断することになり、画面ごとに挙動がバラつきます。

Figma ではフレームの Clip Content のオン・オフでコンテンツの切り抜きを制御します。コードでは CSS の `overflow` プロパティ（`hidden` / `scroll` / `auto`）、テキストの `text-overflow: ellipsis`、行数制限の `-webkit-line-clamp` などが対応します。

## テキストのオーバーフロー

もっともよく直面するのが、テキストが想定より長いケースです。ユーザー名、商品名、コメント——長さが予測できないテキストは必ずあります。

ここで決めるべきは、省略（truncate）か折り返し（wrap）かです。

- 1行で収めたい場面（テーブルのセル、ナビゲーション項目）は `…` で省略する。Figma では Truncate Text の設定、コードでは `text-overflow: ellipsis` と `overflow: hidden` の組み合わせ
- 複数行を許容する場面（カードの説明文、コメント）は折り返すが、最大行数を決めておく（2行まで、3行までなど）。コードでは `-webkit-line-clamp` で行数制限をかける
- 全文表示が必要な場面（記事本文、利用規約）は制限なく折り返す

この判断がコンポーネントの仕様に含まれていないと、「ここは1行で切るべきか、2行まで出すべきか」が実装者ごとに異なる結果になります。

## コンテナのオーバーフロー

コンテンツの量がコンテナの高さを超えたとき——リストの項目数が想定以上に多い、フォームの入力項目が画面に収まらないなど——の扱いも事前に決めておきます。

- **スクロール**: コンテナ内にスクロール領域を設ける。Figma ではプロトタイプモードの Scroll Behavior で表現できるが、デザインカンプだけでは伝わりにくい。仕様として「この領域はスクロールする」と明記する。コードでは `overflow-y: auto` が一般的
- **ページネーション / もっと見る**: 一度に表示する件数を制限し、残りはページ送りやボタンで表示する。データが大量になる前提のリスト（検索結果、通知一覧）ではこの方式が適している
- **切り捨て**: 表示しきれないコンテンツを切り捨てて表示しない。`Avatar` の画像が枠からはみ出す場合に `overflow: hidden` で丸く切り抜くのが典型例

スクロールを採用する場合は、スクロール領域の高さの決め方も決めておきます。固定高（`height: 400px`）か、画面高さに連動（`max-height: 60vh`）か。モーダル内のリストなら画面高さに連動させないと、小さい画面でモーダル自体が画面外にはみ出します。

Figma の Clip Content は見た目上コンテンツを切り抜きますが、それがスクロールなのか切り捨てなのかは伝わりません。デザインカンプに加えて、スクロール可能であること、最大表示件数があること、などを仕様として補足しておくのが確実です。
