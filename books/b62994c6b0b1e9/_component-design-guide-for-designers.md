# はじめに

## なぜこれを書いたのか

こんにちは、タイミーの横田です。

デザインシステムのコンポーネント設計論にフォーカスし、長年さまざまな現場でデザイナーやエンジニアと議論してきた内容を記事にまとめました。

私はこれまで、自社・他社でその時々のデザインシステムを設計し、組織にインストールするということを何度も経験してきました。

デザインシステム自体をどう運用するかについては書籍なども増えてきましたが、実装とデザインを細部で連動させることや、スケーラブルに設計することにいたっては、言語化されていない経験則がたくさんあることを感じていました。

コンポーネントというトピックひとつとってもプラクティスがたくさん存在します。ところが、その原則や経験則がないと、何がわからないかわからない（Unknown unknowns）な状態です。エンジニアや他のデザイナーに教わって気づくものの、何に気づいてないかはまだわからない。この微妙で厄介な問題は、エンジニアリングと接近しようとするデザイナーが遅かれ早かれ通る道です。

このシリーズでは、デザイナー・エンジニアが日常的に向き合うコンポーネントの設計にフォーカスしてデザインシステムの考え方を整理します。以下の2点を目指します。

1. コードを書かないデザイナーにデザインシステム的な考え方に関するリファレンスを提供する
2. 手探りでデザインシステムを構築しようとする方々に、論点のガイドを提供する

タイミーでどのように実践しているかについては、note の紹介記事にまとめています。本書ではAIに読み込ませて使ったり、よりさまざまな文脈の組織で活用したりできる汎用的なガイドを提供することを優先しています。

## あなたのモチベーション

[Figma](https://www.figma.com/)で画面をつくるデザインは、一枚のキャンバスに最終形を描く作業に近いものでした。しかしデザインシステムでは、レゴブロックの突起の形状を設計し、誰でもお城を作れるようにする。**絵を描く**から**建築する**へのマインドシフトが必要です。

![「絵を描く」から「建築する」へのマインドシフト](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-72.png)

この領域は教科書で学ぶのがとても難しく、実際にコードを書いたり、エンジニアと議論したりする中で泥臭く体得していくものです。そして、同じ組織の中でも、デザインシステムを構築する側と利用する側のデザイナーの間には、感覚に大きな溝がしばしばあります。

ここで扱う内容は、ソフトウェアエンジニアリングの設計原則と重なる部分が少なくありません。プロパティの設計、命名規則、変更の安全性、関心の分離——これらはエンジニアが日常的に考えていることです。デザイナーがこうした考え方を身につけると、3つのことが起こります。

1. **エンジニアとの会話が変わる。** 「この変更は破壊的ですか？」「このプロパティはEnumとBooleanのどちらが適切ですか？」——こうした問いを投げかけられるようになると、設計レビューの質が上がり、手戻りが減ります。
2. **デザインの影響範囲が見えるようになる。** Figma上の気軽な変更がコード側でどれほどの影響を持つかを想像できるようになります。この感覚があるかないかで、提案のしかたが変わります。
3. **チーム全体の生産性にレバレッジがかかる。** デザイナーがどのようにデザインを運用するかは開発工数に大きく影響します。さらには、開発工数やコミュニケーション効率は、デザインによる問題解決の速度にも構造的に影響します。デザインの仕方がチーム全体の生産性にレバレッジをかけるという視点は、あまり語られてきませんでした。

コードを書ける必要はありません。大事なのは、エンジニアが設計を考えるときの思考フレームを共有することです。同じ地図を見ながら会話できるようになるだけで、チームの動き方は大きく変わります。

とはいえ、読んでいただくとわかるかと思いますが、UIデザインをしてきたデザイナーであれば感覚的に理解していることをあえて言語化しているにすぎない箇所もあります。ああこれね、となるパートも多くあると思います。一度体得されるとあえて文章化されないような事柄がたくさんある事に気づきます。

この記事はデザイナー向けに書いていますが、エンジニアやPMにも役立つ内容を含んでいます。エンジニアにとっては、デザイナーの観点からの設計トピックを概観することができ、デザイナーにエンジニアリングならではの概念を説明することに役立ちます。PdMにとっては、デザインシステムへの投資がなぜ開発速度やプロダクト品質に効くのか、その構造的な理由が見えるようになります。

なお、このBookの筆者はプロダクトデザイナーで、エンジニアリングの経験はかじる程度です。エンジニアとデザインシステムを構築した経験は多数ありますが、一部知識が甘いところもあるかもしれません。ご容赦いただけたらと思います。

## AI時代とデザインシステム

昨今、生成AIによってデザイナーがコードに触れる敷居は大きく下がりました。AIがコードを書いてくれるからこそ、構造の設計を理解する価値が高まっています。それがプロダクトへの関わり方をより深くする機会になります。

デザインシステムへの投資をフェーズによってはおこなわず、短期の価値創出を優先する考え方もあります。しかし現在ではAIの支援で実装コストが下がっており、デザインシステム自体がAIの実装精度をさらに高める好循環につながるポテンシャルがあります。

デザインシステムをAIにコンテキストとして渡すだけで、自社のコンポーネントを使ったより精度の高いコードが返ってくるようになります。

ここでAIの精度を左右するのは、見た目の正確さ以上に、コンポーネントに込められた意味の正確さです。命名が意図を正しく伝え、プロパティの型が制約を明示し、バリアントが意味の違いを反映している。こうした意味的な整合性が、AIにとっても人間にとっても、設計意図を読み取る土台になります（ただし、AIのよしな力が高まれば、人間が苦心する場面も減っていくかもしれません）。

取り入れるかはあくまで状況次第ではありますが、デザインシステムの存在価値は現在〜今後の基準で再検討する価値があると考えます。AIがさらに発達してから取り入れる、恩恵を受けられるメンバーが増えてから取り入れる、あるいは後から移行しやすい土台だけ先に整えておく。段階的な選択肢もあります。

## この記事の読み方

この記事は8つの章で構成されています。

- 急いでいる方: コンポーネント分割と変数の2章だけで、日常の設計判断に必要な知識の大半がカバーできます
- じっくり読む方: 原則→戦略→分割→現実的な問題→変数→状態→レイアウト→アセットの順に、抽象から具体へ進みます
- 特定の課題がある方: 気になる章から拾い読みしても問題ありません

もしも読み終えたら、コンポーネントの設計に対する解像度は劇的に向上しているのではないかと思います。

- この記事では、[React](https://react.dev/) / [Swift](https://developer.apple.com/swift/) / [Kotlin](https://kotlinlang.org/) / [Flutter](https://flutter.dev/)といった技術スタックを問わず、デザインシステムの構築・運用でアプリでもWebでもよく遭遇する課題を、コンポーネント設計論として体系化することを試みました。わかりやすいよう、馴染み深いFigmaやNotionにたとえています。
- デザインシステムに関する諸概念は近年整備が進んだこともあり、登場する用語にはデファクトスタンダードが存在しない場合があります。社内で馴染む呼び方があれば読み替えてください。
- さまざまなファクターをごく総花的に扱います。すべて完璧に理解・運用することよりも、実践を通じて自社にあったやり方を見つけることのほうが重要と考えています。
- 必ずしも実装に連動することがデザインシステムの要件であるとは考えていませんが、この記事は、デザインとコードの一致性をある程度高めることのメリットを念頭に書いています（ややもすれば過激かもしれません）。参考になる部分だけ取り入れるとよいと思います。

# 原則: コンポーネントライブラリがめざすもの

Figma（あるいはSketch）のおかげで、デザイナーもコンポーネントの概念には馴染んできたのではないでしょうか。

コンポーネントという言葉は広い意味で使われます。ソフトウェアのモジュール、ハードウェアの部品、ビジネスプロセスの構成要素——いずれも「コンポーネント」と呼ばれることがあります。
この記事では、UIを構成する再利用可能な部品に限定して扱います。Figmaのコンポーネント機能で作るマスターコンポーネントとインスタンスの関係や、コードの関数コンポーネントがこれにあたります。

なぜ私たちはコンポーネントという単位で考えるのでしょうか。

それは、プロダクトを変更しやすくし、一貫性を保つためです。

Kevin Muldoonは[What Design Systems Actually Do](https://www.designsystemscollective.com/what-design-systems-actually-do-ea8a3daba32a)の中で、デザインシステムが提供する価値を間接化・カプセル化・制約・意味の符号化・合成・慣習という6つの抽象化で整理しています。この章では、その6つを土台にデザインシステムの考え方を紹介します。これらを押さえておくと、後の章で登場するプラクティスの背景が見通せるようになります。

これらは独立したチェックリストではなく、互いに補強し合い、ときに緊張関係を生む体系です。たとえば、制約は判断の負荷を下げますが、強すぎると合成の自由度を損ないます。カプセル化は複雑さを隠しますが、隠しすぎると慣習の形成を妨げます。このバランス感覚こそが、原則を現場に適用する際の要諦です。

## 間接化（Indirection）: 一箇所を直せば全部直る

トークンやマスターコンポーネントを介して、変更を一箇所に集約する仕組み。これが間接化です。「再利用性」と「変更のしやすさ」は、同じメカニズムの表と裏です。

同じものを何度も作らない。一度作った品質をどこでも再現できる——これはユーザー体験の安定に直結します。Figmaでマスターコンポーネントを更新すれば、すべてのインスタンスに変更が反映される。コードでも同様です。ボタンの押し心地やエラーの表示方法が画面ごとにバラバラだと、ユーザーは使うたびに学び直す必要があります。

組織の視点で見れば、コンポーネント化はコスト削減であると同時に、品質への投資にレバレッジをかける仕組みです。共通のコンポーネントがなければ、同じUIを作るたびにデザイナーごとの判断が入り、品質のばらつきを引き起こします。組織として決めたデザインをコンポーネントに落とし込んでおけば、誰が使っても同じ品質が再現でき、特定のデザイナーへの依存もなくなる。

さらに重要なのは、あるデザイナーやエンジニアが磨き上げた優れた設計判断が、コンポーネントを通じて組織全体に伝播するという点です（あるいは逆もしかりですが――）。アクセシビリティへの配慮、インタラクションの細やかさ、エッジケースへの対処——こうした品質は、個々の画面を作るたびにゼロから積み上げるのでは到底行き渡りません。コンポーネントに一度閉じ込めてしまえば、それを使うすべてのユースケースが恩恵を受けます。

たとえば、ブランドカラーを青から赤に変更するとします（別の意味で大変ですね！）。バラバラに実装されていたら、ボタンのある画面すべてをひとつずつ直さなければなりません。コンポーネントで管理されていれば、トークンの値をひとつ書き換えるだけで済みます。

実際にはブランドカラーの全面変更より、プライマリボタンの角丸を8pxから12pxに統一する、フォントサイズのベースを14pxから16pxに上げるといった地味な変更のほうが頻繁に起こります。こうした変更も、コンポーネント化されていれば一箇所の修正で全画面に反映できます。
デザイナーが少人数でも大規模なプロダクトを運用できるのは、このレバレッジが効いているからです。同じUIを1から作り直す工数が減り、新しい機能の開発に時間を使えるようになります。

![間接化: 1箇所の変更がすべてに届く](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-23.png)

Nathan Curtisは「[And You Thought Buttons Were Easy?](https://medium.com/eightshapes-llc/and-you-thought-buttons-were-easy-26eb5b5c1871)」の中で、ボタンひとつをデザイン・実装・テストするコストを$20,000（300万円）と見積もり、50チームがそれぞれ作れば$1,000,000（1億5000万円）になると試算しています。
（単価の設定が極端なので、1/10程度でイメージしたらよいかと思いますが、考え方としてはこういうことです）

間接化は、このコストを1回分に圧縮する仕組みです。そして圧縮されるのはコストだけではありません。1チームが丁寧に作ったコンポーネントを50チームが使えば、最高の品質もまた50チームに届きます。

## カプセル化（Encapsulation）: 複雑さを隠す

内部の複雑さを隠し、使う側にはシンプルなインターフェースだけを見せる。これがカプセル化です。ひとことで言えば、**ひとつの部品にひとつの責任を持たせること**でもあります。

ボタンを例に考えてみましょう。ラベルと背景色だけのシンプルな部品に見えますが、その裏には膨大な設計判断が隠れています。`Hover`・`Pressed`・`Disabled`・`Focus`のインタラクション状態、`primary`・`secondary`・`destructive`のバリアント、アイコンの有無と位置、ライト/ダークテーマ——これらの組み合わせだけで数百にのぼります。カプセル化されたボタンコンポーネントは、この複雑さを隠して「variant と size を選ぶだけ」にしてくれます。

![ボタンの複雑さ: シンプルに見えて設計判断の山](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-55.png)

たとえば、`UserCard`コンポーネントの中に、ユーザーデータを取得するロジックが埋め込まれていたとします。画面上ではきれいに動きます。しかし、同じカードを別の画面で「お気に入り一覧」に使いたくなったとき、データ取得先が決め打ちになっているので使い回せません。見た目だけ欲しいのに、データ取得のロジックがくっついてくるからです。

結果として、ほぼ同じ見た目の`UserCard2`が生まれます。この種の「似て非なるコンポーネント」の増殖は、カプセル化が崩れている兆候です。

もし`UserCard`が「受け取ったデータを表示する」ことだけに責任を持ち、「どこからデータを取ってくるか」を呼び出す側に任せていれば、どの画面でもそのまま使い回せます。Figmaでいえば、マスターコンポーネントが見え方を決め、インスタンス側がテキストや画像を差し替える関係と同じです。

この考え方があると、Figmaで修正したとき何に影響するかが予測でき、エンジニアに聞く前に安全な変更範囲を判断できます。バグ修正の影響範囲が局所化され、ある画面を直したら別の画面が壊れた、という事故を防げます。

### 3つの分離レイヤー

カプセル化は、コンポーネント設計のさまざまな場面で顔を出します。この記事では、以下の3つのレイヤーを順番に扱っていきます。

![カプセル化: 3つの分離レイヤー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-24.png)

- **見た目とデータの分離**: コンポーネントは表示に専念し、どんなデータを取ってきて渡すかは呼び出す側が担う
- **構造とスタイルの分離**: 骨組みと見た目の装飾を切り離す。後述するHeadless UIの思想。[Shadcn/ui](https://ui.shadcn.com/)はこの分離をライブラリレベルで体現した実例で、[Radix UI](https://www.radix-ui.com/primitives)が提供する骨組み（振る舞い＋アクセシビリティ）に[Tailwind CSS](https://tailwindcss.com/)で見た目を上書きする構成になっている
- **汎用とドメインの分離**: どこでも使える部品（`Button`や`Avatar`）と、特定の機能に特化した部品（`JobCard`）を混ぜない。コンポーネント分割の章で詳しく扱う

`UserCard`ひとつをとっても、3つの分離が見えます。見た目（レイアウトや色）とデータ（ユーザー名やアイコンURL）は分離すべきですし、骨組み（`Auto Layout`の構造）とスタイル（色・角丸）も分けられます。`UserCard`自体はドメインコンポーネントですが、その中で使う`Card`（枠）や`Avatar`（アイコン）は汎用コンポーネントです。

責任を分けておくからこそ、片方だけを変えたり、別の組み合わせで再利用したりできます。レイアウトの章で扱う、コンポーネントの中身（`padding`）と配置（`margin`）を分ける話も、カプセル化そのものです。

## 制約（Constraint）: 選択肢を絞り、判断の負荷を下げる

レストランで「10品のコース」と「何でもお作りします」のどちらが注文しやすいでしょうか。選択肢を意図的に絞ることで、判断の負荷を下げる。これが制約の原則です。

色を例にとりましょう。ディスプレイが表現できる色は約1680万色です。しかし、プロダクトで使う色が1680万色あったら、誰もデザインの一貫性を保てません。10色程度のセマンティックカラーに絞ることで、どの画面でも意味のある配色が再現できるようになります。

スペーシングも同じです。`margin`や`padding`に「好きな数字を入れてよい」とすると、14px, 17px, 23pxのような半端な値が乱立します。4/8/12/16/24/32のスケールに制約すれば、誰が作っても整ったリズムが生まれます。

![制約: 選択肢を絞り、判断の負荷を下げる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-53.png)

変数の章で扱うプロパティの型も制約の一形態です。Booleanは2択、EnumはN択、Stringは自由入力。型が厳しいほど誤用が減り、型がゆるいほど柔軟性が増します。

[Ross Horbiの試算](https://medium.com/@rosshorbi/how-i-created-a-design-system-for-buttons-cfebbc55106e)によると、とあるボタンの取りうる姿の組み合わせはサイズ4段階 × アイコン有無4パターン × スタイル5種 × 状態5種 × テーマ2種 = 960バリアントに達します。制約なしにすべてを自由設計すると破綻するのは明白です。

ただし、制約が強すぎると例外的なユースケースに対応できなくなります。制約と柔軟性のバランスをどうとるか。後の章では柔軟性と秩序のバランスについても考えます。

## 意味の符号化（Semantic Encoding）: 見た目ではなく意味で名付ける

Figmaで赤い塗りの四角形を描いたとします。これは「エラー表示」なのか「セール価格の強調」なのか、見た目だけでは判断できません。赤いボタンが「削除」を表す場合もあれば「エラー」を表す場合もある。

コンポーネントを設計するとき、「視覚的に正確か」と同じくらい「このコンポーネントが表現する意味は何か」を言語化しておくことが大切です。

この視点は、命名の章で扱う「色は意味で名付ける」原則にもつながります。

好例がRadix UIの[`Dialog`](https://www.radix-ui.com/primitives/docs/components/dialog)と[`AlertDialog`](https://www.radix-ui.com/primitives/docs/components/alert-dialog)です。どちらもオーバーレイ付きのモーダルウィンドウで、ピクセル単位ではほぼ同じ外観です。

しかし`Dialog`は背景クリックで閉じられる汎用モーダルであるのに対し、`AlertDialog`は「本当に削除しますか？」のような確認用で、背景クリックでは閉じられません。見た目ではなく、ユーザーに強制する操作の意味が違うから別コンポーネントになっています。

![Radix UI: Dialog と AlertDialog の違い](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-11.png)

アクセシビリティの国際標準規格（[WAI-ARIA](https://www.w3.org/WAI/ARIA/apg/)）でも、スクリーンリーダーに「通常のダイアログ」と「警告ダイアログ」を区別して伝える仕組みが用意されており、この設計判断はその規格に基づいています。意味を正しく符号化することは、アクセシビリティにも直結します。

## 合成（Composition）: 小さな部品を組み合わせる

レゴブロックを思い出してください。同じブロックの組み合わせで、家もロボットも作れます。コンポーネント設計でも同じことが起こります。

4つの小さな部品——`Avatar`、`Text`、`Badge`、`Button`——があるとします。これらを組み合わせるだけで、`UserCard`（Avatar + Text + Badge）にも`NotificationItem`（Badge + Text + Button）にもなります。部品そのものを増やさなくても、配置を変えるだけでバリエーションが生まれるのです。

![合成: 小さな部品を組み合わせて大きなUIを構築する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-54.png)

Figmaのコンポーネントネスト（コンポーネントの中にコンポーネントを入れること）は、まさに合成そのものです。

コンポーネントを柔軟にする方法には、設定値を増やすConfiguration（設定型）と、差し込み口を設けるComposition（合成型）の2つのアプローチがあります。設定値を増やしすぎるとプロパティが肥大化しますが、差し込み口を設ければ利用者が自由に中身を入れ替えられます。この2つのアプローチの違いは、変数の章でElement型（スロット）として詳しく扱います。

合成が強力なのは、バリエーションの増え方が線形ではなく組み合わせ的（combinatorial）だからです。4つの部品を個別に使えば4通りですが、組み合わせれば数十通りのUIが生まれます。部品の数を足し算で増やすのではなく、組み合わせの可能性を掛け算で広げる——この発想の転換が、デザインシステムのスケーラビリティを支えています。

## 慣習（Convention）: 暗黙知を形式化する

あなた以外の誰かが、安全に拡張できるか。

見落とされがちですが、チームの暗黙知を形式化したルール——命名規則やディレクトリ構造——がその土台をつくります。

プロダクトは成功するほど大きくなります。機能が増え、画面が増え、関わる人が増えます。コンポーネント、トークン、プロパティの選択肢——これらはすべて、プロダクトの歴史とともに誰かが増やしていくものです。

たとえば、ボタンのデザインを変える`variant`に`primary`と`secondary`しかない状態で、新しいデザイナーが「警告用のボタンが欲しい」と思ったとします。命名規則が明確であれば`destructive`や`warning`を自然に追加できます。ルールが曖昧であれば、`red-button`や`btn-alert`のような名前が生まれ、体系が崩れていきます。

体系がない場合、次のような時系列を辿るでしょう。`variant`名が色名・略称・英語混在でバラバラです。

1. `variant`: `primary` / `secondary` が存在する
2. 警告用が欲しい → `red-button` を追加
3. 控えめなボタンも欲しい → `btn-light` を追加
4. 半年後、`primary` / `secondary` / `red-button` / `btn-light` / `outline-gray` が混在し、新メンバーが `red-button` と `btn-light` の違いは何ですか？と聞く。答えられる人がいない

![慣習: ルールの有無が半年後の品質を決める](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-41.png)

最初の2人目が正しく拡張できたかどうかは、10人目の生産性を大きく左右します。新メンバーが既存の仕組みに沿って迷わず貢献でき、チームが大きくなっても生産性が落ちにくい。これが慣習のビジネスインパクトです。

慣習には、もうひとつ見逃せない効果があります。それは、チーム内の優れたプラクティスを組織全体に広げる媒体になるということです。あるデザイナーがアクセシビリティに配慮した命名規則を考案したとき、それが個人のノウハウに留まるか、チームの慣習として根づくかで、到達範囲はまるで違います。慣習とは、個人の知恵を組織の資産に変換する仕組みです。

拡張するために参照する体系をルール化することに加え、実装やFigmaファイルから類推可能であることが重要です。これはコンポーネントに限らず、トークンの命名体系、Enumの選択肢、ディレクトリ構造、あらゆる設計判断に通じる問いです。

## 補足: 経路依存性（Path Dependency）——初期の選択が未来を縛る

経路依存性（path dependency）とは、初期に選んだ道がその後の選択肢を制約し、後戻りが難しくなる現象のことです。Figmaでたとえるなら、最初に`Auto Layout`なしで画面を作り始めてしまい、50画面できたところで`Auto Layout`に移行しようとしたら、全画面を作り直す必要が生じ、結局対応がなされず、また51画面目が生まれるという状況。このように、過去の偶然おこなわれた選択が、巡り巡って適切な仕切り直しの機運すらも奪ってしまう状況です。

この現象はライブラリの選択、命名、ディレクトリ構造——デザインシステムのあらゆる要素に関連します。いくつか例を見てみましょう。

たとえば、立ち上げ期に[MUI](https://mui.com/)を採用して管理画面を作ったケースを考えてみてください。最初は開発スピードが出て順調でした。

ところが1年後、ユーザー向け画面にも独自のデザインを入れたくなったとき、`MUI`のスタイル上書きがいたるところに広がっていて、Headless UIに乗り換えようにも影響範囲が大きすぎて踏み切れない。

![経路依存性: 初期の選択が未来を縛る](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-39.png)

命名も同じです。初期に`Card`と名付けたコンポーネントが50画面で使われたあとに「やっぱり`Tile`のほうが適切だった」と気づいても、Figma・コード・ドキュメント・チームの会話すべてに染みこんだ名前を変えるコストは、最初に決めるコストとは比べものになりません。

こうした構造は、デザインシステムのあらゆる層に潜んでいます。ディレクトリ構造、プロパティ設計、どれも時間が経つほど方向転換が難しくなります。

経路依存性の厄介さをさらに際立たせるのが、追加と削除のコストの非対称性です。コンポーネントに新しいプロパティやバリアントを追加するのは比較的簡単です。コードを数行足し、Figmaにバリアントをひとつ加えるだけ。既存の利用箇所には影響しません。一方、一度追加したものを削除するのは桁違いに大変です。

たとえば、ボタンに`ghost`というバリアントを追加した場面を考えてみてください。追加したその日は5分の作業です。しかし半年後、「`ghost`は`outline`と役割が重複しているから統合しよう」と判断したとき何が起きるでしょうか。

- `ghost`を使っている全画面を洗い出す必要がある
- 各画面で`outline`に置き換えて問題ないか個別に判断する
- Figmaのインスタンス、コード、テスト、ドキュメントをすべて更新する
- 「なぜ`ghost`がなくなったのか」をチームに説明し、合意を得る

5分で追加したものを削除するのに、数日から数週間かかることは珍しくありません。そして、この非対称性は時間とともに拡大していきます。使われている画面が10のときに削除するのと、100に増えてから削除するのでは、コストが文字通り桁違いです。使われる期間が長いほど、チームの語彙に染みこみ、ドキュメントに書かれ、新メンバーがそれを前提に学習する。削除のコストは線形ではなく、時間に対して加速度的に上がっていきます。

この性質を知っていると、「とりあえず追加しておこう」という判断の重みが変わります。追加はほぼ無料に見えますが、実際にはその瞬間から将来の削除コストが積み上がり始めています。慎重に追加し、使われなくなったものは早めに非推奨（deprecated）にする——この姿勢が、長く使えるコンポーネントライブラリを支えます。

だからこそ初期の設計判断は慎重に決める価値がありますが、未来にわたってスケーラブルな判断を最初から下せるかというとそうもいきません。結局これは、どれくらい先のことまで見据えて設計・実行できるかという問題にもなっていきます。ただ、先を見通すにも手を動かすにもリソースが要るので、現実にはこうした性質を頭に入れながら後で改修しやすくしておくか、あるタイミングでコストを払ってやりきるか、あるいは散らかったままで割り切るか——チームの状況に応じた落としどころを探ることになります。

## 意図的な妥協: 場当たりを「設計」にする

6つの原則と経路依存性の力学を理解したとしても、現実にはすべてを理想通りに進められる場面はほとんどありません。リリースは来週、エンジニアは2人、デザイナーは兼務——こうした状況で「原則を完全に守れるまで出せない」とは言えません。

場当たり的な対処は、どのプロダクトでも必ず発生します。問題は場当たり的であること自体ではなく、なんとなくやって、なんとなく定着してしまうことです。

なんとなく`Card`と名付けたが本当にそれでよいか検討していない。なんとなくBooleanにしたが、3つ目の選択肢が出てきたらどうなるか考えていない。こうした「考えていない」が積み重なると、経路依存性の力学が効いてきて、後から見たときに「なぜこうなっているのか」を誰も説明できない状態になります。

場当たり的な対処を意図的な妥協に変えるのに、大きな手間は要りません。

- **「なぜ今こうするか」を一言残す。** Figmaのコメントやコードのコメントに「本来はEnumだが、選択肢が確定していないためStringで仮置き」と書くだけで、後から見た人が修正の判断材料を得られる
- **後で直しやすい方向に倒す。** 名前を仮で決めるなら、少なくとも一括置換しやすい一意な名前にする。型を仮で決めるなら、より厳密な型への移行が非破壊的変更になる方向を選ぶ（Stringで仮置き → 後でEnumに絞る、のほうが逆よりも安全）
- **「今はやらない」と「やらなくていい」を区別する。** 意識的に先送りした判断はチーム内で共有し、何が起きたら着手するかのトリガーを決めておく。トリガーがないと、先送りは風化して既成事実になる

原則を知らずに場当たり的に進めるのと、原則を知ったうえで意図的に妥協するのでは、見た目は同じでも半年後の改善のしやすさがまるで違います。理想を知っているからこそ、「今はどこまでやり、どこを後に回すか」という線引きができるのです。

## 一般化と個別化のバランス: どちらに寄せるか

コンポーネントをより多くの場面で使えるようにしたいとき、一般化と個別化のどちらに寄せるかが問題になります。

一般化とは、さまざまな文脈で使えるよう抽象度を上げることです。`Button` はどんなページでも使えますが、特定のページに最適化されてはいません。個別化とは、特定の文脈に合わせて最適化することです。`ShiftApplyButton` は求人応募画面に完璧にフィットしますが、他の画面では使えません。

この緊張関係は、デザインシステムのあらゆる設計判断に顔を出します。

- **コンポーネントの粒度**: 汎用コンポーネントとドメインコンポーネントの線引き
- **プロパティの型**: Enum（選択肢を限定する一般化）とString（自由入力を許す個別化）の選択
- **共通化のタイミング**: 似たUIを早期にまとめるか、個別のまま育てるか
- **柔軟性の設計**: 設定値で制御するか（一般化）、差し込み口を設けて利用者に委ねるか（個別化）

一般化しすぎると、どの文脈でも使えるがどの文脈にも最適ではないコンポーネントが生まれます。プロパティは膨張し、条件分岐が増え、「このプロパティは何のために存在するのか」を誰も説明できなくなる。

個別化しすぎると、似た見た目のコンポーネントが乱立し、変更のたびに複数のコンポーネントを同時に修正する羽目になります。一箇所を直せば全部直るという間接化のメリットが失われます。

最適解はプロダクトのフェーズやチームの規模によって変わります。立ち上げ期は個別化寄りで素早く作り、パターンが見えてきたら一般化する。成熟期には一般化された基盤を維持しつつ、ドメイン固有の要件は個別のコンポーネントで吸収する。

大事なのは、いま自分たちがこのスペクトラムのどこにいるかを自覚し、意図的に選ぶことです。なんとなく共通化する、なんとなく専用のものを作る——この「なんとなく」が、経路依存性を通じて後から修正しにくい構造を生みます。この緊張関係は以降の章で繰り返し登場しますが、正解がひとつに定まらないからこそ、判断の軸を持っておくことに価値があります。

---

以上の6つの原則——間接化・カプセル化・制約・意味の符号化・合成・慣習——は、後の章で登場する具体的なプラクティスの土台になります。すべてを一度に実現する必要はありません。自分たちのシステムがどの原則をカバーしていて、どこが手薄かを把握しておくと、自組織が強化すべきポイントが見えてきます。

経路依存性はこれらの原則そのものではありませんが、原則を適用する際に常に意識しておくべき力学です。初期の設計判断がどれほど後に響くかを知っていれば、6つの原則への向き合い方も変わります。

デザインシステムは、チームの認知リソースを再配分します。ボタンの色やサイズで悩む時間がなくなった分、ユーザーの課題解決や情報設計に集中できる。工数の削減と思考の質の向上に加え、間接化の節で見たように、優れた設計判断がシステムを通じて組織全体に行き渡るレバレッジも生まれます。

換言すれば、デザインシステムとは認知的余白を生み出す仕組みです。定型的な判断をシステムに委ね、人間の注意力をまだ答えのない問いに向ける。この再配分の効果は、関わる人数が増え、判断の頻度が上がるほど顕著になります。

//todo ここのジレンマについて書く
難しいのは、デザインシステムへの向き合いに時間をかけすぎてしまうことは、かえって答えのない問いに向きあう時間を没却しているのではないか？（つまり、今どこのどの時間軸にフォーカスするのか？という問い）

## デザインシステムがないとどうなるか

原則を押さえたところで、ここまでの話を裏側から見てみます。デザインシステムがない、あるいは機能していない状態で何が起きるか。

**デザイナーの視点。** デザインの判断基準が個人の頭の中に閉じます。ボタンのスタイルや余白のルールが明文化されていないため、デザイナーごとに微妙に異なるUIが生まれ、プロダクト全体の一貫性が人の記憶力に依存します。新しいメンバーは暗黙のルールを一つずつ学ぶ必要があり、チームが大きくなるほどこの負荷は増えていきます。

**エンジニアの視点。** デザインとコードの間に共通の語彙がないため、デザインカンプの解釈が毎回発生します。同じ意図の見た目が画面ごとに異なる実装として積み重なり、プレゼンテーション層に技術的負債が蓄積します。コードベースの中で似た役割のコンポーネントが散在し、どれが正で何が派生なのかを把握するコストが機能追加のたびに増大します。

**PdMの視点。** プロダクトの一貫性が、設計ルールではなく個別のレビューに頼る状態になります。UIの変更（ブランドカラーの刷新、トーンの統一など）を実施しようとしたとき、影響範囲の特定自体がプロジェクトになる。デザインレビューが視覚的な細部の指摘に時間を取られ、ユーザー体験や情報設計の議論に到達しにくくなります。

**マネージャーの視点。** プロダクトの成長とともにUI開発の速度が鈍化していきます。画面数が増えるほど暗黙の規約も増え、それを知っている人がボトルネックになる。チーム横断でUIの一貫性を保つには、システムによる担保ではなく人による調整が必要になり、コミュニケーションコストがチームの人数に比例して膨らみます。デザインシステムへの投資判断を先送りするほど、あとから導入するコストが上がっていく——これも経路依存性の一種です。

![デザインシステムがない世界: 4つの立場から見た課題](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-73.png)

いずれの立場にも共通するのは、すでに決まっているべきことが決まっていないために、同じ判断を繰り返しているという構造です。デザインシステムは、この繰り返しを仕組みとして吸収し、チームの認知リソースを本来の問題解決に向けるためのものです。同時に、デザインシステムがないということは、誰かが苦労して見つけた優れた解決策——たとえばエラー表示の最適なパターンや、アクセシビリティを満たす配色——が個人の手元に留まり、組織全体に還元される経路がないということでもあります。

ただし、デザインシステムの導入がつねに正解というわけではありません。立ち上げ期のプロダクトでは、UIの方向性自体がまだ固まっていないことがあります。その段階で体系化に投資すると、試行錯誤の速度を落とし、まだ見えていない要件に対して早すぎる最適化をしてしまうリスクがあります。少人数のチームでは暗黙の共有で十分に回っている場合もあり、仕組み化のコストが利益を上回ることもあります。

逆に、すでに回っているプロダクトに後からデザインシステムを整備していくのも簡単ではありません。既存のコードやデザインファイルとの整合性を取りながら段階的に移行する必要があり、投資対効果が見合うやり方を模索しながら進めることになります。改修頻度が高くない領域であれば、無理に統一せず現状のままにしておくほうが合理的なこともあります。

デザインシステムが効くのは、チームや画面の数が増え、暗黙知だけでは一貫性を維持できなくなった段階で、かつUIの変更が継続的に発生する領域です。自分たちがいまどのフェーズにいるか、どこに投資すべきかを見極めることが出発点になります。

原則を押さえたうえで、次いで、これらの原則をどのような手段で実現するか——構築戦略の選択について検討します。

# 構築戦略: どう作るかを選ぶ

## 構築戦略の全体像

コンポーネント設計の具体に入る前に、デザインシステムの構築戦略のパターンをおさえます。

コンポーネントの設計論の序盤になぜこのような大仰なトピックを扱うというと、コンポーネントの運用は土台となるデザインシステムの方式に規定される部分が大きいからです。

しばしば、プロダクトが生まれる際、それをどう構築するかの検討は入念におこなわれなかったり、限られた情報と特有の状況のなかでおこなわれます。デザインシステム以上に重要と思われる事情がたくさんあることのほうが普通です。そして、ある構築方法を選んだ日が、2年後のリブランドの可否を決めていた——そんなことが起こりえます。構築戦略の選択は、その後の自由度や拡大効率を大きく左右します。

もしこの記事をプロダクトの立ち上げ期に読んでいるデザイナーがいるとしたらとても幸運なことです。

ここで紹介する戦略の違いは、デザイナーの日々のワークフローにも影響します。汎用コンポーネントライブラリを採用するなら既存テンプレートのカスタマイズが中心になり、Headless UIベースなら全状態を自分でデザインする責任が生まれます。どちらを選ぶかで、あなたの仕事の範囲が変わります。自社のフェーズやリソースに合わせて適切な戦略を選ぶ必要があります。

![構築戦略の4パターン: コストと自由度のトレードオフ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-25.png)

## 汎用ライブラリの活用: MUIやChakra UIを土台にする

外部公開されているライブラリをそのまま活用する方法です。[Material UI](https://mui.com/)、[Chakra UI](https://chakra-ui.com/)、[Ant Design](https://ant.design/)などがこれにあたります。どんなサービスにも使える汎用のコンポーネント群です。

![汎用ライブラリのコンポーネント例: MUI / Chakra UI / Ant Design](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-56.png)

すでにひと通りのコンポーネントがそろっているため、すぐに開発を始められるのが強みです。`Button`、`Input`、`Modal`、`Table`など、基本的なUI部品はすべて用意されています。とくに初期フェーズのスタートアップや、管理画面のような機能性重視のプロダクトでは、採用するメリットが大きいです。

一方で、どこかで見たことのあるデザインになりがちです。ライブラリの設計思想に強く依存するため、そこから外れた独自のUIを実現しようとすると、かえって実装コストが高まる場合があります。独自性のあるデザインや機能をもつToCサービスでは、カスタマイズの限界がネックになることがあります。

汎用ライブラリがコードとして提供されている場合、対応する言語やフレームワークはライブラリごとに異なります。WebではReactが多いですが、[Material Design](https://m3.material.io/)は[Jetpack Compose](https://developer.android.com/compose)、[Flutter](https://flutter.dev/)、[Angular](https://angular.dev/)などさまざまな環境向けに頒布されています。汎用ライブラリの採用は自社の技術スタックに深く依存します。

また、こうした外部ライブラリへの依存にはいくつか技術的なリスクもあります。

- **アップデート追従コスト**: 大きなバージョンアップで互換性のない変更が含まれると、自社のコード全体を見直す必要が出てきます。カスタマイズしていた部分が動かなくなることもあります
- **ライブラリ自体の存続リスク**: オープンソースのライブラリはメンテナーの運営に依存します。開発が停滞したり、サポート終了になったりすれば、別のライブラリへ移行する大がかりな作業が発生します

とはいえ、上記のリスクは見通しが不明瞭なプロダクト開発において、短期的なメリットを優先できるのであれば有力な選択肢です。

## フルスクラッチでの構築: 自社専用をゼロから作る

自社専用のデザインシステムをゼロから構成するパターン。

[SmartHR UI](https://github.com/kufu/smarthr-ui)や、[デジタル庁デザインシステム](https://design.digital.go.jp/)などがよい例です。たとえば、SmartHR UIでは、コンポーネント名やプロパティ名を日本語の業務用語に合わせて設計しており、ドメインとの一致を優先する判断が見られます。自社の設計思想を100%反映でき、事業領域に特化したコンポーネントを最適化して、ユーザー体験の質を追求できます。

ただし、作るのにも維持するのにもコストがかかります。ボタンひとつとっても、マウスを乗せたときの変化、キーボードで選択したときの枠線、アクセシビリティ対応など、考えるべき点は山ほどあります。これらをすべて自社でメンテナンスし続ける心づもりが必要です。

後ほど言及しますが、すでに稼働中のプロダクトに後からデザインシステムを適用する場合、BtoCのサービスの場合はこのパターンに至ることも少なくありません。

## Headless UIの活用: 見た目を持たないライブラリ

ここ数年で注目されているのがHeadless UI（Headless = 頭のない、つまり見た目の層を持たないという意味）です。Radix UI、[React Aria](https://react-aria.adobe.com/)、[Headless UI](https://headlessui.com/)といったライブラリがあり、多くのプロダクトで採用が進んでいます。

これらは見た目を持たず、機能だけを提供するライブラリです。Figmaでたとえるなら、`Auto Layout`の構造だけが用意されていて、色・フォント・角丸は一切ついていない状態のコンポーネント集です。見た目は自分たちで自由にデザインします。

たとえば、ドロップダウンメニューやモーダル、`Combobox`といったコンポーネントは、アクセシビリティへの対応がとても複雑です。これを自社でゼロから正しく実装するのは大変です。Headless UIを使えば、この複雑な裏側のロジックはライブラリに任せつつ、見た目だけを自社のスタイルで自由にあてることができます。車輪の再発明を防ぎながら、自由度を確保できます。

Headless UIの設計思想がよく表れているのが、見た目が似たコンポーネントの分類です。

![Radix UI: 見た目が似た3つのコンポーネント](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-14.png)

Radix UIには、いずれもドロップダウン的な見た目の[`Select`](https://www.radix-ui.com/primitives/docs/components/select)、[`DropdownMenu`](https://www.radix-ui.com/primitives/docs/components/dropdown-menu)、[`ContextMenu`](https://www.radix-ui.com/primitives/docs/components/context-menu)が別々のコンポーネントとして存在します。`Select`はリストから値を選ぶUI、`DropdownMenu`はメニューからアクションを実行するUI、`ContextMenu`は右クリックで開く操作メニュー。

![Headless UI: Listbox / Combobox / Menu](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-57.png)

Headless UIライブラリも同様に、[`Listbox`](https://headlessui.com/react/listbox)はドロップダウンで1つ選ぶUI、[`Combobox`](https://headlessui.com/react/combobox)は入力しながら候補が絞られる検索付き選択UI、[`Menu`](https://headlessui.com/react/menu)はアクション一覧、というように分離しています。ポップオーバーが開いて項目が並ぶという見た目は共通しているのに、なぜ分けるのか。それはユーザーが何をしたいか——値を選ぶのか、アクションを実行するのか、検索してから選ぶのか——が違うからです。

見た目ではなくインタラクションの目的でコンポーネントを分ける。これがHeadless UIの設計思想であり、後述する「汎用とドメインの分離」にも通じる考え方です。

スタイリングは自分たちでおこなう必要があるため、MUIなどの完結型ライブラリに比べれば初期の手間はかかります。しかし、長期的な運用のしやすさを考えれば、初期コストを払う価値は十分にあります（コンポーネント間の一貫性を保ちながら各コンポーネントをスタイリングするのはAIが得意そうです）。

デザイナーにとっては、MUIのように既成のFigmaテンプレートをカスタマイズするのではなく、骨組みに対して自分たちでゼロからスタイルを設計することになります。自由度は高い反面、使用するコンポーネントのデザインを自分たちで定義する責任が生まれます。

なお、公開されているFigmaテンプレートを自社に合うように加工することになりますが、テンプレートが部分的に実装に足りていない場合がよくあります。必要な分だけ最低限取り入れるという割り切りが必要になってきます。

## ハイブリッド戦略: 組み合わせて使う

いくつかのパターンを紹介しましたが、現実的にはこれらを組み合わせることが有力です。

たとえば、`Button`、`Input`、`Checkbox`といった部品はHeadless UIをベースに自社スタイルをあてて構築し、ドメイン固有の部品は自社で独自に開発する。あるいは、プラットフォームが分かれていれば、管理画面はMUIをそのまま使い、ユーザー向けアプリはフルスクラッチで作るなど、組み合わせ方はさまざまです。

また、ベースはフルスクラッチでありながら、一部の実装が複雑なコンポーネントについてはHeadless UIや汎用ライブラリから拝借するという実装方法も存在します（その場合、実装方法の乖離が少ない選択肢が検討されます）。

なんとなく作るのではなく、短期・長期両面でリソースと目的を天秤にかけ、ここはライブラリに頼る・ここは自社の独自性を追求する、という線引きをなるべく初期に議論することが望ましいです。後になるほど方針転換のコストが大きくなるためです。

## 後発導入: 稼働中のプロダクトにシステムを入れる

### 後からのほうが大変

すでにデザインシステムなしで開発が進んでいるプロダクトに、後からシステムを導入するケースも少なくありません（いや、ほとんどそうだから大変なのです）。

なぜ後発導入が難しいのかを理解しておくと、戦略を立てやすくなります。ゼロから作るプロダクトなら最初からコンポーネントを揃えられますが、稼働中のサービスにはすでに動いているUIが資産として存在しているからです。一度に変えると、QA（品質確認）の範囲が爆発し、リグレッション（意図しない既存機能の破壊）が起きやすくなるためです。

ユーザー影響や改修範囲などを考えると、この資産を壊さずに、新しい仕組みに段階的に置き換えていく必要があります。そうした観点から、フルスクラッチに近い構築になることが多いです。

ただし、中長期的なメリットを見据えたHeadless UIや既存ライブラリの活用も含めて、エンジニアリングチームと早い段階で議論しましょう。技術スタックや既存コードとの相性によって、最適な戦略は大きく変わります。

後発導入で実践的なのは、以下の3ステップです。

![後発導入: 稼働中プロダクトへの3ステップ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-44.png)

1. デザイントークンから入る。 コンポーネントの前に、色・フォントサイズ・余白のトークンを定義して既存コードに適用する。見た目はほぼ変わらないが、後からの一括変更が可能になる。これがもっとも低リスクで効果の高い出発点です
2. 新規画面から準拠する。 既存画面は触らず、新しく作る画面だけをデザインシステムに沿って設計する。新規画面は100%準拠というルールを置くことで、デザインシステムの利用実績が自然に積み上がります
3. 既存画面は優先度をつけて段階的に移行する。 ユーザーの利用頻度が高い画面や、変更が予定されている画面から置き換えていきます

古いUIと新しいUIが一時的に混在する状態は、どのプロダクトでも起こりうるものです。

混在期間は避けられないと受け入れたうえで、その期間を管理することに意識を向けましょう。全部揃うまで出せないではなく、揃ったところから価値を出すという方針が現実的です。

### LLMによるリファクタリングへの期待

一方で、すでに稼働中のプロダクトにデザインシステムを導入するのであれば、機能や挙動の本質を変えずにパーツを差し替えていくことであるので、一定LLMによる実装の再現性が高い領域であるといえます。また、見た目とロジックの分離がかなっていれば、表層面の差し替えとしてこれをおこなえるため、一定画面で見てデバッグすれば問題も回収できると捉えることができます。

1. コードレビューや移行設計の問題はあるものの、既存プロダクトにデザインシステムを実装する工数が膨大であるという観点は解決されつつあります。
2. LLMによる日々の実装の再現度を高めるメリットを享受できるのであれば、デザインシステムへの投資は従来よりも高いレバレッジをもっていると評価できます。

上記の観点から、今後、稼働中プロダクトに一気に導入するケースが生まれる可能性があります。


## 戦略を選ぶ前に: ボトルネックはどこか

構築戦略を決める前に、自分たちのチームで何が本当のボトルネックなのかを診断することが重要です。従来、ボトルネックはUIの実装スピードにありました。しかしAIがコードを書く時代には、事情が変わりつつあります。

実装スピード以上に、フィードバックループの速度——良い決定をするために必要な情報がチーム内で時間内に集まるか、変更の影響を正確に把握できるか——といった「決定の質」が、より大きなレバレッジを持つようになってきていると考えます。

たとえば、コンポーネントの分割方針を変えたいとき、影響範囲を30分で把握できるチームと3日かかるチームでは、意思決定の速度が桁違いです。

デザインシステムへの投資も、この視点で優先度を判断すると、自社にとって最も効果的な出発点が見えてきます。有名なデザインシステムの構成をそのまま真似たくなりますが、他社の正解が自社の正解とは限りません。色の不一致、命名の混乱、手戻りの多さ——いま自分たちが何に困っているかを起点に、具体的な痛みから解決していく姿勢が、長く機能するデザインシステムにつながります。

---

構築戦略と土台の議論はここまでです。以降では、個々のコンポーネントをどう設計するかという、より具体的な問いに踏み込んでいきます。

# コンポーネント分割: 何をどう分けるか

ボタン、カード、モーダル——同じ名前のコンポーネントなのに、デザイナーとエンジニアの頭の中にある形が違う。そんなすれ違いの多くは分割の基準を策定・共有していないことから生まれます。

コンポーネントの分割とは、複雑なUIを認知しやすい単位に切り分ける行為です。適切な境界線は、個々の部品を理解しやすくし、変更時の影響範囲を限定し、チーム間の責任分担を明確にします。境界線をどこに引くかは技術的な判断であると同時に、チームの認知負荷を設計する問いでもあります。

## コンポーネント設計の考慮事項

ひとつのコンポーネントについて検討すべき要素は多岐にわたります。大まかに次のような考慮事項があります。

![コンポーネント設計の8つの観点](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-31.png)

- 階層: どこに位置するか
- 名前: コンポーネント名、プロパティ名、値の名前
- プロパティ: 何を受け取り、どんな型か。必須か任意か
- 見た目: バリアント、色、サイズ、レイアウト
- 状態: Loading / Error / Empty / Partial / Ideal
- 依存関係: 何に依存し、何から利用されるか
- トークン: どのデザイントークンを参照するか
- 振る舞い: 幅の伸縮、レスポンシブ対応

ボタンひとつとっても、これだけの要素が同時に存在します。どれかひとつだけを決めればよいのではなく、これらが絡み合ってコンポーネントの設計になります。この記事の各章では、それぞれの要素を掘り下げていきます。

仮にFigmaとコードの一致性を目指す場合、コンポーネントの命名・ディレクトリ・責務範囲を後から変更するコストが大きい場合が多いです。デザイナー同士の連携、エンジニアとの連携、使用している箇所の改修。利用箇所が多いほど大変です。

だからこそ、個別のコンポーネントをどう名付け、位置づけるかは、誰でも同じ判断ができるよう組織内で整備することが重要です。そして、コンポーネント分割の思想は、コンポーネントの命名とディレクトリ分けに影響し、デザインシステムのオペレーションの基礎となります。

## コンポーネント化するか？

前提として、UIはコンポーネント化せずに画面に直接作り込むこともできます。

Figmaでいえば、マスターコンポーネントにせず通常のフレームとして描くことに相当します。つまり、画面に映るものすべてがコンポーネント化されている必要は（技術的には）ありません。

では、何をコンポーネント化すると組織が最も恩恵を受けられるのでしょうか。判断の軸としては、一箇所を直せば全部直る状態にしたい・連続性をもって拡張したい場合にコンポーネント化する。

コンポーネント化されているということは、そのコンポーネントを拡張したり、類似するものはそのコンポーネントのやり方に従うという道を開いていることです。つまり、単なる1画面に登場するUI以上に、組織的な合意や規範が詰まっていると捉えることができます。

実務ではいくつかの基準が使われています。

- よく使われるUIや汎用用途のものだけをコンポーネント化する
- 2回以上使用されたらコンポーネント化する
- 今後再利用される可能性のあるUIをコンポーネント化する
- 再利用性を問わず、画面上のすべての要素をコンポーネント化する

この考え方の背景にあるのがSSOT（Single Source of Truth）——真実の情報源はひとつだけ、という原則です。原則の章で紹介した間接化の考え方そのものです。Figmaでいえば、コンポーネントのマスターを1つ持ち、全画面でそのインスタンスを使う。マスターを更新すれば全インスタンスに反映される。

たとえば、フッターのリンク一覧。今は1画面にしか置いていなくても、将来2画面目に必要になったとき、コピー&ペーストで増やすとリンクの追加漏れが起きます。コンポーネント化しておけば、元を直すだけで全画面に反映されます。

一方で、見た目が似ているからといって何でも共通化すればよいわけではありません。この判断については「早すぎる共通化の罠」で詳しく扱います。

迷ったときは、以下のようなフローをチームではなしてみるといいかもしれません。

![コンポーネント化の判断フロー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-01.png)

## コンポーネントの分割方法: 3つのアプローチ

コンポーネントの整理方法にはいくつかのアプローチがあります。チームの規模やプロダクトの複雑さに応じて使い分けます。代表的な3つを取り上げます。

### Atomic Design: 複雑さで分ける

[Atomic Design](https://atomicdesign.bradfrost.com/)は、Brad Frost氏が提唱したUIの構造化手法です。化学のメタファーを用いて、UIを以下の5つの階層に分類します。

- Atoms（原子）: ボタン、ラベル、入力フィールドなど、これ以上分割できない最小のUI要素
- Molecules（分子）: 原子を組み合わせた小さな機能単位。検索バーなど
- Organisms（有機体）: 分子や原子を組み合わせた、ひとまとまりのUI領域。ヘッダーやカードリストなど
- Templates: Organismsを配置したページの骨格。実データではなくワイヤーフレーム的な構造
- Pages: Templatesに実データを流し込んだ、最終的な画面

このアプローチは、小さな部品からUIを積み上げるという考え方を広く浸透させました。

![Atomic Design: 5つの階層](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-40.png)

ところが、実際に使ってみるとやっかいなのは、`molecules`と`organisms`の境界線が人によってバラバラになることです。ボタンと入力フォームを組み合わせたら分子なのか、それが特定の検索窓になったら有機体なのか。

実際には、ある程度くずした運用をしている場合が多いです。たとえば、`atoms`と`molecules`の2層のみを使い、`organisms`との境界線に悩む時間を省くという判断もあります。

Atomic Designは日本のサービスでも導入事例が豊富であり、そして辛みやその解決も多く発信されています。

### Feature-Sliced Design: 目的で分ける

Atomic Designはコンポーネントの構造で分類する考え方でした。もうひとつ、何のための部品かで分類する考え方があります。[Feature-Sliced Design](https://feature-sliced.design/)（FSD）と呼ばれる手法のエッセンスです。

Figmaのページやセクションをどう整理するかを考えるときにも使える視点なので、ここでは3つのレイヤーに絞って紹介します。

- **UI Kit レイヤー** — どのプロダクトでも使い回せる、汎用的なUI部品です。`Button`、`Input`、`Avatar`、`Badge`など。
- **Features / Domain レイヤー** — 特定のサービスやデータに紐づくコンポーネントです。商品カード、ユーザープロフィール、お気に入りボタンなど。
- **Widgets / Templates レイヤー** — 上の2つを組み合わせて作る、大きなかたまりです。ヘッダー、フォーム全体、商品一覧セクションなど。

大事なのは矢印の方向です。上のレイヤーは下のレイヤーを使えますが、逆はありません。

ECサイトで具体的にイメージしてみましょう。

![Feature-Sliced Design の3層構造](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-02.png)

- UI Kit: `Button`、`Input`、`Card`、`Tag` — どんなサービスにも使い回せる
- Domain: `ProductCard`（商品の情報を表示する）、`CartItem`（カート内の1行） — ECサイトのデータに依存する
- Widgets: `ProductListSection`（`ProductCard`の一覧＋フィルター）、`CheckoutForm`（`CartItem`の一覧＋決済ボタン） — Domainの部品を組み合わせた画面の骨格

`ProductCard`は`Button`や`Badge`を使いますが、`Button`が`ProductCard`の存在を前提にすることはありません。

この一方通行が崩れると何が起きるか。`Button`が`UserCard`に依存していたら、`UserCard`を変更するたびに`Button`まで壊れるかもしれません。一方通行であれば、影響は常に下流（利用する側）にしか伝わりません。

Figmaで考えると直感的です。`Button`コンポーネントが`UserCard`のインスタンスを内部に含んでいたら、おかしいですよね。それと同じ感覚です。

この方式のメリットは、依存の方向が明確になることで影響範囲の予測がしやすくなる点です。UI Kitを修正しても影響はそれを使うDomain以上のレイヤーに限られ、Widgetsの変更がUI Kitに波及することはありません。レイヤーごとに責務が分かれているため、コンポーネントが増えても構造が破綻しにくく、新しいメンバーもどの階層に手を入れるべきか判断しやすくなります。

この考え方は、後述の汎用・ドメインの考え方にも重複するところがみられます。

### フラットに置く: 階層なしで並べる

すべてのコンポーネントを階層なしにひと箇所にまとめるシンプルな方法です。コンポーネント数が少ないうちは、分類に悩む必要がなく、見通しもよいため十分に機能します。Figmaでいえば、ページやセクションを分けず、すべてのコンポーネントを1つのページにフラットに並べている状態です。小規模なプロダクトでは有効な選択肢です。

ただし、コンポーネントが増えてくるとどこに何があるか分からない問題が目立ってきたり、責務設計に規律がないまま発展しがちです。コンポーネント数が20〜30を超えてきたら（これは厳密なルールではなく、ファイルを開いたときに一覧性を失い始める目安です）、前述のような階層化を検討するとよいでしょう。

見通しが悪くなってから整理するより、少し早めに構造を入れるほうが移行コストが小さくなります。

## 汎用とドメインの分離: どこでも使える部品と専用の部品

Atomic Design、FSD、フラット配置と3つのアプローチを見てきました。次いで、Feature-Sliced Designにも内包されていた汎用とドメインという分類軸について、より詳しく検討します。
そのコンポーネントが汎用的(generics, general)なものか、ドメイン(domain, feature)に関連するものかという分類です。

![汎用コンポーネントとドメインコンポーネントの依存関係](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-03.png)

これは汎用ライブラリにはない、インハウスならではの論点です。実務で頻繁に直面するにもかかわらず、体系的に語られることが少ないテーマでもあります。

なぜデザイナーがこの区別を知る必要があるのか。この境界を意識しないと「なんでも入る万能コンポーネント」か「どこにも使い回せない専用コンポーネント」の両極端に振れやすいからです。

汎用とドメインの境界を引くことで、プロパティの肥大化と亜種の増殖を同時に防げます。

この境界を設ける目的は、コンポーネントが使える範囲を限定することです。
汎用コンポーネントはどこからでも呼び出せますが、ドメインコンポーネントは特定の機能の文脈でのみ使う、という規約です。

この判断はコンポーネントを作るタイミングでおこなうことが有効です。一度汎用として作ったコンポーネントに、特定の機能でしか使わない表示ルールが入り込むと、後から切り離すコストが高まります。
逆に、最初からドメイン専用として作っておけば、汎用化が必要になったときに方針が明確になります。

Material DesignやAnt Designなどの汎用ライブラリは、あらゆるサービスでの利用を想定しているため、汎用コンポーネントのみで構成されています。

それぞれみていきましょう。

### 汎用コンポーネント: どのサービスでも使える部品

何にでも利用可能なコンポーネント——それが汎用コンポーネントです。

![汎用コンポーネントの例: どのサービスでも使い回せる部品](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-59.png)

たとえば、ボタンは会員登録にも退会にも使われます。このレイヤーのコンポーネントは、特定のデータ構造に依存しないよう設計します。ユーザー名を表示するボタンではなく、テキストを表示するボタン。

汎用かどうかを判断するわかりやすい基準は、まったく別のサービスでもそのまま使えるかどうかです。自社のサービス名やデータモデルに依存しなくても機能するなら汎用コンポーネント、特定のサービスの文脈がないと意味をなさないならドメインコンポーネントと考えるとわかりやすいでしょう。

このことから、汎用コンポーネントは特定のビジネスロジック（業務固有のルールや判断）を内包しないのが原則です。たとえば、求人サイトで`Button`コンポーネントを汎用的に扱うのであれば、「履歴書不要」という文言をコンポーネントに直接埋め込むのは避けるべきでしょう。これは、コンポーネントの設計の中に「ドメイン知識をもっている」と呼ばれる状態です。

逆に、任意のテキストを渡して変えられるようにすることはOK。ボタンはあくまで「押せる」というインタラクションだけを提供し、押された後に何をするか、何とテキストを表示するかは呼び出し側に委ねます。

正しい設計は、`label` プロパティを通じて外からテキストを渡す形です。`<Button label="履歴書不要で応募する" />` のように使えば、同じButtonコンポーネントが「ログイン」にも「購入する」にも使い回せます。

汎用コンポーネントはどこでも使い回せるため、デザインシステムの基盤として強力であり、プロダクトをまたいで共有もできます。一方で、汎用性を高めようとするあまりプロパティが増えすぎて複雑になりがち。

特定画面や特定ドメインでしか使わない機能は後述のドメインコンポーネントに切り出します。

### ドメインコンポーネント: 特定のデータに特化した部品

特定のデータを表示するための専用コンポーネントです。

![ドメインコンポーネントの例: 特定のデータ構造に特化した部品](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-60.png)

たとえば、ECサービスにおける商品カードを考えてみましょう。

商品名、価格、サムネイル画像、在庫状態といった特定のデータを表示することに特化しています。どんなデータが来るか決まっているからこそ、価格のフォーマットや在庫切れ時の表示といった表示ルールをコンポーネント内部に閉じ込められるのです。

あるいは特定の機能に紐づいたUIがプロダクト内のあちこちで使い回されるなら、ドメインコンポーネント化します。逆に、見た目が似ているだけで入るデータや役割がバラバラなら、汎用の`Card`コンポーネントを組み合わせるほうが適切です。

この汎用とドメインの違いは、後述する変数の章で扱うデータの受け取り方にも深く関わってきます。

汎用コンポーネントはプロパティごとに個々の値をバラバラに受け取り、ドメインコンポーネントはデータ一式をまるごと受け取ることが可能、という設計の違いです。

コンポーネントを汎用かドメインかに位置づけることで、使える範囲や使い方が明確になります。また、デザイン管理するのは汎用コンポーネントまで・ドメインコンポーネントは実装者が任意に作る、というように線引きするのもひとつの考え方です。

もちろん、すべてがきれいに分かれるケースばかりではありません。実務で判断に迷う境界線上のケースを見てみましょう。

### 汎用とドメインの境界: 答えが一意に決まらないケース

チャット機能の吹き出し（バブル）を例に考えてみます。

チャットの吹き出しはドメインか、ボタンのような汎用部品か。

![汎用かドメインか: 視点で答えが変わる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-32.png)

ロジックの複雑さに着目するか、扱うデータの特化度に着目するかで答えが変わります。

ロジックの観点で見れば、テキストを表示するだけであり、またボタンのようにあらゆるサービスで登場しうるという意味では汎用ともいえます。

一方、扱うデータの特化度で見れば、送信者・タイムスタンプ・既読状態といったチャット固有の構造に依存しているので、ドメインともいえます。

特定のオブジェクトにそのまま対応する設計をするのであれば、ドメインコンポーネントとして整理したほうが実務上便利でしょう。

答えが一意に決まらないケースこそ、社内でケーススタディとして議論し、自分たちの判断基準を育てていく価値があります。判断を積み重ねた記録自体が、チームのナレッジになります。

## 早すぎる共通化の罠: 見た目が似ていても目的が違う

プログラミングにはDRY（Don't Repeat Yourself＝重複をなくせ、という開発の格言）という有名な原則があります。しかし近年、エンジニアの間では[AHA（Avoid Hasty Abstractions）](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)＝あわてて共通化するな、という反論も広まっています。

たとえば、2つの画面に見た目がよく似たカードがあったとします。
同じ部品だからとひとつの`Card`コンポーネントにまとめました。ところが後日、片方には「いいねボタン」が追加され、もう片方は「スワイプで消せる」ようになりました。

結果、`hasLikeButton` と `isSwipeable` という互いに無関係なプロパティがひとつのコンポーネントに混在し、全体像を把握しづらい複雑なコンポーネントができあがります。

見た目が似ていることと、目的やドメインが同じことは別の話です。

![早すぎる共通化の罠: プロパティ肥大化](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-20.png)

無理にひとつに統合するよりも、あえて別々のコンポーネントとして持っておくほうが、将来の変更に強くなることがあります。

共通化の判断は、実際に同じパターンが繰り返し現れてからでも遅くありません。

プログラミングの格言に「3回同じパターンが出て初めて共通化せよ（Rule of Three）」があります。2つ似た画面を見てすぐにマスターコンポーネントを作りたくなりますが、3つ目のユースケースが出るまで待つことで、本当に必要なプロパティの形が見えてきます。

この罠は、実在するライブラリの設計判断を見ると鮮明になります。MUIの[`Chip`](https://mui.com/material-ui/react-chip/)と[`Badge`](https://mui.com/material-ui/react-badge/)は、どちらも「小さい情報表示の部品」という概念レベルでは近い存在です。しかし別コンポーネントとして設計されています。`Chip`はクリックや削除ができるインタラクティブな要素、`Badge`は`Avatar`やアイコンの右上に重ねて配置する通知ドット（アプリアイコンの赤丸の数字）です。見た目が明らかに違うこの2つでさえ、「ラベル的なもの」としてひとつにまとめたくなる誘惑が生まれます。

![MUI: Chip（操作できる）と Badge（見るだけ）](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-12.png)

Ant Designでも[`Tag`](https://ant.design/components/tag/)（カテゴリやステータスのラベル）と[`Badge`](https://ant.design/components/badge/)（件数や状態を示すドット）は別コンポーネントです。`Tag`は単体で意味を持つラベル、`Badge`は別の要素に付随する補助情報。振る舞いが違えばコンポーネントも分ける——汎用ライブラリはこの原則に忠実です。

![Ant Design: Tag と Badge](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-13.png)

「触れるかどうか」「何を伝えるか」「どこに配置されるか」——見た目の類似ではなく振る舞いで分けることが、長期的な保守性を高めます。

## ネイティブ要素とカスタムコンポーネント: OSの部品をどこまで活かすか

このセクションはモバイルアプリ中心の話です。

モバイルアプリの構築方法は大きく2つあります。

iOS/Androidそれぞれのネイティブ言語で作る方法と、[React Native](https://reactnative.dev/)や`Flutter`のようなクロスプラットフォームのフレームワークで一度に両方を作る方法です。どちらを選ぶかはエンジニアリングチームの判断要素が多いのですが、デザイナーとして知っておくべきポイントがあります。

いずれのフレームワークにも、ネイティブ要素が存在します。実装で悩みがちなのが、iOSやAndroidのネイティブ要素をどこまで活かすかという問題です。

たとえば、日付選択やセレクトボックス、トースト通知やアクションシート。Figmaではユースケースやブランドを反映した凝ったデザインを作りたくなりますが、これらをゼロからカスタム実装するコストは大きい。加えて、アクセシビリティやOSアップデートへの追従という面でもリスクを負います。

ネイティブUIを採用するメリットは、ユーザーが慣れ親しんだ操作感を提供できるだけでなく、OSのアップデートに自動で追従できることです。Appleが新しいデザイン言語を導入しても、Androidがインタラクションを改善しても、ネイティブUIを使っていればそのメリットを享受できます。

ただし、クロスプラットフォームフレームワーク（FlutterやReact Nativeなど）を使っている場合、事情が異なります。これらのフレームワークはネイティブUIを部分的に独自再現しているため、OSアップデートのメリットをそのまま受けられないことがあります。

いずれの構築方法であっても、デザイナーとして押さえておきたい方針は共通です。

- 基本的には、OS標準のUIをリスペクトする
- 独自性がブランドの核心でない限り、複雑な入力フォームなどはネイティブの挙動に寄せる
- どうしてもカスタムする場合でも、OS標準の挙動をベースにし、必要な部分だけを上書きすることで、挙動の安定性を確保する（Webの場合はHeadless UIの活用も有効）

ネイティブUIの活用方針やフレームワークの選定は、デザインだけでは決めきれない領域です。エンジニアリングチームの技術的な知見と、プロダクトの将来計画をふまえた組織的な判断が必要です。デザインの管理においては、ネイティブUIはデザインシステムのコンポーネントライブラリとは別の枠組みで参照用として用意しておくのが現実的です。

## コンポーネントの命名

命名は、デザインデータ上ではあまり意識しなくてもよいのですが、実装においては名前がすべてといっても過言ではありません。

Figmaでのコンポーネントはなんとなくインスタンスをコピー&ペーストで配置しますが、フロントエンドやモバイルの実装では、コンポーネント名でコンポーネントを呼び出します。名前を変更するということは、すべての呼び出し箇所を修正するということです。

一度決めたらなるべく変えない（ぐらいの気持ちで設計する）。議論になったことはその場でルール化してドキュメントに残しておかなければ、同じ議論や調整が繰り返されることになります。

コンポーネントの設計にはさまざまな命名が発生します。`Frame 1` や `Property 1` のような命名でFigmaデータを作っても、コード側では必ず命名がおこなわれます。であれば、デザイナーが意味や意図をもとに命名に参加することは意義深いはずです。

命名は設計の一部です。最初につけた名前がそのままコードに入り、ドキュメントに引用され、チームの会話に定着します。後から変えるコストは思った以上に高くなりがちです。

加えて、命名規則が整理されていると、[Cursor](https://www.cursor.com/)や[GitHub Copilot](https://github.com/features/copilot)などのAIコード生成ツールが自社の命名体系に沿った補完をします。逆に、命名がバラバラだとAIもバラバラなコードを生成し、不整合が増えます。

いくつかの勘所をご紹介します。

### 業界の語彙から借りる

コンポーネントの名前をゼロから考える必要はありません。[Radix UI](https://www.radix-ui.com/primitives)、[MUI](https://mui.com/)、[Chakra UI](https://chakra-ui.com/)といった広く使われているUIライブラリには、長い議論と実践を経て定着した命名があります。`Dialog`、`Popover`、`Accordion`、`Breadcrumb`——これらはすでに業界の共通語彙です。命名についてチーム内で議論すると意見が割れがちですが、既存の語彙に揃えてしまえば議論そのものを省略できます。悩むより揃えるほうが早いことのほうが多いです。

[Mobbin Glossary](https://mobbin.com/glossary)のように、UIパターンの名前と定義をまとめたリファレンスも役立ちます。自分たちのコンポーネントに名前をつけるとき、まずこうしたリソースに同じ概念がないかを確認する習慣があると、命名のブレを防げます。

この考え方はコンポーネント名に限りません。変数の章で扱うプロパティ名（`variant`、`size`、`disabled`など）も、既存ライブラリの慣習に揃えておくと、エンジニアとの会話がスムーズになり、新メンバーが既存の知識をそのまま持ち込めます。

![ライブラリ間の命名収束: 同じ概念には同じ名前が定着している](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-74.png)

独自の命名が必要になるのは、プロダクト固有のドメインコンポーネント（`JobCard`、`RecipeStep`など）や、既存の語彙ではカバーできない概念に対してです。汎用的な部品には業界の語彙を借り、独自性が必要な部分にだけオリジナルの名前を使う。この使い分けが、外から来た人にも読めるコンポーネントライブラリをつくります。

### 状態やバリエーションを名前に含めない

これは後述する変数の章でも扱う、コンポーネントの状態管理に直結する話です。先にここで概要を押さえておきましょう。

避けたいのは、コンポーネントの名前に状態やバリエーションを含めてしまうことです。たとえば、`RedButton` や `LoadingButton` ではなく、`Button` という名前にして、Figmaのバリアントで `variant` = `danger`、プロパティで `isLoading` = ON のように切り替える設計にします。

なぜかというと、状態やバリエーションを名前に含めると、組み合わせの数だけコンポーネントが増えていくからです。`RedButton` と `LoadingButton` と `SmallButton` が別々に存在していたら、`SmallRedLoadingButton` が必要になった瞬間に命名が破綻します。名前は「何であるか」だけを表し、「いまどんな状態か」はプロパティで表現する。この切り分けが管理のしやすさを決めます。

![命名: 状態を名前に含めると組み合わせが爆発する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-26.png)

バリアント名は役割で選びます。[Nick Babichの分類](https://uxplanet.org/buttons-in-ui-design-four-common-styles-f6bd02468388)では、ボタンを Solid（塗りつぶし）・Ghost（枠線のみ）・Icon-only・FAB（フローティング）の4スタイルに整理しています。`variant`に色名（`Blue`）ではなく、このように表現スタイル（`ghost`）や役割（`primary`）で名付けると、テーマ変更に耐える命名になります。

ただし、利用可能範囲が広いコンポーネントに、1箇所の利用のための改変・拡張がおこなわれるような場合は切り出したほうが管理しやすい場合もあります。

プロパティ名や値の選択肢の命名については、変数の章で詳しく扱います。

見た目が近いコンポーネントをどう名付けるかは、実在するライブラリの判断が参考になります。

Radix UIは`Dialog`（通常のダイアログ）と`AlertDialog`（警告を伴うダイアログ）で「意味の違い」を明示しています。外見はほぼ同じモーダルですが、名前を見るだけで用途の違いが伝わります。

MUIは`Chip`（ユーザーが操作する部品）と`Badge`（見るだけの通知ドット）で「インタラクションの有無」を名前に反映しています。名前がコンポーネントの役割を正確に伝えるからこそ、使う側が迷わずに済みます。

### データモデルとAPI名称: コードの用語と揃える

実装の世界には、バックエンドのデータモデルやAPIで使われている用語体系があります。たとえば、ユーザーの情報は `User`、求人は `Job`、勤怠は `Attendance` といった名前で管理されており、APIのレスポンスにもこれらの名前がそのまま使われています。

ドメインコンポーネントを設計するとき、この用語体系と合わせるかどうかは重要な設計判断です。

ドメインコンポーネントの場合。APIが返す `Shift` というデータを表示するカードなら、`ShiftCard` と名付けるのが自然です。`ShiftCard` というコンポーネント名を見れば、`Shift` のデータを受け取って表示するのだなとすぐにわかります。

Figmaのコンポーネント名、コードのコンポーネント名、APIのデータ名が同じ語彙で通じていれば、会話のたびに頭の中で翻訳する手間がなくなります。

一方、汎用コンポーネントの場合。`Avatar`、`Card`、`Badge` といったUI Kit層の部品は、特定のデータモデルに依存しない名前をつけます。`UserAvatar` ではなく `Avatar`。`ShiftCard` ではなく `Card`。汎用コンポーネントの強みはどのデータにも使えることなので、特定のデータ名をつけた瞬間にその汎用性が失われます。

汎用の`Card`コンポーネントにデータモデルの名前を混ぜてしまうと、別のデータに使いたくなったときに名前が矛盾します。逆に、ドメインコンポーネントに抽象的な名前をつけると、何のデータを表示するのかがぱっと見で分からなくなります。

![データモデルとコンポーネント名: 揃えるか、離すか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-66.png)

合わせるべきところで合わせ、離すべきところで離す。この判断の軸になるのは、そのコンポーネントが特定の情報やデータ構造に依存しているかどうかです。

ドメインコンポーネントの命名でAPIの用語体系と合わせたいとき、いくつかの具体的な方法があります。

- APIレスポンス（JSON）を見せてもらい、データがどんな名前で管理されているか確認する
- SwaggerやGraphQLのスキーマを閲覧し、エンティティ名やフィールド名を把握する
- AIに「うちのコードベースではこのデータは何という変数名で扱われていますか？」と尋ねる

命名で悩む時間を減らし、コードとデザインの語彙を最初から揃えることで、翻訳コストのない設計が可能になります。

## 同じオブジェクトを受け取り、レイアウトだけが異なる

ドメインコンポーネントを設計していると、同じデータを受け取るのにレイアウトだけが異なるバリエーションが生まれます。

たとえば、記事を表示するコンポーネントを考えます。一覧ページでは画像つきの縦型カード、フィード画面では横幅いっぱいのセル、サイドバーではタイトルだけのコンパクトな行。受け取るオブジェクトは同じ Article で、タップすると記事詳細に遷移する点も共通しています。このバリエーションを1つのコンポーネントにまとめるか、別々にするかが問題になります。

![同じオブジェクトを受け取り、レイアウトだけが異なる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-68.png)

唯一の正解はありません。ただし、判断の軸はあります。

- **使う場所が明確に異なるなら分ける。** 一覧ページとサイドバーでは、今は同じプロパティでも、時間が経つにつれてそれぞれに固有の機能が乗っていきます。一覧にはフィルターのハイライトが、サイドバーには閲覧済みマークが追加される——こうした分岐が起きたとき、1つのコンポーネントに押し込むとプロパティが膨らみ、条件分岐だらけになります
- **レイアウトの違いだけで振る舞いが同じなら、まとめてもよい。** `variant: "card" | "cell" | "compact"` のように切り替える設計です。ただし、バリアント間で表示する情報量が大きく異なる場合は、まとめることで逆に複雑になります

実装の視点では、見た目は別コンポーネントにしつつ、データの取得やタップ時の遷移ロジックだけを共通のフック（カスタムHook）として切り出す方法もあります。見た目の分離とロジックの共有を両立できるため、分けるか迷ったらこのアプローチが保守的です。

### レイアウトバリエーションの命名

分けると決めたとき、名前のつけ方がバラつきやすい問題があります。あるコンポーネントは `XXCard` と `XXItem`、別のコンポーネントは `XXLarge` と `XXSmall`——こうした不揃いが蓄積すると、名前から形を推測できなくなります。

レイアウト形状で接尾辞を統一するのが実用的です。縦型のリッチな表示は `Card`、横幅いっぱいのリスト行は `Cell`、コンパクトな最小表示は `Item`。チームで接尾辞の意味を揃えておけば、`ArticleCard` と `ProductCard` は同じような見た目だと推測できます。

もうひとつのアプローチは、配置場所で名前を分ける方法です。`ArticleListCard`、`ArticleSidebarItem`、`ArticleFeedCell` のように、どこで使うかが名前に入ります。場所ごとに機能が分岐していく前提なら、この命名が素直です。

![レイアウトバリエーションの命名: 形状で分けるか、場所で分けるか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-69.png)

どちらを選ぶにせよ、ルールがチーム内で共有されていることが重要です。命名規則がないまま進むと、半年後には `ArticleCard`、`ArticleTile`、`ArticleBlock` が並立し、どれがどのレイアウトなのか誰にもわからなくなります。

---

ここまで、コンポーネントの分割・分類・命名という設計のルールを整理してきました。しかし、ルールは理想の条件下で機能するものであり、現実のプロダクト開発はつねに理想の外側にあります。次の章では、設計したルールが現実の制約や変化にぶつかったとき、どのように対処し、どこまで妥協するかという問いを扱います。

# 現実的な問題への対処: 壊れ方を設計する

## 運用で直面する課題と対処法

ここまではコンポーネントをどう設計するかを扱ってきました。ここからは、設計したコンポーネントを運用する中で直面する現実的な課題と、その対処法を扱います。

原則の章で触れた経路依存性——初期の選択が未来を制約する力学——がある以上、完璧な初期判断には限界があります。それでも、変更コストを下げる手立てはあります。ここでは3つの防御策を扱います。古いものを安全に終わらせるライフサイクル管理、既存の利用者を壊さない変更の作法、そして100%準拠を求めない例外の設計です。

![安全な変更と破壊的変更: 増やすのは簡単、変えるのは大変](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-27.png)

## 安全な変更と破壊的変更: Figmaの修正がコードを壊すとき

コンポーネントのライフサイクルと密接に関わるのが、変更の安全性という概念です。

まず大前提として、増やすのは簡単で、減らすのと変えるのは大変です。棚に本を1冊追加するのは簡単ですが、すでに置いてある本の背ラベルを全部貼り替えるのは大変な作業です。

コンポーネントの変更もまったく同じ構造をしています。デザイナーがFigma上で気軽におこなう修正が、コード側では既存の実装を壊す破壊的変更（Breaking Change）になり得ます。

この感覚をデザイナーが持っているかどうかで、エンジニアとの連携のスムーズさが大きく変わります。

### 追加は安全、変更と削除は危険

安全な変更とは、既存の実装に影響を与えない変更のことです。新しいバリアントの追加、新しい任意プロパティの追加がこれにあたります。たとえば、ボタンに `variant` = `warning` を新しく追加しても、いま使われている `primary` や `secondary` のボタンは何も変わりません。

一方、破壊的変更とは、既存のコードがエラーを起こしたり、意図しない見た目になったりする変更です。具体的には、プロパティ名の変更、Enumの選択肢の削除や名称変更、新しい必須プロパティの追加などが該当します。Figma上で typo を直したいだけだからとプロパティ名を変えると、コード側ではそのプロパティを参照しているすべての箇所でエラーが起きます。

この区別を知っていると、「プロパティ名を変えたいけど今はやめておいて、次のメジャーアップデート（V2）で新旧並行稼働させながら移行しよう」といった判断ができるようになります。
エンジニアがよく口にする「後方互換性」とは、まさにこの話です。冒頭の原則で述べた慣習（Convention）と直結しています。既存を壊さない変更ができる設計は、新メンバーが安心して機能を追加できる土台になります。

Figmaではプロパティを自由に変更でき、インスタンスは自動で追従しますが、コードの世界ではそうはいきません。この非対称性を意識しておくだけで、変更の提案のしかたや移行計画の立て方が変わってきます。

![追加と削除の非対称性: 似たバリアントは増えやすく、減らしにくい](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-70.png)

増やすのは安全、変えるのは大変。ソフトウェア設計にはこれに近い考え方として開放閉鎖の原則（OCP: Open-Closed Principle）があります。拡張には開かれているが、修正には閉じられているべき、という設計指針です。コンポーネント設計でも、新バリアントの追加は歓迎しつつ、既存プロパティの変更は慎重に——という姿勢に通じます。

## 例外を許容する設計: 100%準拠は目指さない

デザインシステムに100%準拠を最初から目指すと、運用の負荷が高くなりすぎることがあります。結果として、システム自体が使われなくなるケースも珍しくありません。

90%の定型と10%の例外を最初から織り込んでおくくらいがちょうどよいでしょう。FigmaとコードのUIが完全一致している必要もありません。インターフェース（プロパティの名前と型）が一致していることのほうが、チームの共通理解にとってはるかに重要です。

未整備な規則は後から一括で差し替えしやすいように作っておくこともできます。

たとえば、色の値をハードコードせずトークンで管理しておけば、後から一括変更できます。コンポーネント化されていない要素をいつコンポーネント化するかの基準も決めておくとよいでしょう。「3回以上同じUIが登場したらコンポーネント化を検討する」のようなシンプルなルールで十分です。

## 既存コンポーネントでは理想のデザインが実現できないとき

デザインシステムを運用していると、ありもののコンポーネントではやりたいデザインができない、という場面によく出くわします。

このとき、FigmaでいきなりDetach（コンポーネントとの紐付けを解除すること）してゼロから作り直すのではなく、段階的に検討できるオプションを整理しておくと、チーム全体の判断がブレにくくなります。

判断の軸が共有されていれば、人によって対応が変わる問題を防げるためです。

### 4つの選択肢

1. 既存コンポーネントの組み合わせで解決できないか？ まず試すべきは、今あるコンポーネントの組み合わせやスロットの活用で目的を達成できないかの検討です。
2. バリアントやプロパティの追加で対応できないか？ 既存コンポーネントに新しいバリアントやプロパティを足すことで、ユースケースをカバーできることがあります。ただし、1つのコンポーネントに機能を詰め込みすぎると複雑になるので、追加が妥当かどうかはチームで判断します
3. 新しいコンポーネントとして切り出すべきか？ 既存とは明確に目的が異なるなら、別のコンポーネントとして新設するのが正解です。その際は命名やレイヤーの配置も含めて設計します
4. 一回限りの例外として許容するか？ 一度きりのキャンペーンページや実験的なUIなら、コンポーネント化せずに個別対応と割り切る選択肢もあります。ただし、同じ例外がN回発生したらコンポーネント化を検討する、というルールをセットにしておきます

このフローをチーム内で共有しておくだけで、サイレントなDetachが減り、デザインシステムへのフィードバックが仕組みとして回るようになります。

![既存コンポーネントで実現できないとき: 4つの選択肢](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-43.png)

ただし、こうしたグレーゾーンはデザイナー間で連携せずにデザインシステムから外れた実装が増える原因になりがちです。例外への対処はしっかり共有・議論し、論点を資産にしていく姿勢をチーム全体で持ちたいところです。

デザインシステムから外れた実装が発生したとき、それを失敗と見なすかデータと見なすかで、チームの文化は大きく変わります。このコンポーネントだけ使えなかったという声は設計の盲点を示していますし、毎回カスタマイズが必要だったというパターンは新しいバリアントの候補を教えてくれています。逸脱を罰するのではなく、逸脱からシステムを改善するフィードバックループを回すこと。違反を取り締まる「トークン警察」ではなく、正しい選択が自然にできる環境を設計することが、強制よりもはるかに高い準拠率につながります。

生態系になぞらえれば、Detachされたコンポーネントは「突然変異」です。突然変異のすべてが有害なわけではありません。有用な変異はシステムに昇格し、そうでないものは淘汰される。「これを使いなさい」と指示するだけの規範的なシステムより、「これを組み合わせて新しいものも作れる」と可能性を開く生成的なシステムのほうが、こうした進化を受け入れやすくなります。デザインシステムは石碑ではなく生態系です。

![デザインシステムの進化サイクル](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-51.png)

次にコンポーネントを変更するとき、エンジニアに「これは破壊的変更になりますか？」と聞いてみてください。その一言で、移行計画の議論がスムーズに始まります。

## コンポーネントのライフサイクル: 終わらせる設計

デザイナーがコンポーネントの廃止プロセスを知っておくべき理由は、Figma上のマスターコンポーネントを消すとき、それがどこに影響するかを判断できるようになるためです。

コンポーネントは作ることに目が行きがちですが、システム運用で本当に難しいのは捨てることです。終わらせるタイミングは誰も教えてくれません。

プロダクトが成長すれば、コンポーネントは必ず古くなります。そして、実装では、古い方を残したまま新しいものを追加し、徐々に移行することがよくおこなわれます。

新しいボタンを作ったとき、古いボタンをどう扱うか？

ここに方針がないと、使われなくなったコンポーネントがゾンビのように残り続けます。新メンバーがこれ使っていいんですか？と迷うことになります。

### 非推奨の告知と削除

もう使わないでねという意思表示をシステムに組み込んでおく。Figmaなら、コンポーネント名の先頭に [Deprecated]（非推奨：もう使わないでねという印）をつけたり、説明欄に代わりの `NewButton` を明記したり、背景色を目立つ色にする方法があります。コード側でも同様の非推奨マークを付けることで、使おうとしたときに警告が出るしくみがあります。

たとえば、古い `ListItem` と新しい `ListItemV2` が両方存在しているとします。[Deprecated] マークがなければ、新しくチームに入ったデザイナーは2つを見比べて、どちらを使うべきか悩みます。そして多くの場合、慣れている古いほうを選んでしまう。こうして移行が進まなくなります。

[Deprecated]マークなしで新旧コンポーネントを並行運用した結果、1年後に`ListItem`（初代）と`ListItemV2`（改良版）と`NewListItem`（実験版）の3つが共存していたこともあります。新メンバーは最も新しそうな名前を選びますが、実は最新版は`ListItemV2`で、`NewListItem`は実験的に作られて放置されたものでした。

作る責任と同じくらい、終わらせる責任を持つこと。これがデザインシステムを長く健全に保つためのポイントです。

![非推奨化のワークフロー: 告知から削除までの4ステップ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-76.png)

![コンポーネントのライフサイクル](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-22.png)

# 変数(1): コンポーネントの変数を解剖する

Figmaのプロパティパネルは、コードの設計図そのものです。パネルに並ぶトグルやドロップダウン、あの一つひとつに型があることを意識したことはありますか？　この章を読むと、エンジニアに「このプロパティ、BooleanですかEnumですか？」と自分から確認できるようになります。型の会話ができるだけで、認識のズレによる手戻りが激減します。

プロパティの型を選ぶことは、コンポーネントの作り手と使い手の間に交わされる契約を定義することでもあります。Booleanは「2つの状態しかない」という約束であり、Enumは「この中から選んでほしい」という約束です。

## プロパティの型を解剖する

![Figma プロパティパネルとコードの対応関係](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-18.png)

ここからは、コンポーネントが外側から受け取る設定値——プロパティ——を詳しく見ていきます。Figmaのコンポーネントプロパティパネルに並んでいるトグルスイッチ、テキストフィールド、バリアントの切り替え。これらはコード上の変数と対応しています。

> **Notice:** この章で「変数」「プロパティ」と呼んでいるのは、コンポーネントに渡す設定値のことです。FigmaのVariables機能（デザイントークンを管理するしくみ）とは別の概念です。混同しやすいので注意してください。

Figmaのプロパティパネルを整理することは、コードの設計図を書くことでもあります。この設計図はAIコード生成の精度にも直結します。型が明確に定義されていれば、AIに渡したときに自社のルールに沿った精度の高いコードが返ってきやすくなります。

プロパティには型（Type）があります。Figmaのプロパティパネルで、トグルスイッチなのか、テキスト入力なのか、バリアントの切り替えなのか——その入力方式の違いが、コードでは型として定義されています。Notionのデータベースを思い浮かべてください。カラムを作るとき、テキスト・数値・チェックボックス・セレクト・日付……と種別を選びます。
あのカラムの種別が、ここでいう型にあたります。

Figmaのプロパティパネルでも同じことが起きています。トグルスイッチはBoolean、バリアント切り替えはEnum、テキスト入力はStringです。Figmaのプロパティパネルではテキスト入力欄に何でも自由に入れられますが、コードの世界では数値の 24 とテキストの "24" は別物です。このプロパティに入る値はテキストなのか、数字なのか、ON/OFFなのかを意識して設計すると、コードとの対応関係が明確になります。

ここでは、Boolean、Enum、String、Number、Dateといった基本の型に加え、配列やオブジェクトといったデータの構造についても解説します。聞き慣れない用語もありますが、ひとつずつFigmaの操作に対応づけていきます。

![プロパティの型: Figma での見え方とコードの対応](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-17.png)

以下の表は全体像です。まずはざっと眺めてみましょう。

| 型      | コードでの書き方（参考）                        | Figmaでの表現             |
| ------- | ----------------------------------------------- | ------------------------- |
| Boolean | `isDisabled: boolean`（ON/OFFの値）             | トグルスイッチ            |
| Enum    | `size: 'S' \| 'M' \| 'L'`（3つの中から1つ選ぶ） | バリアント（Variant）     |
| String  | `label: string`（自由なテキスト）               | テキスト入力              |
| Number  | `count: number`（数値）                         | テキスト入力              |
| Date    | `deadline: Date`（日付）                        | テキスト入力              |
| Array   | `items: Item[]`（データの一覧）                 | `Auto Layout`内の繰り返し |
| Object  | `user: User`（データのまとまり）                | 複数プロパティの集合      |
| Element | `icon: ReactNode`（別の部品を差し込む）         | `Instance Swap`           |

### 汎用ライブラリの変数設計をみてみる

Chakra UIやMUIなどの汎用ライブラリを見漁ったことのある方は、変数の設計が似通っていることに気づいているかもしれません。

実際に並べてみると、どのライブラリも Button・Input・Select・Tag・Switch・Checkbox といった基本部品を揃えており、それぞれが `size`・`variant`・`colorScheme`・`disabled` といった類似のプロパティを持っています。名前やAPIの細部は違っても、設計の骨格は共通しています。

![汎用ライブラリのコンポーネント例: MUI / Chakra UI / Ant Design](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-56.png)

これは偶然ではなく、UIの問題構造が同じだからです。ボタンには見た目のバリエーションとサイズが必要で、入力フィールドにはプレースホルダーと無効状態が必要——こうした要件は言語やフレームワークを問わず共通します。だからこそ、ここから先で扱う変数の型や設計パターンは、特定のライブラリに依存しない普遍的な知識として使えます。

### Boolean: 真偽値

スイッチのON/OFF、はい/いいえの2択です。コードでは`true`/`false`という値が入ります。

Figmaではプロパティパネルにあるトグルスイッチで指定するプロパティです。アイコンを表示するかどうか、読み込み中かどうか、といった存在や状態のオンオフを管理します。

たとえば、`isRequired`（必須かどうか）、`isDisabled`（操作できない状態かどうか）、`showIcon`（アイコンを表示するかどうか）。名前の通り、はい/いいえで答えられる性質をそのままプロパティにしたものです。

#### Boolean の命名

Booleanのプロパティ名には2つのルールがあります。

ひとつは否定形を避けること。`isNotDisabled` ではなく `isDisabled`。Figmaでいえば、トグルスイッチの名前を「無効ではない」にするか「無効」にするかの違いです。二重否定は読み手を混乱させるだけです。

もうひとつは動詞で始めること。`is` は状態（`isDisabled`）、`has` はあるかないか（`hasBorder`）、`show` は表示するかどうか（`showIcon`）。プロパティ名を読むだけで、何のON/OFFかがわかります。

#### Boolean が増えすぎたら Enum へ

Booleanはシンプルで使いやすい反面、増えすぎると矛盾が生まれます。トグルが3つあればON/OFFの組み合わせは8通り。そのほとんどは、ありえない状態を含んでいます。

たとえば、ボタンのサイズを `isSmall` と `isLarge` という2つのBooleanで管理したとします。どちらもOFFなら通常サイズ。では両方ONになったら？ 小さくて大きいボタンは存在しません。こうした矛盾が生まれる時点で、サイズは最初からEnum（`Small` / `Medium` / `Large` の選択式）にすべきだったということです。

同じことは表示位置にも当てはまります。Figmaのプロパティパネルに「左アイコン表示」「右アイコン表示」の2つのトグルが並んでいて両方ONにできてしまう状態を想像してください。`hasLeftIcon` と `hasRightIcon` を別々に持つとこの矛盾が生じます。これを1つのドロップダウン `iconPosition: 'left' / 'right' / 'none'` にまとめれば、常にひとつだけが選ばれます。これがBooleanからEnumへの移行です。

![Boolean の矛盾: 2つのトグルより1つの Enum](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-42.png)

![Boolean×2 の矛盾 vs Enum×1 のシンプルさ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-75.png)

Booleanを追加するときの確認ポイントです。

- そのON/OFFは本当に2択か？ 将来3択以上に増える可能性はないか
- 他のBooleanと組み合わせたとき、ありえない状態が生まれないか
- Figmaのバリアント（Enum）で表現したほうがシンプルにならないか
- ひとつのコンポーネントにBooleanが3つ以上並んでいないか

もうひとつ知っておきたいのは、Booleanには「まだ決まっていない」がないということです。Figmaのトグルスイッチと同じで、ONかOFFか、必ずどちらかの状態にあります。だからこそ、コンポーネントを新しく作ったとき、そのトグルの初期状態をONにするかOFFにするかをあらかじめ決めておく必要があります。

### Enum: 列挙型

あらかじめ用意された選択肢の中からひとつだけ選ぶ形式です。Notionデータベースのセレクトカラムと同じ考え方です。

FigmaのVariant（バリアント）がこれにあたります。たとえば、`size` なら `small` / `medium` / `large` のどれか、`variant` なら `primary` / `secondary` のどれか、というように選択肢をあらかじめ定義しておきます。Figmaのバリアントでサイズ = `S` / `M` / `L`を選ぶ操作を思い浮かべてください。プロパティパネルのドロップダウンから選ぶあの操作そのものが、Enumの概念です。

Enumの価値は、あえて制約することにあります。

String型は何でも入力できますが、自由すぎるとチームのなかでバラつきが生まれます。Enumにして選択肢を絞ることで、迷う場面が減り本質に集中できるようになる。選択肢の体系そのものが、コンポーネントの使い方を暗に伝えてくれます。

制約は、急いでいるときにこそ効きます。デッドライン直前、人は最も簡単な道を選びがちです。選択肢が自由すぎると「とりあえず」の判断が積み重なり、一貫性が崩れていく。あらかじめEnumで選択肢を整えておくことは、正しい選択を最も簡単にする環境設計です。

たとえば、余白をNumber型の自由入力にすると、14px、16px、18px…と微妙に違う値が画面ごとに増えていきます。これをSpacing Tokenにして `Small` / `Medium` / `Large` しか選べなくすれば、誰が組んでもリズムが整います。トークン化前は画面ごとに5種類以上の余白値が混在していたのが、トークン化後は3種類だけ——余白に関する議論が大幅に減るのは、デザインシステム導入のわかりやすい成功指標です。

#### 選択肢の命名: 意味で名付ける

Enumの選択肢は、見た目ではなく意味で名付けます。よくあるのがこのようなものです。
みてのとおり、MECEであったり、粒度感がそろっていたりすることがわかります。
誰でも心当たりがあるかもしれませんが、選択肢の命名は重要である割にデザイナーが手癖でつけてしまいがちです。今は問題なくても、次の人が困る命名は克服しましょう。

| プロパティ  | 選択肢の例                            |
| ----------- | ------------------------------------- |
| size        | small / medium / large                |
| variant     | primary / secondary / outline / ghost |
| status      | success / warning / error / info      |
| colorScheme | blue / green / red / gray             |
| placement   | top / right / bottom / left           |
| intensity   | solid / subtle / outline              |
| orientation | horizontal / vertical                 |
| shape       | circle / square / rounded             |

それでは、個別の性質をもつ選択肢設計の論点をみていきます。

#### Tシャツサイズ: 拡張可能なスケール

`size` の選択肢として広く使われているのがTシャツサイズです。`small` / `medium` / `large` という呼び方で、省略形なら `s` / `m` / `l`。基準となるサイズを `medium` に置き、そこから上下に展開していきます。

拡張が必要になったとき、上方向は `x-large` → `2x-large`（`xl` → `2xl`）、下方向は `x-small` → `2x-small`（`xs` → `2xs`）と伸ばせます。最初から全段階を用意する必要はありませんが、この拡張パスを頭に入れておくだけで、命名の破綻を防げます。

もうひとつ意識しておきたいのが、最も代表的な値をスケールの中に正しく位置づけることです。いま選択肢がひとつしかなくても、その値がスケールのどこにあるかを考えておく。よくある失敗は、なんとなく最初に作ったサイズを `size = default` と名付けてしまうパターンです。1年後には `default` / `small` / `smaller` / `tiny` の4段階に膨れ上がり、`default`が`large`なのか`medium`なのか答えられない——こうした事態は珍しくありません。

最初に作るものがひとつであっても、スケールの中での位置を決めて`medium`や`large`というように体系を前提として名付けます。`Default`はスケール上の位置を表さない名前です。だからこそ、最も代表的な値には`medium`という明確な位置づけを与えておきましょう。

#### 色のセマンティクス: 見た目ではなく役割で名付ける

色についても同じことが言えます。`variant` = `Blue` としてしまうと、ブランドカラーが変わったときやダークモードに対応したときに名前と実際の色が矛盾します。

![色のセマンティクス: 見た目ではなく役割で名付ける](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-61.png)

色は意味で名付けると堅牢です。`variant` = `Primary` や `variant` = `Danger` のように、その色が果たす役割で呼ぶことで、中身の色が変わっても名前が壊れません。

なぜ見た目の色名が問題になるのか。プロダクトのライフサイクルの中で、色は思った以上に変わります。ブランドカラーの刷新、ダークモードの追加、アクセシビリティ改善によるコントラスト調整——いずれも色の値が変わる契機です。`variant: red` と名付けていたものが紫に変わったとき、名前と現実が矛盾し、コードとデザインの対応関係が壊れます。`variant: danger` であれば、色が何色になろうと意味は通ります。

この考え方はデザイントークンの設計にも直結します。トークンの章で扱ったように、`Tag`・`Badge`・`Callout` が同じセマンティックカラーを参照していれば、トークンの値をひとつ変えるだけですべてのコンポーネントに反映されます。逆にリテラルな色名で管理していると、コンポーネントごとに値を追いかける必要が生じます。

ボタンもバッジもタグも、同じセマンティックカラー体系に基づいて名付けることで、コンポーネント間の一貫性が保たれます。

#### 設計の確認ポイント

- 選択肢の名前は見た目ではなく意味で付けているか（`Red` ではなく `Danger`）
- 将来の拡張を見越した命名になっているか（新しい選択肢を追加しても既存の名前が不自然にならないか）
- 選択肢の数は適切か（7つ以上あるなら設計を見直すサイン。選択肢が多すぎると使う側が迷い、管理も煩雑になります）
- 同じ意味の選択肢が別の名前で重複していないか

#### 実践例: Tag と Badge

Enumの力が特に発揮されるのが、`Tag`、`Badge`、`Callout` のように色とサイズの組み合わせをまとめて管理するコンポーネントです。

実際のライブラリでも、Enumの設計が見た目の似たコンポーネントを整理する武器になっています。Figmaでいえば、`Badge`と`Tag`の両方に`size`（`S` / `M`）と`colorScheme`（`info` / `success` / `warning` / `error`）というバリアント軸を揃えておき、`Tag`にだけ「×ボタン表示」のトグルを追加する設計です。

[Chakra UI](https://chakra-ui.com/)はまさにこの構造で、[`Badge`](https://chakra-ui.com/docs/components/badge)と[`Tag`](https://chakra-ui.com/docs/components/tag)が同じ色の体系（`colorScheme`）と表現の種類（`variant`）——塗りつぶし（`solid`）、薄い背景色（`subtle`）、枠線のみ（`outline`）——を共有しつつ、`Tag`にだけ閉じるボタンの有無を切り替えるBooleanが加わっています。

色と強度の軸は共通の設計言語で揃え、機能の違いだけをBooleanで表現する。このパターンは自社のコンポーネント設計でもそのまま応用できます。

![Chakra UI: Badge と Tag の colorScheme バリエーション](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-16.png)

たとえば、`Tag`コンポーネントを考えてみてください。情報の種類を表す色（`info`: 青、`success`: 緑、`warning`: 黄、`error`: 赤）と、表示サイズ（`small` / `medium`）の掛け算になります。

これを色とサイズの2つのEnumで管理すれば、Figmaのバリアントは2軸のマトリクスになり、構造が明快です。

### String: 文字列

ボタンのラベルや入力欄のプレースホルダーなど、画面に表示されるテキストデータです。

ここでデザイナーが考えるべきはデータの不在です。もし文字列が空だったら、その領域は詰めるのか、あるいはプレースホルダーを出すのか。ユーザー名が極端に長かった場合、… で省略するのか、折り返すのか。これらはすべてプロパティの仕様として定義しておきたいところです。

![String型: テキストの振る舞い6パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-33.png)

文字列型のプロパティを追加するときに確認しておきたいことがあります。

- 空のとき何が起きるか決めたか（領域を詰める？ プレースホルダーを出す？）
- 最大文字数を超えたときの処理を決めたか（省略記号、折り返し、スクロール）
- 改行を含む可能性はあるか（1行テキストか複数行テキストか）
- 本当に自由入力が必要か（選択肢が決まっているならEnumにできないか）

日本語だけでデザインしていると見落としがちですが、同じ意味のテキストでも英語になると幅が1.5〜2倍に膨らむことがあります。たとえば、日本語で「確認」と表示していたボタンが、英語では「Confirm」になります。横幅が固定されたボタンでは、テキストが溢れるか省略されて読めなくなります。

多言語対応の予定がなくても、テキストの長さが変動する前提でコンポーネントを組んでおくことは、堅牢な設計につながります。

たとえば、アイコンとテキストが横に並ぶボタンで、テキストが長くなったときにどうするか。アイコンを非表示にしてテキストを優先するのか、テキストを省略記号で切るのか、折り返して高さを広げるのか。これはコンポーネントの仕様として事前に決めておきたい判断です。

もうひとつ気をつけたいのが、テキストの縦方向の振る舞いです。Figmaのテキストボックスは `Auto Height` に設定すれば中身に合わせて高さが変わりますが、コードでも同じ挙動になるかはフレームワークや実装方法によって異なります。行の高さ（Line Height）がコンポーネント全体の縦幅にどう影響するかは、デザインとコードで差が出やすいポイントです。

### Number: 数値

バッジのカウント数（通知が3件あるときの「3」）や評価スコア（星4.5）など、数値を示すデータです。

![Number型: 数値の表示ルール](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-45.png)

文字列と数値の違いは、スプレッドシートを思い浮かべるとわかりやすいでしょう。

セルに数字を入れると右寄せになり、テキストを入れると左寄せになります。あの挙動が示すとおり、数字と文字列は根本的に異なるデータ型です。数値は合計や比較、フォーマット変換などの計算ができるのに対し、文字列はあくまで文字の並びにすぎません。

999+ のように上限を超えた場合の表示ルールや、0のときに非表示にするかどうかといった仕様も、数値型のプロパティに付随する重要な設計判断です。

数値型のプロパティを扱うときに確認しておきたいことです。

- 上限・下限を超えたときの表示を決めたか（999+、0件のときなど）
- 0のとき非表示にするか、0と表示するか
- マイナスの値はありえるか（ポイント残高、差分表示など）
- 単位の表示はコンポーネントの責任か、外から渡すか（円、件、%）

### Date: 日付と時刻

カレンダーの予定日、メッセージのタイムスタンプ、クーポンの有効期限。日付や時刻を扱うデータです。
これはFigmaでは表現することができないため、Stringのプロパティで扱うことになるでしょう。

私たちが画面上で見ている 2月17日 や 3日前 といった表示は、裏側では 2026-02-17T14:00:00Z のような機械が読む形式のデータを変換したものです。スプレッドシートでも、セルに日付を入れるとカレンダー形式で表示されますが、中身は表示を変えても意味が維持される日付データですよね。それと同じで、日付データには裏側のデータと画面に出す見た目という二層構造があります。

![Date型: 日付の表示形式と設計判断](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-46.png)

日付型のプロパティを設計するときの確認ポイントです。

- 日付のフォーマットはコンポーネント内部で決めるか、外部で決めてテキストとして渡されるか
- タイムゾーンの考慮は必要か（海外ユーザーがいるサービスでは要注意）
- 相対表示（3日前）と絶対表示（2月17日）のどちらを使うか、切り替えるか
- 未来の日付と過去の日付で表示を変える必要はあるか（締め切りのカウントダウン、イベント開始までの残り時間など）

ここまでの5つの型（Boolean / Enum / String / Number / Date）で、コンポーネント設計に必要な基礎は揃いました。以降のArray・Object・Elementは、複雑なデータを扱うときに必要になる発展的な型です。今すぐ必要でなければ次の章に進んでも構いません。読み進める方のために、ここからはデータの構造（まとまり方）に関する型を見ていきます。

ひとつ実践的なコツを補足します。たとえば、更新日: 2026/01/01 と表示するUIがあるとき、Figma上のプロパティは 2026/01/01 のテキストだけにし、更新日というラベルはコンポーネント内に固定しておくと、実装との対応が明確になります。

### Array: 配列（リスト）

同じ種類のデータが複数あるとき、コンポーネントにはそのリストをまるごとプロパティとして渡します。タグの一覧、通知リスト、メニューの項目——こうしたケースです。

Figmaでいえば、同じコンポーネントを`Auto Layout`内に繰り返し配置する操作にあたります。コードではこれを配列として扱います。

![配列: 同じテンプレートに異なるデータを流し込む](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-62.png)

同じ器に異なるデータを流し込む——これが配列型のUIの特徴です。各要素のテキストの内容、`Tag`の有無、ステータスの色はそれぞれ異なりますが、コンポーネント自体は同じものが使い回されます。

![Array型: リストの4つの状態](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-34.png)

ただし、Figmaでは3件分のデータを置くと3件で固定されますが、実際のアプリでは0件になったり100件になったりします。デザイナーが意識しておきたいのは、0件・1件・大量にあるときのそれぞれの見え方です。

- 0件のとき何を表示するか（空状態のデザインは用意したか）
- 上限はあるか（無限に増えるのか、最大表示件数を設けるか）
- 大量にあるとき、無限スクロールかページネーションか
- 並び順は固定か、ユーザーが変えられるか

### Object: オブジェクト（データのまとまり）

名前・アイコン・ステータスのような、複数の情報がひとかたまりになっているケースです。

Notionでいえば、データベースの1行がこれにあたります。ユーザーという1行に、名前・アイコン画像・ステータスがセットで入っているイメージです。

![オブジェクト: 複数の値をひとかたまりで渡す](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-63.png)

たとえば、ユーザーカードに渡すユーザーというデータを考えてみてください。名前、アイコン画像、ステータス。これらをバラバラのプロパティとして渡すこともできますが、ドメインコンポーネントではユーザーの情報一式としてまとめて渡すほうが自然です。

Figmaのプロパティパネルでは、こうしたデータのまとまりを直接表現する方法がありません。名前・アイコン・ステータスをバラバラのプロパティとして並べるしかないのです。しかし、コード側ではユーザーというひとつのまとまり（オブジェクト）として渡せます。

デザイナーが意識しておきたいのは、このコンポーネントに渡すデータは、個別の値なのか、まとまりなのか、という点です。`Avatar`なら画像URLだけで十分（個別の値）。`UserCard`ならユーザーの情報一式が前提（まとまり）。この判断が、コンポーネントを汎用にするかドメイン専用にするかの分かれ道です。

Figmaのプロパティパネルで見比べてみると、この違いがはっきりします。`Avatar`のパネルには`image`、`altText`の2項目だけ。一方`UserCard`には`userName`、`userImage`、`rating`、`status`、`isVerified`とずらりと並びます。

プロパティが20個並んだコンポーネントは、使う側にとって何をどう設定すればいいかわからないものになります。逆に粒度が粗すぎると汎用性がなくなります。いま手元のFigmaで、プロパティが10個を超えているコンポーネントを探してみてください。それはドメイン専用として認識すべきサインかもしれません。

オブジェクトの中で特に気をつけたいのは、データの一部が欠けているケースです。ユーザー名はあるけどアイコン画像がない、評価スコアがまだ付いていない。こうした歯抜けのデータにどう対応するかを、コンポーネントの仕様として決めておく必要があります。

また、オブジェクトをまるごと受け取る設計は、そのコンポーネントが特定のドメインに紐づいていることを意味します。コンポーネント分割の章で触れたように、汎用コンポーネントは個々の値をバラバラに受け取り、ドメインコンポーネントはデータ一式をまとめて受け取るのが基本です。

Objectを受け取るコンポーネントを作ろうとしているなら、それはドメインコンポーネントとして位置づけるのが自然でしょう。

![Object型: 個別の値 vs データのまとまり](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-47.png)

### Element: 要素

ここまでの型（Boolean、Enum、String、Numberなど）はすべて、テキストや数値といったデータを渡すものでした。しかし、プロパティに渡したいのがデータではなく、別のコンポーネントそのものというケースがあります。

![Button のスロット構造: 差し込み口を設けることでバリアント爆発を防ぐ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-04.png)

Figmaで考えるとわかりやすいです。`Instance Swap Property`を使って、ある箇所にアイコンを差し込んだり、`Avatar`に差し替えたりします。

コードの世界ではこの仕組みをスロット（slot）と呼びます。Reactでは`ReactNode`あるいは`JSX.Element`型、SwiftUIでは`@ViewBuilder`、Flutterでは`Widget`型としてそれぞれ表現されます。ここでは便宜上Element型と総称します。好きなものを差し込める口を設けておく設計です。

たとえば、カードの説明文を表示する箇所を考えてみてください。通常はテキストを渡せば十分です。しかし、テキストの一部をリンクにしたい場合はどうでしょうか。String型ではここからここまでがリンクという情報を表現できません。リンクを含んだUIのかたまりをまるごと渡す必要があります。

あるいは、リストアイテムの左側に置くものが、ある画面ではアイコン、別の画面では`Avatar`。こうした場合にスロット（Element型のプロパティ）があれば、何を差し込むかは利用者に委ねられます。

スロットの威力がもっともわかりやすいのは、バリアントの爆発を防げる点です。

![バリアント爆発 vs スロット: 4つ作るか、1つで済ませるか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-71.png)

アイコン付きボタンの例で考えてみましょう。デザイナーは `LeftIcon` / `RightIcon` / `BothIcons` / `NoIcon` という4つのバリアントを作りがちです。しかし、スロットの発想を使えば、ボタンの左右に好きなものが入るエリアを用意するだけで済みます。アイコンでも、バッジでも、何も入れなくてもよい。

Figmaでは、`Instance Swap Property`を使ってスロットを表現します。設計のポイントは2つです。

- 何も入れないを選択肢に含める。空のプレースホルダーコンポーネントを候補に入れておけば、アイコン不要な場面でも対応できる
- 差し込める対象を制約する。`Instance Swap Property`で差し替え候補を同じカテゴリに限定し、意図しない使い方を防ぐ

設計時に考えておきたいのは、その箇所にテキストを渡すだけで本当に十分か、それとも将来的にUIのかたまりを渡す必要が出てこないか、という点です。最初はStringで足りていても、後からリンクやアイコン付きテキストが必要になるケースは少なくありません。

![Element型（スロット）: 差し込み口で中身を自由に](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-48.png)

コンポーネントを柔軟にする方法は2つあります。プロパティ（設定値）をどんどん増やす方法と、スロットのように小さな部品を差し替える方法です。前者をConfiguration（設定型）、後者をComposition（組み合わせ型）と呼びます。プロパティが10個、20個と膨らんできたら、それはスロット（Composition）への切り替えどきです。

![Configuration vs Composition: 設定の山か、組み合わせか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-50.png)

ここまで個々の型を見てきました。次の章では、これらの型が複数組み合わさったときにどう振る舞うか——プロパティの設計と運用に踏み込みます。

# 変数(2): プロパティの組み合わせと運用

個々の型を知ったうえで、次に問われるのは「型をどう組み合わせ、どう運用するか」です。プロパティ同士の直交性、トークンによる一貫性の担保、Figmaとコードのギャップへの対処を扱います。

## プロパティの直交性: 組み合わせが壊れない設計

実際のコンポーネントではプロパティが複数組み合わさって使われます。このとき大事になるのが、プロパティ同士が互いに干渉しないという性質です。これを直交性と呼びます。

あるプロパティの値を変えたとき、他のプロパティの意味や振る舞いまで変わってしまうなら、そのプロパティ同士は独立していません。Figmaでバリアントを設計するとき、この感覚があると組み合わせの破綻を未然に防げます。

### 直交している状態

`Button`に`size`（`S`・`M`・`L`）と`variant`（`primary`・`secondary`・`destructive`）の2つのプロパティがあるとします。`size`を`S`から`L`に変えても`variant`の見た目は変わらない。`variant`を`destructive`に変えても`size`は影響を受けない。3×3＝9通りすべてが成立します。これが直交している状態です。

![直交性: size と variant の組み合わせがすべて成立する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-05.png)

もし「`destructive`のときは`S`が使えない」「`secondary`の`L`だけ角丸が変わる」といった暗黙の制約があったら、組み合わせるたびにルール確認が必要になります。

もう一つの例を見ます。タグの部品に`colorScheme`（情報・成功・警告・エラー）と`variant`（塗りつぶし・薄い背景・背景なし）の2つのプロパティがあるとします。`colorScheme`は意味を表し、`variant`は濃度を表します。種類を変えても濃度の振る舞いは変わらないし、濃度を変えても種類の意味は変わりません。この2つは独立しています。

![直交性: colorScheme と variant の組み合わせマトリクス](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-28.png)

### 1つの組み合わせに2つの意味を持たせると何が起きるか

直交性が壊れるのは、1つのプロパティが複数の関心事をまとめて引き受けてしまうときです。

たとえば、ボタンの見た目を`style`というプロパティひとつで管理しているケースを考えます。選択肢は `primary`・`secondary`・`danger`・`ghost`。最初の3つは色の種類（意味）を表していますが、`ghost`だけは「背景なし」という色の強さを表しています。1つのプロパティに「色の種類」と「色の強さ」という2つの関心が混在しています。

この設計では、`ghost`のエラー色はどうなるのかという問いに答えられません。`style: ghost`は背景がないのだから、`danger`の赤い背景は出せない。「`ghost`のときはエラー表示に対応していません」という例外が生まれ、その例外はドキュメントに書かれ、やがて忘れられます。

`variant`（`solid` / `subtle` / `ghost`）と`colorScheme`（`primary` / `secondary` / `danger`）を分ければ、`colorScheme: danger` × `variant: ghost`の組み合わせは自然に成立します。赤いテキストだけのボタンが、マトリクスの1セルとして生まれる。例外のないシステムは、ドキュメントなしでも正しく使えます。

![直交性の崩れ: 1つのプロパティに混ぜる vs 分離する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-67.png)

### 設計時のチェックポイント

プロパティを設計するとき、次の3つを確認します。

- このプロパティの値を変えたとき、他のプロパティの意味や動きまで変わらないか
- 2つのプロパティの組み合わせに暗黙の優先順位が生まれていないか
- ひとつの値が複数の関心事（色の種類と色の強さ、サイズと形状など）をまとめて扱っていないか

直交性が保たれていると、プロパティを追加するたびに既存の組み合わせを紐解く必要がありません。逆に、プロパティ間に暗黙の依存があると、機能を足すたびに優先順位の整理が必要になり、そのルールは時間とともにチーム内で忘れられていきます。

Figmaの[Propstar](https://www.figma.com/community/plugin/1116018586739867857/propstar)というプラグインを使うと、コンポーネントのすべてのプロパティ組み合わせを一覧表示できます。直交性が保たれているかの確認や、プロパティのヌケモレの発見に便利です。

## トークンの共有: 複数コンポーネントの一貫性を保つ

ここまでは個々のコンポーネントのプロパティ設計を見てきました。もう一歩引いて、複数のコンポーネントにまたがる設計について触れておきます。

色やサイジングの体系は、複数のコンポーネントで使い回せるように設計しておくと便利です。こうした共通の値に名前をつけて一元管理する仕組みをトークンと呼びます。Figmaでいえばスタイルやバリアブルに近い概念です。

![トークンの共有: 複数コンポーネントの一貫性を保つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-06.png)

Figmaでは、`Tag`の色を変えたければ`Tag`のスタイルを編集し、`Callout`の色も変えたければ`Callout`のスタイルも別途編集する——というコンポーネントごとの作業になりがちです。

しかしコードの世界では、共通のトークンを参照する仕組みがあれば、トークンの値をひとつ変えるだけですべてのコンポーネントに反映されます。

たとえば、`Tag`の info と `Callout` の info が同じセマンティックカラーを参照していれば、色を変えたいときに一箇所の修正で両方に反映されます。バラバラに定義していると、デザイナーが個別に色を選ぶたびに微妙なズレが蓄積し、`Tag`は青いのに`Callout`は水色、という不一致がいつの間にか生まれます。

色だけの話ではありません。兄弟関係にあるコンポーネント（`Button` / `IconButton` / `CopyButton`など）では、縦幅やアイコンのサイズも共通のトークンを参照しておくと一貫性を保ちやすくなります。

こうしたトークンを一元管理しておけば、`Tag`の配色を微調整したいときに、共通構造を持つすべてのコンポーネントに変更が波及します。トークンを使わず個別のコンポーネントに値を直接書き込んでいたら、ひとつずつ直すことになります。

![トークン変更の波及: 1箇所の変更が全コンポーネントに届く](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-78.png)

Figma上でデザイントークンを管理するプラグインとしては、[Tokens Studio](https://tokens.studio/)が広く使われています。JSONベースでトークンを定義でき、コードとの同期にも対応しています。

## Figmaだけでは伝わらない変数の性質: コードとの差分を知る

ここまで紹介した型はFigmaのプロパティパネルでもある程度表現できます。しかし、コードの変数にはFigmaだけでは伝えきれない性質がいくつかあります。知っておくだけで、エンジニアとの会話がぐっとスムーズになるポイントです。

### 必須と任意: デフォルト値で使いやすさが決まる

なぜこの区別が重要なのか。コンポーネントのプロパティが10個あるとき、そのすべてが毎回指定必須だとしたら、使うたびに10項目を埋める手間がかかります。

逆に、ほとんどが任意でデフォルト値を持っていれば、使う側は変えたいところだけを指定すればよい。必須と任意の設計は、コンポーネントの使いやすさを直接的に決めます。

![必須と任意: デフォルト値で使いやすさが決まる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-36.png)

必須を最小限にとどめ、よく使われる値をデフォルトに設定しておくことで、8割のユースケースは何も指定しなくてもそのまま使える状態を目指します。

コードでは、変数が必ず渡さなければならないか、省略してもよいかが明確に定義されます。省略できる変数には通常、デフォルト値が設定されています。

たとえば、ボタンコンポーネントの `size` が任意で、デフォルト値が `Medium` であれば、利用者が `size` を指定しなくても中サイズのボタンが表示されます。一方、`label` が必須であれば、テキストなしでボタンを使うことはできません。

Figmaのプロパティパネルには、必須かどうかや省略時のデフォルトを表現する仕組みがありません。すべてのプロパティに常に何らかの値が入った状態で表示されます。

そのため、何がデフォルトで何が意図的な指定なのかが区別できないのです。

これを補うには、Description欄に「デフォルト: Medium」のように明記しておくのがもっともシンプルです。また、何も指定しなかったときの見た目を最初のバリアントとして配置しておくと、利用者がこれがデフォルトかと直感的に理解できます。

ただし、デフォルト値は一度決めたら簡単には変えられません。コードの世界では、デフォルト値を変更すると、明示的に値を指定していなかったすべての箇所で表示が変わります。

`size`のデフォルトを`Medium`から`Small`に変えれば、何も指定していないボタンがすべて小さくなる。影響範囲が広いぶん、デフォルト値の決定はかなり慎重におこなう必要があります。

### 条件付き表示: Figmaとコードでプロパティの数がズレる理由

Figmaでコンポーネントを作るとき、ある要素を表示/非表示にするためにトグルを追加した経験はないでしょうか。エンジニアに「このトグル、コード側では要らないんですよ」と言われて戸惑ったことがあるかもしれません。Figmaの制約とコードの表現力の違いが現れる場面です。

たとえば、カードにサブタイトルを出すかどうかを切り替えたいケースを考えてみます。実はコード側では、この挙動をもっとシンプルに実現できます。

コード側ではサブタイトルのテキストというプロパティが1つあれば十分です。テキストが渡されれば表示し、渡されなければ領域ごと消える。1つのプロパティで中身と表示/非表示を同時に制御できます。

しかしFigmaでは、この挙動を再現するためにサブタイトルを表示するかどうかのトグルとサブタイトルのテキストという2つのプロパティが必要です。コードでは1つで済むことが、Figmaでは2つに分かれるわけです。

こうしたFigmaと実装のプロパティ数のズレは避けられません。大切なのは、このズレがあることをチームで認識し、ルール化しておくことです。

認識が共有されていないと「Figmaと実装でプロパティの数が合わない」という無駄な議論が繰り返されるためです。

![条件付き表示: Figmaでは2つ、コードでは1つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-37.png)

### プロパティ名の先読み: icon問題

ボタンにアイコンを付けられるようにしたいとします。左側にアイコンを1つ置くだけなので、プロパティ名を `icon` にしました。しばらくは問題なく使えます。

ところが数ヶ月後、右側にもアイコンを置きたいという要件が出てきます。右側用のプロパティを追加しようとして手が止まります。`icon` はすでに左側に使ってしまっている。右側を `iconRight` にすると、左が `icon` で右が `iconRight` という非対称な名前になります。かといって既存の `icon` を `iconLeft` にリネームすれば、すでにこのプロパティを使っているすべての箇所を修正しなければなりません。

最初から `iconLeft` と名付けていれば、`iconRight` を足すだけで済んだ話です。将来もう一方が増える可能性を予見できていたかどうかで、後の変更コストが大きく変わります。これは原則の章で触れた経路依存性の力学そのものです。

この「先読み」はアイコンに限りません。ヘッダーだけ作ったあとにフッターが必要になるケース、画像用のプロパティを作ったあとに背景画像との区別が必要になるケースなど、1つだけに見えたものが対になる場面はよくあります。対になる可能性がある要素には、最初から位置や役割を含んだ名前をつけておくと安全です。

さらに、位置を表す語の選び方にも注意が要ります。left / right は物理的な方向を指すため、2つの前提を含んでいます。1つは水平方向であるという前提、もう1つは左から右に読む言語圏であるという前提です。

アラビア語やヘブライ語のように右から左に書く言語では、UIの配置が左右反転します。`iconLeft` と名付けたプロパティが、実際には右側に表示されることになり、名前と見た目が矛盾します。また、レスポンシブデザインでレイアウトの方向が変わる場合にも、left / right は意味を失います。

こうした理由から、物理方向ではなく論理方向で名付ける慣習があります。left / right の代わりに start / end、あるいは leading / trailing を使う方法です。CSSやSwiftUIにもこの考え方に基づいた仕組みが用意されています。

多言語対応の予定がないプロダクトでも、start / end で名付けておくことにデメリットはほとんどありません。将来の可能性を閉じない命名として、頭の片隅に置いておく価値があります。

ここまで、コンポーネントが受け取る設定値——プロパティ——の型と組み合わせを扱いました。次いで、コンポーネントが取りうる状態の設計について考察します。

# 状態: コンポーネントの見え方を網羅する

デザインするとき、データが完璧に入った理想的な状態を中心に描くのは自然なことです。しかし、コンポーネントを実装するときに必要になるのは、すべての状態の定義です。状態の設計が抜けていると、リリース直前にエンジニアから「この状態のデザインがない」と差し戻されることになります。

状態の設計とは、突き詰めれば不確実性への備えです。データは必ず届くとは限らない。通信は失敗しうる。ユーザーの入力は予測できない。理想状態だけをデザインすることは、晴れの日だけを想定して家を建てるようなものです。

この章では、データの有無に関わる状態（UIスタック）と、ユーザー操作に伴う状態（インタラクション状態）の2つに分けて整理します。

## UIスタック: データの有無による5つの状態

画面にデータがどう入ってくるかは、デザイナーがコントロールできません。読み込み中かもしれないし、一部しかデータがないかもしれない。こうした状態の設計は往々にしてエンジニアがヌケモレを教えてくれることが多いのですが、リリース直前であまりきちんとデザインできなかったという経験はよくあるのではないかと思います。

[Scott Hurff](https://www.scotthurff.com/posts/why-your-user-interface-is-awkward-youre-ignoring-the-ui-stack/)が提唱したUIスタックという概念では、UIには以下の5つの状態があるとされています。

1. `Ideal State`: データが完璧に入った状態。Figmaで最初にデザインする状態
2. `Empty State`: データが空の状態。リストが0件のとき、`Avatar`の画像がないとき
3. `Loading State`: 読み込み中。スケルトンスクリーンやスピナー
4. `Partial State`: データが不完全な状態。ユーザー名はあるけどアイコンがない、商品情報はあるが画像が未登録、など
5. `Error State`: 読み込み失敗やバリデーションエラー

![UIの5つの状態と遷移](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-07.png)

新しいコンポーネントを設計するとき、これら5つの状態をすべて定義してから実装に渡してください。

この5つの状態の区別は、見た目が似たコンポーネントを分離する根拠にもなります。

MUIでは、ユーザーへのフィードバックという同じ目的を持ちながら、[`Alert`](https://mui.com/material-ui/react-alert/)（ページ内に常駐するお知らせ欄）、[`Snackbar`](https://mui.com/material-ui/react-snackbar/)（画面下部に一瞬だけ出る通知。トーストとも呼ばれます）、[`Dialog`](https://mui.com/material-ui/react-dialog/)（操作を中断して確認を求めるモーダル）を別々のコンポーネントとして提供しています。

`Alert`は`Error State`や`Partial State`の表示手段、`Snackbar`は操作完了後の一時通知、`Dialog`は操作前の確認。見た目が似ていても、UIスタックのどの層で使われるかが違えば、コンポーネントとして分けるのが自然です。

ユーザーカードや求人リストなどのドメインコンポーネントでは、これらの状態をあらかじめ定義しておく必要があります。読み込み中、データが空、エラーといった状態ごとの見た目をFigmaのバリアントとしてデザインしておきます。たとえば、`state` というバリアント軸に `ideal` / `empty` / `loading` / `error` を用意する方法が一般的です。

成功したときの理想的な画面だけでなく、失敗時やデータ欠損時の見た目もコンポーネントの仕様に含めておくと、実装時にこの状態のデザインがないという差し戻しがなくなります。
そして、用意されているにしてもコンポーネントや画面ごとに明確な基準なく揺れがちなポイントです。コンポーネント設計のチェックリストに組み込んだり、パターンを策定しておくとよいでしょう。

![Loading / Partial / Error のスケルトンパターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-77.png)

### Partial State: もっとも見落としやすい状態

特に`Partial State`はデザイナーが最も見落としやすい状態です。`Ideal State`と`Empty State`は意識しやすい——データがあるか、ないか。しかし現実のデータはある/ないの二択ではなく、一部だけあることのほうが圧倒的に多いのです。

たとえば、ユーザープロフィールカードで考えてみてください。ユーザー名はあるがプロフィール画像を登録していない。評価スコアはあるがレビュー件数が0件。自己紹介文は入力されているが、スキルタグが未設定。

これらの組み合わせは膨大です。すべてをデザインするのは現実的ではありませんが、少なくとも各データ項目が欠けたとき、その領域をどう扱うかのルールは決めておく必要があります。

実践的な対処としては、データ項目ごとにフォールバック（代替表示）を定義しておくことです。

![Partial State: データ欠損時のフォールバック](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-35.png)

| データ項目       | 欠損時の代替表示   |
| ---------------- | ------------------ |
| プロフィール画像 | イニシャルアイコン |
| 評価スコア       | 「—」を表示        |
| 自己紹介文       | 領域ごと詰める     |
| スキルタグ       | セクション非表示   |

こうしたルールがコンポーネントの仕様に含まれていれば、データが欠けても画面が壊れません。

### プロパティと状態の違い

ここでひとつ、デザイナーが混乱しやすいポイントがあります。

UIスタックで扱っている `Loading` や `Error` は、コンポーネントの状態です。これは前の章で扱った外から渡す設定値（プロパティ）とは性質が異なります。

違いを日常に置き換えてみます。信号機でいえば、この信号機は車道用であるというのが外から設定されるプロパティです。一方、いま赤か青かはその信号機自身が切り替える状態です。

Figma上では、プロパティもバリアントとして表現されます。しかしコードでは、外から渡す設定値（`props`）とコンポーネント自身が管理する状態（`state`）は明確に区別されます。この区別があると、外から制御すべき設定値と、コンポーネント内部で管理すべき状態が明確になり、責任の範囲がはっきりします。

この区別をFigma上でも見分けやすくするために、状態を表すプロパティに目印をつけておくのが有効です。たとえば、`_state` や `_isLoading` のように `_` プレフィックスをつけて命名しておけば、外から渡す設定値なのかコンポーネント内部の状態なのかが一目でわかり、デザインと実装の間の認識のズレを防げます。

ここまで扱った `Loading` や `Error` はシステム側の状態——データの有無やAPIの成否によって決まるものでした。コンポーネントにはもうひとつ、ユーザーの操作に伴う見た目の変化があります。これもまた状態の一種ですが、性質が異なるので分けて整理します。

## インタラクション状態: ユーザーの操作に応じた見た目の変化

ボタンの上にマウスカーソルを乗せたとき、押し込んでいるとき、操作できない状態のとき。これらはそれぞれ `Hover`、`Pressed`、`Disabled` と呼ばれます。Figmaでは `Interactive Components` の機能で表現できます。

![インタラクション状態: 5つの見た目を統一ルールで管理する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-29.png)

Webにおけるボタンのインタラクションには一覧のながれがあります。default → hover → focused → pressed → waiting（[Curtis, 2016](https://medium.com/eightshapes-llc/buttons-in-design-systems-eac3acf7e23)）。この一連の流れを切れ目なくデザインすることが、ボタンのインタラクション品質を決めます。

ここで大事なのは、こうしたインタラクション状態のルールをコンポーネントごとに個別に決めないことです。`Hover`時は現在の背景色に対してオーバーレイを8%重ねる、`Disabled`時は`opacity`を38%に下げる——こうしたルールをトークンとして一元管理しておけば、新しいコンポーネントを作るときにゼロから設計する必要がなくなります。[Material Design 3のState Layers](https://m3.material.io/foundations/interaction/states/state-layers)がこの考え方の参考になります。

デザイナーが見落としがちなのがフォーカス状態です。マウスを使わずキーボードのTabキーで画面を操作するユーザーにとって、いまどの要素にフォーカスがあるかを示すフォーカスリング（枠線）は不可欠な手がかりです。フォーカスリングの色、太さ、オフセットをコンポーネント横断で統一しておくことが重要です。

すべてのインタラクティブなコンポーネントに対して、`Hover`、`Pressed`、`Disabled`、`Focus`の見た目を定義しておくと、実装の抜け漏れが減り、操作方法を問わず一貫した体験を提供できます。

# レイアウト: コンポーネントの中身と置き方を分離する

変数の章ではコンポーネントが何を受け取るかを扱いました。ここからは、コンポーネントをどう配置するかという別の設計軸に移ります。

## 中身と配置の分離

冒頭の原則で紹介したカプセル化（Encapsulation）が、もっとも具体的に効いてくる領域です。コンポーネントの中身と置き方を分離する——余白、区切り線、幅の振る舞いをどう設計するか。Figmaの`Auto Layout`の設定と対応づけながら見ていきます。

核心はシンプルです。コンポーネントは自分の中身だけに責任を持ち、どこに置くかは親に任せる。ソフトウェア設計における関心の分離（Separation of Concerns）の空間的な表現ともいえます。コンポーネントは「自分がどう見えるか」だけに関心を持ち、「自分がどこに置かれるか」には無関心でいる。この無関心さこそが、再利用性の源泉です。

この分離が曖昧だと、ボタンをここに置いたら余白がおかしい、カードの幅が想定と違うという問題が再利用のたびに発生します。逆に、この原則が徹底されていれば、同じコンポーネントがどんなレイアウトの中に置かれても意図通りに振る舞います。

システム設計や通信における原則のひとつに「受け取るものには寛容に、送り出すものには厳密に」（ポストルの法則）という考え方があります。コンポーネントに当てはめると、どんな入力（長いテキスト、空データ、想定外の画像比率）が来ても壊れずに受け止めること。一方で、外に提供するレイアウト——marginを持たない、幅の振る舞いが予測可能——は厳密であるべきです。この章で扱う設計判断の多くは、この「入力に寛容、出力に厳密」の実践です。

## 外側の余白: コンポーネントに含めない

コンポーネントの外側にmarginを含めるか含めないか。このひとつの判断で、再利用するたびに余白を手動で調整する手間がなくなります。

Figmaでコンポーネントを作るとき、ボタンの下に24pxの空白を含めた状態でコンポーネント化するケースは珍しくありません。Figma上では使いやすいのですが、コードに反映されると、別の場所で使うたびに余白の上書きが必要になります。

ここで大事な区別があります。コンポーネントの内側の余白（`padding`）は問題ありません。ボタンの中でテキストと枠の間に16pxの余白を取ること、カードの中でコンテンツと境界線の間に24pxの余白を取ること。これらはコンポーネント自身の見た目の一部です。

問題になるのは外側の余白（`margin`）です。実装の世界では、コンポーネントは自立した箱の中身であり、箱と箱の距離を決めるのは、それらを並べる親要素の仕事です。Figmaでいう`Auto Layout`の間隔設定がまさにこれにあたります。

コンポーネントに外側の余白を持たせてしまうと、再利用のたびに余白が大きすぎる、もっと詰めたいという問題が起き、再利用性が失われます。

たとえば、ボタンコンポーネントに `margin-bottom: 24px` を含めて作ったとします。フォーム画面ではぴったりです。しかし、ダイアログの中に同じボタンを置いたら余白が広すぎる。カードの中に置いたら今度は間隔が合わない。

結局、3つの画面でそれぞれmarginを上書きすることになり、ボタンの余白が画面ごとに違うというバグチケットが1ヶ月で5件も上がるようなことがおきます。

![padding（内側）と margin（外側）の責任分離](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-19.png)

外側の余白をコンポーネントから剥がして、親の`Auto Layout`で `gap: 16px` を設定する方式に切り替えれば、この種のバグはなくなります。どこに置いても親が間隔を決めるので、ボタン側で上書きする必要がなくなるのです。

原則は、コンポーネントの内側のデザイン（`padding`、背景色、枠線など）はコンポーネントが責任を持ち、外側の配置（`margin`、隣の要素との距離、画面上の位置）はレイアウトを担当する親が決定する、という役割分担です。

- コンポーネントの責任: `padding`（内側の余白）、背景色・枠線、コンテンツの配置
- 親（レイアウト）の責任: `margin`（外側の余白）、要素間の間隔（`gap`）、画面上の位置

## 下線（区切り線）: コンポーネントに含めるか？

余白と同じくらい議論になるのが、リストアイテムの下に引く区切り線の扱いです。

たとえば、リストの各行の間に薄いグレーの線を入れるデザインを考えてみてください。設定画面のメニューリストでも、チャットの会話一覧でも、同じ問題が発生します。この線をリストアイテムのコンポーネントに含めるべきか、それともリストアイテムの外側で制御すべきか。

コンポーネントに下線を含めると、リストの最後の行にも下線がついてしまいます。あるいは、区切り線なしのレイアウトで使いたいときに線が消せません。

余白の問題とまったく同じ構造です。

![区切り線: コンポーネントに含めるか、親が制御するか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-38.png)

一方で、リストの中での区切り線はほぼセットで使うものなので、コンポーネントに含めたほうが配置の手間が減る、という判断もあります。

実務的な落としどころとしては、下線の表示を Boolean のプロパティ（`showDivider`: ON/OFF）として持たせる方法が有効です。デフォルトはONにしておき、最後の行や区切り線が不要な文脈ではOFFにできるようにします。

実装では、最後の要素だけ`showDivider: false`にするのが一般的です。最後の要素の下に線があると、リストの終端がわかりにくくなるためです。

もうひとつのアプローチは、区切り線をリストアイテムに含めず、独立した`Divider`コンポーネントとして親が配置する方法ですChakra UIの[`Divider`](https://v2.chakra-ui.com/docs/components/divider)がこれにあたります。リストアイテム自体は区切り線を一切知らず、親が`ListItem` → `Divider` → `ListItem` → `Divider` → `ListItem`のように交互に並べます。

この方式は余白の原則と完全に一致しています。コンポーネントは自分の中身だけに責任を持ち、要素間の装飾は親が制御する。そして、色々な要素が登場してもそれぞれごとにborderをつくメル必要がありません。ただし、配置のたびに`Divider`を挟む手間が増えるため、`showDivider`プロパティで内包する方式とはトレードオフの関係です。チームの方針として統一しておくのがよいでしょう。

## 幅の振る舞い: Fill・Hug・Fixedの3パターン

もうひとつ、レイアウトに深く関わるのがコンポーネントの幅の扱いです。コンポーネントは、どんな幅の枠の中に置かれるかわかりません。

サイドバーの狭いスペースかもしれないし、画面いっぱいの幅かもしれません。このとき、コンポーネントがどう振る舞うかを決めておく必要があります。

幅の振る舞いは、大きく3つのパターンがあります。

- 親の幅いっぱいに広がる（`Fill`）: 置かれた枠に合わせてコンポーネントの幅が変わる。Figmaでいう`Fill Container`の設定。テキスト入力フィールド、カード、`Divider`など、文脈に応じて幅が変わるべきコンポーネントはこれが基本
- 中身に合わせて自動で伸縮する（`Hug`）: テキストやアイコンの量に応じて幅が決まる。Figmaでいう`Hug Contents`の設定。ボタン、`Tag`、`Badge`など、内容量に幅が比例するコンポーネントに適している
- 固定幅（`Fixed`）: 特定のピクセル値で幅が決まっている。アイコン、`Avatar`、サムネイルなど、サイズが一定であるべきコンポーネントに適している

![Fill / Hug / Fixed の3パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-08.png)

デザイナーがFigmaでコンポーネントを作るとき、見た目は思い通りでも、そのまま実装すると画面サイズが変わったときに想定外の見た目をすることがあります。`Button`のデフォルトを `Fixed Width` にしてしまうと、利用者が画面幅いっぱいのボタンを作りたいときにいちいち設定を変えなければなりません。

ただし、同じコンポーネントでも文脈によって振る舞いが変わることがあります。ボタンはふだんは中身に合わせて伸縮するけれど、モバイルのフォーム画面では画面幅いっぱいに広げたい。

こうしたケースでは、コンポーネント自体は `Hug` をデフォルトにしておき、親の`Auto Layout`側で `Fill` に切り替える、というのが自然な設計です。コンポーネントの幅は自分では決めない、置かれた場所の枠が決める。これも余白の原則と同じ考え方です。

仕様として、このコンポーネントのデフォルトの幅の振る舞いは何かを明示しておくと、実装のブレが減ります。

### 最小幅・最大幅: 振る舞いに制限をかける

Fill・Hug・Fixed の3パターンだけでは対処しきれないケースがあります。Fill で親の幅に追従するコンポーネントが、極端に狭い画面で潰れてしまう。Hug で中身に合わせて伸びるコンポーネントが、長いテキストによって画面幅を突き破る。こうした問題を防ぐのが最小幅（min-width）と最大幅（max-width）です。高さについても同様に min-height / max-height が使えます。

Figma では Auto Layout の子要素に Min Width / Max Width を設定できます。コードでは CSS の `min-width` / `max-width` がそのまま対応します。

たとえば、テキスト入力フィールドは Fill で親の幅に追従するが、最小幅を 200px に設定しておけばそれ以下には縮まない。モーダルダイアログは max-width を 640px にしておけば、大画面でも間延びしない。`Avatar` は固定サイズだから min / max は不要。

この制約はレスポンシブデザインでとくに重要です。画面幅が変わっても壊れないコンポーネントを作るには、Fill / Hug / Fixed のデフォルトに加えて、どこまで縮めてよいか・どこまで広げてよいかの限界値をセットで定義しておく必要があります。

## オーバーフロー: はみ出したコンテンツの扱い

コンポーネントの枠に対してコンテンツが収まりきらないとき、何が起きるか。この問いに答えておかないと、実装時にエンジニアが都度判断することになり、画面ごとに挙動がバラつきます。

Figma ではフレームの Clip Content のオン・オフでコンテンツの切り抜きを制御します。コードでは CSS の `overflow` プロパティ（`hidden` / `scroll` / `auto`）、テキストの `text-overflow: ellipsis`、行数制限の `-webkit-line-clamp` などが対応します。

### テキストのオーバーフロー

もっともよく直面するのが、テキストが想定より長いケースです。ユーザー名、商品名、コメント——長さが予測できないテキストは必ずあります。

ここで決めるべきは、省略（truncate）か折り返し（wrap）かです。

![テキストのオーバーフロー: 省略・行数制限・折り返し](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-64.png)

- 1行で収めたい場面（テーブルのセル、ナビゲーション項目）は `…` で省略する。Figma では Truncate Text の設定、コードでは `text-overflow: ellipsis` と `overflow: hidden` の組み合わせ
- 複数行を許容する場面（カードの説明文、コメント）は折り返すが、最大行数を決めておく（2行まで、3行までなど）。コードでは `-webkit-line-clamp` で行数制限をかける
- 全文表示が必要な場面（記事本文、利用規約）は制限なく折り返す

この判断がコンポーネントの仕様に含まれていないと、「ここは1行で切るべきか、2行まで出すべきか」が実装者ごとに異なる結果になります。

### コンテナのオーバーフロー

コンテンツの量がコンテナの高さを超えたとき——リストの項目数が想定以上に多い、フォームの入力項目が画面に収まらないなど——の扱いも事前に決めておきます。

![コンテナのオーバーフロー: スクロール・もっと見る・切り捨て](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-65.png)

- **スクロール**: コンテナ内にスクロール領域を設ける。Figma ではプロトタイプモードの Scroll Behavior で表現できるが、デザインカンプだけでは伝わりにくい。仕様として「この領域はスクロールする」と明記する。コードでは `overflow-y: auto` が一般的
- **ページネーション / もっと見る**: 一度に表示する件数を制限し、残りはページ送りやボタンで表示する。データが大量になる前提のリスト（検索結果、通知一覧）ではこの方式が適している
- **切り捨て**: 表示しきれないコンテンツを切り捨てて表示しない。`Avatar` の画像が枠からはみ出す場合に `overflow: hidden` で丸く切り抜くのが典型例

スクロールを採用する場合は、スクロール領域の高さの決め方も決めておきます。固定高（`height: 400px`）か、画面高さに連動（`max-height: 60vh`）か。モーダル内のリストなら画面高さに連動させないと、小さい画面でモーダル自体が画面外にはみ出します。

Figma の Clip Content は見た目上コンテンツを切り抜きますが、それがスクロールなのか切り捨てなのかは伝わりません。デザインカンプに加えて、スクロール可能であること、最大表示件数があること、などを仕様として補足しておくのが確実です。

# アセット: ビジュアルをシステムとして管理する

## アセット管理の考え方

レイアウトではコンポーネントの配置と空間を扱いました。ここからは、コンポーネントに組み込まれるもうひとつの要素——ビジュアルアセットの管理に移ります。

コンポーネントやトークンに加えて、アイコン、イラストレーション、アニメーションといったビジュアルアセットもデザインシステムの重要な構成要素です。

これらはデザイナーが作って終わりではなく、実装に組み込まれ、長期的にメンテナンスされ続けるものです。ファイル形式の選択、命名規則、色の制御方法など、デザインと実装の接点で押さえるべきポイントが多くあります。

## コード実装か画像埋め込みか: 再現手段の選択

Figma上で描けたからといって、それがそのままCSSやコードで再現できるとは限りません。複雑なグラデーション、不規則な形状、繊細なテクスチャ表現などは、コードでの再現がむずかしく、手間もかなり大きくなります。

そのような場合、無理にコードで再現するよりも、SVGや`WebP`などの画像として埋め込むほうが合理的です。

なぜこの判断が重要か。この選択は一度決めると覆しにくいからです。

コードで実装したビジュアルは、後からトークンで色を変えたり、アニメーションを追加したり、柔軟に制御できます。一方、画像として埋め込んだものは、変更のたびにデザイナーが書き出し直してエンジニアに渡す手順が発生します。

つまり、コード実装は変更コストが低く、画像埋め込みは初期コストが低い。この表現は今後変わる可能性があるかを軸に判断します。

![コード実装かアセット埋め込みかの判断フロー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-09.png)

たとえば、ライトモードで黒、ダークモードで白に切り替わるアイコンはコード実装が必須です。画像として埋め込んでいると、モード切り替えのたびにファイルを差し替える手間が発生します。一方、一度作ったら長期間変わらない装飾的なイラストは画像埋め込みで構いません。

コードで再現するか、アセットとして埋め込むかは、早い段階で実装方針をすり合わせておきたい論点です。

## アイコン管理: 既存ライブラリと独自制作のトレードオフ

アイコンはUIの中でよく使われるグラフィックのひとつです。まず考えるべきは、世の中にあるアイコンライブラリを使うのか、自社でゼロから作るのかという戦略です。

### 既存ライブラリを使う

実装コストがほぼゼロなのが大きな強みです。ライブラリを導入して名前を指定するだけで画面に配置できます。一貫性が保たれており、アイコンが足りなくて困ることもありません。

反面、ブランドの独自性は薄れます。どこかで見たことがあるアプリという印象になりがちですし、自社特有の概念を表現するアイコンがない場合、結局一部だけ自作することになります。

### 独自アイコンを制作する

![既存ライブラリ vs 独自アイコン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-21.png)

ブランドの世界観を細部までコントロールでき、プロダクト独自のドメイン知識を視覚的に正しく伝えることが可能です。ただし、制作とメンテナンスのコストは大きいです。SVGのパスをきれいに掃除し、書き出し設定を整え、実装で使える形式で管理し続ける必要があります。

これらはハイブリッド運用することも可能です。矢印やゴミ箱などの汎用的なアイコンは既存のライブラリに頼り、プロダクトを象徴する重要なアイコンだけを自作する構成です。ただし、この場合は線の太さや角丸のルールをライブラリ側に寄せる配慮が欠かせません。統一感がないとここだけ浮いて見えるという問題が起きるためです。

## ベクターアイコンの活用: SVGとアイコンフォント

アイコンの管理にどんな形式を選ぶかは、日々の開発効率に影響する選択です。

意外と多いのが、アイコンをPNGやJPGなどのラスター画像で管理しているパターンです。この方式だと、色違いが必要になるたびに別ファイルを書き出す必要がありますし、ダークモード対応では同じアイコンの白版・黒版が倍々で増えていきます。さらに拡大表示でぼやけるという根本的な問題もあります。

現在の開発現場では、アイコンはSVGまたはアイコンフォントとして管理するのが標準です。こうした形式であれば、個別の画像ファイルを保存・呼び出しする必要がなく、アイコン名を指定するだけで表示できます。色やサイズもコードから自由に制御でき、ほとんどのケースではこの方式で十分です。

具体的にどれほどの違いがあるかを見てみましょう。

![名前指定によるアイコン呼び出し](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-49.png)

Figmaでの管理方法としては、アイコンそれぞれを個別のコンポーネントとして作成する方法と、`Component Set`でバリアントとしてまとめる方法があります。チームの規模やアイコンの数に応じて選択してください。

以下では、アイコンをSVGとして実装に渡す際に知っておきたい技術的仕様を紹介します。

## 色の制御: アイコンの色を自動で合わせるしくみ

Figma上でアイコンの色を変えるとき、塗りの色を直接変更しますよね。コードの世界でも同じことをしたいのですが、Figmaから書き出したSVGファイルの中身を覗くと、色が `#1A1A1A`（ほぼ黒のカラーコード）のような固定値で埋め込まれていることがあります。

この状態だと、ボタンの中に置いたアイコンの色をボタンの色に合わせて自動で切り替える、といったことができません。

ダークモードを導入した際にこの問題にぶつかるチームは少なくありません。ライトモードでは黒いアイコンがきちんと見えていたのに、ダークモードに切り替えた瞬間、黒い背景に黒いアイコンで何も見えない。原因は、SVGに色が固定値で埋め込まれていたことです。

### 色を親に委ねる

理想は、SVGの中の色を固定値にせず、周囲のテキスト色に自動で合わせるという指定にしておくことです。CSSでは `currentColor` という値でこれを実現します。白いテキストのボタンの中に置けば白に、青いリンクの中に置けば青に、と自動で色が変わります。Figmaでいえば、Variablesでアイコンの色をテキスト色トークンに紐づけておくのと近い考え方です。

![SVGの色制御: 固定色 vs currentColor](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-30.png)

運用ルールとしておすすめなのは、Figma上でアイコンコンポーネントを最初から黒一色で作ることです。コード側で色を上書きする前提にしておけば、Figma上ではカジュアルに色をあてることができます（こうしたとき、デザイントークンによる規律が有効です）。

チームによっては、書き出し時に自動で色を除去するビルドスクリプトを用意しているケースもあります。チームで運用方法をすり合わせておきましょう。

## 参考リソース

この記事で扱った内容をさらに深掘りしたいときや、自社のデザインシステムを設計する際の参考として、以下のリソースが役立ちます。

**デザインシステム事例:**

- [Shopify Polaris](https://polaris.shopify.com/) — eコマース向けの成熟したシステム
- [Atlassian Design System](https://atlassian.design/) — B2Bプロダクト向け
- [GitHub Primer](https://primer.style/) — 開発者ツール向け
- [IBM Carbon](https://carbondesignsystem.com/) — エンタープライズ向け

**UIパターン・コンポーネント集:**

- [Mobbin](https://mobbin.com/) — 実在アプリのUIパターン検索
- [Component Gallery](https://component.gallery/) — オープンソースコンポーネントの横断比較

**ツール:**

- [Tokens Studio](https://tokens.studio/) — Figmaプラグインでデザイントークンを管理
- [Storybook](https://storybook.js.org/) — コンポーネントのカタログ化と動作確認

**アクセシビリティ:**

- [ARIA Authoring Practices Guide (APG)](https://www.w3.org/WAI/ARIA/apg/) — WAI-ARIAの実装パターン集

# おわりに

長い記事にお付き合いいただき、ありがとうございます。

この記事では、デザインシステムのコンポーネント設計を、原則から具体的な変数の型まで段階的に掘り下げてきました。

![本書の構成と知識の積み上げ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-10.png)

振り返ると、この記事で扱ってきたのは「Figmaとコードをどう揃えるか」だけではありませんでした。コンポーネントをどう分けるか、プロパティにどんな型を選ぶか、変更のどこが安全でどこが危険か——これらの問いに向き合うことは、一枚の画面を描くこととは質の異なる思考です。

個々のUIの見た目ではなく、変更のしやすさ、拡張の余地、認知の負荷。目に見えない構造に意識を向ける力——システム思考と呼ばれるものの一端が、この記事で扱ってきた内容です。

この記事には命名規則や型定義の話が数多く登場しました。
ただ、ルールに忠実に従うこと、細部を完璧にすることも、それ自体がゴールではありません。ルールの背後にある「なぜ」を掴むこと——その構造的な理解が、まだルールのない新しい局面でも自分で判断できる力になります。

「この変更の影響範囲はどこまでか」「この設計は半年後の誰かが安全に拡張できるか」「この命名は意図を正しく伝えているか」。こうした問いを自然に立てられるようになることは、デザインシステムの仕事に限らず、プロダクト設計のあらゆる場面で活きてきます。

これらを抑えることで、本来私たちが取り組むユーザー価値の実現にフォーカスできるようにする。細かい議論や調整に時間を使わずにデザインできることが本質的に目指すべきことです。

そしてもうひとつ。デザインシステムは単に作業を速くするための装置ではありません。一人が磨き上げたUXの質を、組織全体に伝播させるインフラです。あるデザイナーがエッジケースまで丁寧に詰めたコンポーネントは、それを使うすべての画面の品質を底上げします。投資が線形ではなく指数的に効く——この構造こそ、デザインシステムが「効率化ツール」を超えて組織の競争力になりうる理由です。

コンポーネント名、プロパティの型、レイヤーの階層。これらが整理されていると、会議で「あのコンポーネントのあのプロパティ」と言ったとき、デザイナーもエンジニアも同じものを思い浮かべられます。このメンタルモデルの同期は、ツールの一致ではなく、チームが同じ設計言語を共有することで実現します。そしてその設計言語は、完成品ではなく、チームで育てていくものです。

![メンタルモデルの同期: Figma・コード・チームの認知が一致する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-52.png)

## この記事のKey Takeaway

### 原則

- **間接化**: トークンやマスターコンポーネントを介して、変更を一箇所に集約する。コストの圧縮装置であると同時に、品質の増幅装置でもある
- **カプセル化**: 内部の複雑さを隠し、使う側にはシンプルなインターフェースだけを見せる
- **制約**: 選択肢を意図的に絞り、判断の負荷を下げる。正しい選択を最も簡単にする環境設計
- **意味の符号化**: 見た目ではなく意味で名付ける。色ではなく役割で設計する
- **合成**: 小さな部品を組み合わせて大きなUIを構築する。部品を増やさずにバリエーションを増やせる
- **慣習**: 命名規則やディレクトリ構造など、チームの暗黙知を形式化する。新メンバーが迷わず拡張できる土台
- **経路依存性**: 原則ではなく、設計判断に常に作用する力学。追加はほぼ無料に見えるが、削除コストは時間とともに加速度的に上がる。慎重に追加し、早めに非推奨にする姿勢が重要
- **意図的な妥協**: 場当たり的な対処は必ず発生する。問題は「なんとなく」やること。理由を一言残す、後で直しやすい方向に倒す、先送りにトリガーを決める——この3つで場当たりは設計になる
- 6つの原則は工数削減だけでなく、定型的な判断から解放し、本質的な問題に集中する余地を生む。加えて、一人の優れた設計判断を組織全体に伝播させるレバレッジとして機能する

### 構築戦略

- **汎用ライブラリ**（MUI / Chakra UI等）: すぐ使えるが、独自のデザインを追求するほどカスタマイズコストが上がる
- **フルスクラッチ**: 設計思想を100%反映できるが、構築も維持もコストが高い
- **Headless UI**（Radix UI / React Aria等）: 見た目を持たず機能だけを提供する。アクセシビリティ対応をライブラリに任せつつ、スタイルは自由に設計できる
- 現実的にはハイブリッド——汎用部品はHeadless UIベース、ドメイン固有部品はフルスクラッチなど、短期と長期の両面でリソースと目的を天秤にかける
- **後発導入の3ステップ**: トークンから入る → 新規画面から準拠する → 既存画面は優先度をつけて段階移行。混在期間は避けられないと受け入れ、揃ったところから価値を出す

### コンポーネント分割

- コンポーネント化の判断基準は「一箇所を直せば全部直る状態にしたいか」
- Atomic Design（大きさで分ける）、FSD（目的で分ける）、フラット配置の3つのアプローチがある
- FSDの依存方向は一方通行: 上位レイヤーは下位を使えるが、逆はNG
- コンポーネント数が20〜30を超えたら階層化を検討する

### 汎用とドメインの分離

- **汎用コンポーネント**: 特定のデータ構造に依存しない。別のサービスでもそのまま使えるかが判断基準
- **ドメインコンポーネント**: 特定のデータ構造に特化し、表示ルールをコンポーネント内部に閉じ込める
- オブジェクトをまるごと受け取るならドメインコンポーネント、個別の値を受け取るなら汎用コンポーネント
- 境界はチームで判断基準を議論し、ケーススタディを積み重ねてナレッジにする

### 命名

- コンポーネント名はゼロから考えず、Radix UI / MUI / Chakra UI 等の業界語彙から借りる。悩むより揃えるほうが早い
- 名前は「何であるか」だけを表し、「いまどんな状態か」はプロパティで表現する。`RedButton`ではなく`Button` + `variant="danger"`
- ドメインコンポーネントはAPIのデータモデル名と揃える（`ShiftCard`）。汎用コンポーネントは特定のデータ名を含めない（`Card`）
- 命名規則が整っているとAIコード生成の精度も上がる。逆にバラバラだとAIもバラバラなコードを生成する
- 一度決めた名前を変えるコストは高い。最初の命名で議論し、ルール化してドキュメントに残す

### 早すぎる共通化の罠

- 見た目が似ていることと、目的やドメインが同じことは別の話
- 無理に統合すると互いに無関係なプロパティが混在し、複雑なコンポーネントになる
- 共通化の判断は、同じパターンが繰り返し現れてからでも遅くない（AHA原則）

### 安全な変更と破壊的変更

- **増やすのは簡単、変えるのは大変**: バリアント追加は安全、プロパティ名の変更やバリアント削除は破壊的変更
- Figmaではプロパティを変更してもインスタンスが自動追従するが、コードではそうはいかない。この非対称性を意識するだけで、変更提案の仕方が変わる
- コンポーネントは作ることより終わらせることのほうが難しい。[Deprecated]マークで非推奨を明示し、代替コンポーネントを記載する

### 例外の許容

- 100%準拠を目指さない。90%の定型と10%の例外を最初から織り込む
- Detachの前に4つの選択肢を検討する: 組み合わせ → バリアント追加 → 新規作成 → 例外許容
- 逸脱を「データ」と見なしフィードバックループを回す。運用はルールの監視ではなく、正しい選択が自然にできる環境設計
- FigmaとコードのUIが完全一致している必要はない。インターフェース（プロパティの名前と型）が一致していることのほうが重要

### 変数の型

- **Boolean**: ON/OFFの2値。排他的な状態（`Small`/`Large`）をBooleanで分けると矛盾が生じる。Enumを使う
- **Enum**: 決まった選択肢から1つ選ぶ。追加は安全、削除や名称変更は破壊的変更
- **String**: 自由入力テキスト。空文字列・長文・改行を含むケースを必ず定義する
- **Number**: 上限・下限・ステップを明示する
- **Array**: 0件・1件・多数の3パターンを考慮する
- **Object**: 複数の情報のまとまり。ドメインコンポーネントはデータ一式をまとめて受け取る
- **Element（スロット）**: 差し込み口を設けてバリアント爆発を防ぐ。Configuration（設定値で制御）よりComposition（部品を組み合わせ）が柔軟

### プロパティの直交性

- プロパティ同士が互いに干渉しない設計が重要。あるプロパティの値を変えても、他のプロパティの意味が変わらないようにする
- 関心が異なるなら、見た目が似ていても別コンポーネントにする（例: Toggle vs Switch）
- プロパティ名の先読み: `icon`と名付けた後に右側のアイコンが必要になると困る。対になる可能性がある要素は最初から位置を含んだ名前にする

### Figmaとコードの差分

- デフォルト値で使いやすさが決まる。8割のユースケースは何も指定しなくても使える状態を目指す
- Figmaではトグル＋テキストの2操作で条件付き表示を制御するが、コードでは値の有無で1つで制御できる。このズレを認識しルール化する
- デフォルト値は一度決めたら簡単に変えられない。影響範囲が広いため慎重に決定する

### 状態

- **UIスタック**: `Ideal` / `Empty` / `Loading` / `Partial` / `Error` の5状態をすべて定義してから実装に渡す
- `Partial State`が最も見落としやすい。データ項目ごとにフォールバック（代替表示）を定義する
- 外から渡す設定値（props）とコンポーネント自身が管理する内部状態（state）を区別する
- **インタラクション状態**: `Hover` / `Pressed` / `Disabled` / `Focus` をトークンで一元管理し、コンポーネントごとに個別に決めない

### レイアウト

- コンポーネントは自分の中身だけに責任を持ち、どこに置くかは親に任せる
- 外側の余白（`margin`）はコンポーネントに含めない。親の`Auto Layout` / `gap`で制御する
- **幅の振る舞い**: `Fill` / `Hug` / `Fixed`の3パターンをデフォルトとして明示する
- テキストのオーバーフロー（省略 vs 折り返し）とコンテナのオーバーフロー（スクロール vs ページネーション）を定義する

### トークンとアセット

- 色・サイズをトークンとして一元管理し、複数コンポーネントの一貫性を保つ。個別に値を書き込むと微妙なズレが蓄積する
- アイコンはSVGで管理し、色は `currentColor` で親のテキスト色に自動追従させる
- コード実装か画像埋め込みかは「今後変わる可能性があるか」で判断する
- 既存ライブラリ＋独自アイコンのハイブリッド運用では、線の太さや角丸のルールを統一する
