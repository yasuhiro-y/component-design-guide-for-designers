---
title: "おわりに"
---

長い記事にお付き合いいただき、ありがとうございます。

この記事では、デザインシステムのコンポーネント設計を、原則から具体的な変数の型まで段階的に掘り下げてきました。

![本書の構成と知識の積み上げ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-10.png)

振り返ると、この記事で扱ってきたのは「Figmaとコードをどう揃えるか」だけではありませんでした。コンポーネントをどう分けるか、プロパティにどんな型を選ぶか、変更のどこが安全でどこが危険か——これらの問いに向き合うことは、一枚の画面を描くこととは質の異なる思考です。

個々のUIの見た目ではなく、変更のしやすさ、拡張の余地、認知の負荷。目に見えない構造に意識を向ける力——システム思考と呼ばれるものの一端が、この記事で扱ってきた内容です。

この記事には命名規則や型定義の話が数多く登場しました。
ただ、ルールに忠実に従うこと、細部を完璧にすることも、それ自体がゴールではありません。ルールの背後にある「なぜ」を掴むこと——その構造的な理解が、まだルールのない新しい局面でも自分で判断できる力になります。

「この変更の影響範囲はどこまでか」「この設計は半年後の誰かが安全に拡張できるか」「この命名は意図を正しく伝えているか」。こうした問いを自然に立てられるようになることは、デザインシステムの仕事に限らず、プロダクト設計のあらゆる場面で力になります。

これらを抑えることで、本来私たちが取り組むユーザー価値の実現にフォーカスできるようにする。細かい議論や調整に時間を使わずにデザインすることができることが本質的に目指すべきことです。

コンポーネント名、プロパティの型、レイヤーの階層。これらが整理されていると、会議で「あのコンポーネントのあのプロパティ」と言ったとき、デザイナーもエンジニアも同じものを思い浮かべられます。このメンタルモデルの同期は、ツールの一致ではなく、チームが同じ設計言語を共有することで実現します。そしてその設計言語は、完成品ではなく、チームで育てていくものです。

![メンタルモデルの同期: Figma・コード・チームの認知が一致する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-52.png)

# この記事のKey Takeaway

## 原則

- **間接化**: トークンやマスターコンポーネントを介して、変更を一箇所に集約する。再利用性と変更のしやすさは同じメカニズムの表裏
- **カプセル化**: 内部の複雑さを隠し、使う側にはシンプルなインターフェースだけを見せる
- **制約**: 選択肢を意図的に絞り、判断の負荷を下げる。正しい選択を最も簡単にする環境設計
- **意味の符号化**: 見た目ではなく意味で名付ける。色ではなく役割で設計する
- **合成**: 小さな部品を組み合わせて大きなUIを構築する。部品を増やさずにバリエーションを増やせる
- **慣習**: 命名規則やディレクトリ構造など、チームの暗黙知を形式化する。新メンバーが迷わず拡張できる土台
- **経路依存性**: 原則ではなく、設計判断に常に作用する力学。追加はほぼ無料に見えるが、削除コストは時間とともに加速度的に上がる。慎重に追加し、早めに非推奨にする姿勢が重要
- **意図的な妥協**: 場当たり的な対処は必ず発生する。問題は「なんとなく」やること。理由を一言残す、後で直しやすい方向に倒す、先送りにトリガーを決める——この3つで場当たりは設計になる
- 6つの原則は工数削減だけでなく、定型的な判断から解放し、本質的な問題に集中する余地を生む

## 構築戦略

- **汎用ライブラリ**（MUI / Chakra UI等）: すぐ使えるが、独自のデザインを追求するほどカスタマイズコストが上がる
- **フルスクラッチ**: 設計思想を100%反映できるが、構築も維持もコストが高い
- **Headless UI**（Radix UI / React Aria等）: 見た目を持たず機能だけを提供する。アクセシビリティ対応をライブラリに任せつつ、スタイルは自由に設計できる
- 現実的にはハイブリッド——汎用部品はHeadless UIベース、ドメイン固有部品はフルスクラッチなど、短期と長期の両面でリソースと目的を天秤にかける
- **後発導入の3ステップ**: トークンから入る → 新規画面から準拠する → 既存画面は優先度をつけて段階移行。混在期間は避けられないと受け入れ、揃ったところから価値を出す

## コンポーネント分割

- コンポーネント化の判断基準は「一箇所を直せば全部直る状態にしたいか」
- Atomic Design（大きさで分ける）、FSD（目的で分ける）、フラット配置の3つのアプローチがある
- FSDの依存方向は一方通行: 上位レイヤーは下位を使えるが、逆はNG
- コンポーネント数が20〜30を超えたら階層化を検討する

## 汎用とドメインの分離

- **汎用コンポーネント**: 特定のデータ構造に依存しない。別のサービスでもそのまま使えるかが判断基準
- **ドメインコンポーネント**: 特定のデータ構造に特化し、表示ルールをコンポーネント内部に閉じ込める
- オブジェクトをまるごと受け取るならドメインコンポーネント、個別の値を受け取るなら汎用コンポーネント
- 境界はチームで判断基準を議論し、ケーススタディを積み重ねてナレッジにする

## 命名

- コンポーネント名はゼロから考えず、Radix UI / MUI / Chakra UI 等の業界語彙から借りる。悩むより揃えるほうが早い
- 名前は「何であるか」だけを表し、「いまどんな状態か」はプロパティで表現する。`RedButton`ではなく`Button` + `variant="danger"`
- ドメインコンポーネントはAPIのデータモデル名と揃える（`ShiftCard`）。汎用コンポーネントは特定のデータ名を含めない（`Card`）
- 命名規則が整っているとAIコード生成の精度も上がる。逆にバラバラだとAIもバラバラなコードを生成する
- 一度決めた名前を変えるコストは高い。最初の命名で議論し、ルール化してドキュメントに残す

## 早すぎる共通化の罠

- 見た目が似ていることと、目的やドメインが同じことは別の話
- 無理に統合すると互いに無関係なプロパティが混在し、複雑なコンポーネントになる
- 共通化の判断は、同じパターンが繰り返し現れてからでも遅くない（AHA原則）

## 安全な変更と破壊的変更

- **増やすのは簡単、変えるのは大変**: バリアント追加は安全、プロパティ名の変更やバリアント削除は破壊的変更
- Figmaではプロパティを変更してもインスタンスが自動追従するが、コードではそうはいかない。この非対称性を意識するだけで、変更提案の仕方が変わる
- コンポーネントは作ることより終わらせることのほうが難しい。[Deprecated]マークで非推奨を明示し、代替コンポーネントを記載する

## 例外の許容

- 100%準拠を目指さない。90%の定型と10%の例外を最初から織り込む
- Detachの前に4つの選択肢を検討する: 組み合わせ → バリアント追加 → 新規作成 → 例外許容
- 逸脱を「データ」と見なしフィードバックループを回す。運用はルールの監視ではなく、正しい選択が自然にできる環境設計
- FigmaとコードのUIが完全一致している必要はない。インターフェース（プロパティの名前と型）が一致していることのほうが重要

## 変数の型

- **Boolean**: ON/OFFの2値。排他的な状態（`Small`/`Large`）をBooleanで分けると矛盾が生じる。Enumを使う
- **Enum**: 決まった選択肢から1つ選ぶ。追加は安全、削除や名称変更は破壊的変更
- **String**: 自由入力テキスト。空文字列・長文・改行を含むケースを必ず定義する
- **Number**: 上限・下限・ステップを明示する
- **Array**: 0件・1件・多数の3パターンを考慮する
- **Object**: 複数の情報のまとまり。ドメインコンポーネントはデータ一式をまとめて受け取る
- **Element（スロット）**: 差し込み口を設けてバリアント爆発を防ぐ。Configuration（設定値で制御）よりComposition（部品を組み合わせ）が柔軟

## プロパティの直交性

- プロパティ同士が互いに干渉しない設計が重要。あるプロパティの値を変えても、他のプロパティの意味が変わらないようにする
- 関心が異なるなら、見た目が似ていても別コンポーネントにする（例: Toggle vs Switch）
- プロパティ名の先読み: `icon`と名付けた後に右側のアイコンが必要になると困る。対になる可能性がある要素は最初から位置を含んだ名前にする

## Figmaとコードの差分

- デフォルト値で使いやすさが決まる。8割のユースケースは何も指定しなくても使える状態を目指す
- Figmaではトグル＋テキストの2操作で条件付き表示を制御するが、コードでは値の有無で1つで制御できる。このズレを認識しルール化する
- デフォルト値は一度決めたら簡単に変えられない。影響範囲が広いため慎重に決定する

## 状態

- **UIスタック**: `Ideal` / `Empty` / `Loading` / `Partial` / `Error` の5状態をすべて定義してから実装に渡す
- `Partial State`が最も見落としやすい。データ項目ごとにフォールバック（代替表示）を定義する
- 外から渡す設定値（props）とコンポーネント自身が管理する内部状態（state）を区別する
- **インタラクション状態**: `Hover` / `Pressed` / `Disabled` / `Focus` をトークンで一元管理し、コンポーネントごとに個別に決めない

## レイアウト

- コンポーネントは自分の中身だけに責任を持ち、どこに置くかは親に任せる
- 外側の余白（`margin`）はコンポーネントに含めない。親の`Auto Layout` / `gap`で制御する
- **幅の振る舞い**: `Fill` / `Hug` / `Fixed`の3パターンをデフォルトとして明示する
- テキストのオーバーフロー（省略 vs 折り返し）とコンテナのオーバーフロー（スクロール vs ページネーション）を定義する

## トークンとアセット

- 色・サイズをトークンとして一元管理し、複数コンポーネントの一貫性を保つ。個別に値を書き込むと微妙なズレが蓄積する
- アイコンはSVGで管理し、色は `currentColor` で親のテキスト色に自動追従させる
- コード実装か画像埋め込みかは「今後変わる可能性があるか」で判断する
- 既存ライブラリ＋独自アイコンのハイブリッド運用では、線の太さや角丸のルールを統一する
