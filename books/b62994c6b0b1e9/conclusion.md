---
title: "おわりに"
---

長い記事にお付き合いいただき、ありがとうございます。

この記事では、デザインシステムのコンポーネント設計を、原則から具体的な変数の型まで段階的に掘り下げてきました。

![本書の構成と知識の積み上げ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-10.png)

振り返ると、この記事で扱ってきたのは「Figmaとコードをどう揃えるか」だけではありませんでした。コンポーネントをどう分けるか、プロパティにどんな型を選ぶか、変更のどこが安全でどこが危険か——これらの問いに向き合うことは、一枚の画面を描くこととは質の異なる思考です。

個々のUIの見た目ではなく、変更のしやすさ、拡張の余地、認知の負荷。目に見えない構造に意識を向ける力——システム思考と呼ばれるものの一端が、この記事で扱ってきた内容です。

この記事には命名規則や型定義の話が数多く登場しました。
ただ、ルールに忠実に従うこと、細部を完璧にすることも、それ自体がゴールではありません。ルールの背後にある「なぜ」を掴むこと——その構造的な理解が、まだルールのない新しい局面でも自分で判断できる力になります。

「この変更の影響範囲はどこまでか」「この設計は半年後の誰かが安全に拡張できるか」「この命名は意図を正しく伝えているか」。こうした問いを自然に立てられるようになることは、デザインシステムの仕事に限らず、プロダクト設計のあらゆる場面で力になります。

これらを抑えることで、本来私たちが取り組むユーザー価値の実現にフォーカスできるようにする。細かい議論や調整に時間を使わずにデザインすることができることが本質的に目指すべきことです。

コンポーネント名、プロパティの型、レイヤーの階層。これらが整理されていると、会議で「あのコンポーネントのあのプロパティ」と言ったとき、デザイナーもエンジニアも同じものを思い浮かべられます。このメンタルモデルの同期は、ツールの一致ではなく、チームが同じ設計言語を共有することで実現します。そしてその設計言語は、完成品ではなく、チームで育てていくものです。

![メンタルモデルの同期: Figma・コード・チームの認知が一致する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-52.png)

# この記事のKey Takeaway

## 7つの原則

- **間接化（Indirection）**: トークンやマスターコンポーネントを介して、変更を一箇所に集約する。再利用性と変更のしやすさは同じメカニズムの表裏
- **カプセル化（Encapsulation）**: 内部の複雑さを隠し、使う側にはシンプルなインターフェースだけを見せる。ひとつの部品にひとつの責任
- **制約（Constraint）**: 選択肢を意図的に絞り、判断の負荷を下げる。正しい選択を最も簡単にする環境設計
- **意味の符号化（Semantic Encoding）**: 見た目ではなく意味で名付ける。色ではなく役割で設計する
- **合成（Composition）**: 小さな部品を組み合わせて大きなUIを構築する。部品を増やさずにバリエーションを増やせる
- **慣習（Convention）**: 命名規則やディレクトリ構造など、チームの暗黙知を形式化する。新メンバーが迷わず拡張できる土台
- **経路依存性（Path Dependency）**: 初期の選択が未来を縛る。命名・ディレクトリ構造・ライブラリ選択——すべてに同じ力学が働く
- **認知リソースの再配分**: 7つの原則が工数削減だけでなく、定型的な判断から解放し、本質的な問題に集中する余地を生む

## コンポーネント分割

- コンポーネント化の判断基準は「一箇所を直せば全部直る状態にしたいか」
- Atomic Design（大きさで分ける）、FSD（目的で分ける）、フラット配置の3つのアプローチがある
- Atomic Designでは`molecules`/`organisms`の境界が人によってバラバラになりがち
- FSDの依存方向は一方通行: 上位レイヤーは下位を使えるが、逆はNG。`Button`が`UserCard`に依存してはいけない
- コンポーネント数が20〜30を超えたら階層化を検討する

## 汎用とドメインの分離

- **汎用コンポーネント**: 特定のデータ構造に依存しない。別のサービスでもそのまま使えるかが判断基準
- **ドメインコンポーネント**: 特定のデータ構造（オブジェクト）に特化する。データの表示ルールをコンポーネント内部に閉じ込められる
- 汎用コンポーネントにはビジネスロジックを含めない。表示テキストは呼び出し側が渡す
- 境界は一意に決まらないこともある。チームで判断基準を議論し、ケーススタディを積み重ねてナレッジにする
- オブジェクトをまるごと受け取る設計なら、ドメインコンポーネントとして位置づけるのが自然

## 早すぎる共通化の罠

- 見た目が似ていることと、目的やドメインが同じことは別の話
- 無理に統合すると互いに無関係なプロパティが混在し、複雑なコンポーネントになる
- 共通化の判断は、同じパターンが繰り返し現れてからでも遅くない（AHA原則）

## 命名

- **名前は設計の一部**: 最初につけた名前がコード・ドキュメント・チームの会話に定着する。後から変えるコストは高い
- 見た目ではなく役割で名付ける。`RedButton`ではなく`DestructiveButton`
- 状態やバリエーションを名前に含めない。`DisabledButton`ではなく`Button` + `isDisabled`
- ドメインコンポーネントの名前はAPIのデータモデル名と揃える（`ShiftCard`など）
- 汎用コンポーネントにはデータモデル名を入れない（`UserAvatar`ではなく`Avatar`）
- Booleanは動詞で始める（`is` / `has` / `show`）、否定形は避ける
- Enumは意味で名付ける（`variant: red` → `variant: danger`）、色はセマンティクスで
- Figmaのプロパティ名がそのままコードの変数名になる。コード側の命名規約を先に確認する
- 命名規則が整っているとAIコード生成ツールも自社の命名体系に沿った補完をする

## 変数の型

- **`Boolean`**: ON/OFFの2値。排他的な状態（`Small`/`Large`）を`Boolean`で分けると矛盾が生じる
- **`Enum`**: 決まった選択肢から1つ選ぶ。制約が判断の負荷を下げ、正しい選択を最も簡単にする。追加は安全、削除や名称変更は破壊的変更
- **`String`**: 自由入力テキスト。空文字列のケースを必ず定義する
- **`Number`**: 数値。上限・下限やステップを明示する
- **`Array`**: 配列。0件・1件・多数の3パターンを考慮する
- **`Object`**: 複数の情報のまとまり。ドメインコンポーネントはデータ一式をまとめて受け取る
- **`Element`（スロット）**: 差し込み口を設けてバリアント爆発を防ぐ。`Instance Swap Property`で表現する

## プロパティの直交性

- プロパティ同士が互いに干渉しない設計が重要
- あるプロパティの値を変えても、他のプロパティの意味や振る舞いが変わらないようにする
- 関心が異なるなら、見た目が似ていても別コンポーネントにする（例: Toggle vs Switch）
- ひとつのプロパティに複数の関心事をまとめて扱わない

## UIスタック: 5つの状態

- **`Ideal` / `Empty` / `Loading` / `Partial` / `Error`** の5状態をすべて定義してから実装に渡す
- **`Partial State`が最も見落としやすい**: データは「ある/ない」の二択ではなく、「一部だけある」ことのほうが多い
- データ項目ごとにフォールバック（代替表示）を定義しておく
- 外から渡す設定値（`props`）とコンポーネント自身が管理する状態（`state`）は区別する
- 状態を表すプロパティには `_` プレフィックスなど目印をつけると認識のズレを防げる

## インタラクション状態

- **`Hover` / `Pressed` / `Disabled` / `Focus`** の見た目をすべてのインタラクティブなコンポーネントに定義する
- ルールをトークンで一元管理し、コンポーネントごとに個別に決めない
- フォーカスリングの色・太さ・オフセットはコンポーネント横断で統一する

## Figmaとコードの差分

- **必須と任意**: デフォルト値で使いやすさが決まる。8割のユースケースは何も指定しなくても使える状態を目指す
- **条件付き表示**: Figmaではトグル＋テキストの2操作、コードでは値の有無で1つで制御。このズレを認識し、ルール化しておく
- デフォルト値は一度決めたら簡単に変えられない。影響範囲が広いため慎重に決定する

## レイアウト

- コンポーネントは自分の中身だけに責任を持ち、どこに置くかは親に任せる
- **外側の余白（`margin`）はコンポーネントに含めない**: 親の`Auto Layout` / `gap`で制御する
- **区切り線**: `showDivider`（`Boolean`）で制御するか、親のループで挿入するか方針を決める
- **幅の振る舞い**: `Fill`（親に合わせる）/ `Hug`（中身に合わせる）/ `Fixed`（固定）の3パターンをデフォルトとして明示する

## トークンの共有

- 色・サイズをトークンとして一元管理し、複数コンポーネントの一貫性を保つ
- セマンティックカラーを兄弟コンポーネント間で共有すれば、一箇所の修正で全体に反映される
- トークンを使わず個別に値を書き込むと、微妙なズレが蓄積する

## アクセシビリティ

- コンポーネントに組み込めるところは組み込む。使うだけで基準を満たせる状態を作る
- コントラスト比をトークンレベルで保証する
- アイコンやイラストに代替テキスト用のプロパティ（`altText` / `ariaLabel`）を設ける
- コンポーネント単体で全て担保できるわけではない。ページ構造や読み上げ順序は別途議論する

## アセット管理

- **コード実装 vs 画像埋め込み**: 今後変わる可能性があるかで判断する。変更が想定されるならコード実装
- アイコンはSVGまたはアイコンフォントで管理する。PNG/JPGは色違いのたびに別ファイルが増える
- SVGの色は固定値ではなく `currentColor` で親のテキスト色に自動追従させる
- 既存ライブラリ＋独自アイコンのハイブリッド運用では、線の太さや角丸のルールを統一する

## 安全な変更と破壊的変更

- **増やすのは簡単、変えるのは大変**: 新しいバリアント追加は安全、プロパティ名の変更は破壊的
- Figmaではプロパティを自由に変更でき、インスタンスは自動追従するが、コードではそうはいかない
- この非対称性を意識するだけで、変更の提案のしかたや移行計画の立て方が変わる

## ライフサイクル管理

- コンポーネントは作ることより、**終わらせることのほうが難しい**
- [Deprecated] マークで非推奨を明示し、代替コンポーネントを説明欄に記載する
- 方針がないと使われなくなったコンポーネントがゾンビのように残り続ける

## 例外の許容と現実的な対処

- 100%準拠を目指さない。90%の定型と10%の例外を最初から織り込む
- Detach（コンポーネント解除）の前に4つの選択肢を検討する: 組み合わせ → バリアント追加 → 新規作成 → 例外許容
- 逸脱を罰するのではなく「データ」と見なし、フィードバックループを回す。運用はルールの監視ではなく、正しい選択が自然にできる環境設計
- 規範的（これを使え）と生成的（これで新しいものを作れる）のバランスを意識する
- FigmaとコードのUIが完全一致している必要はない。インターフェース（プロパティの名前と型）が一致していることのほうが重要

## AI時代の設計

- 命名規則・型定義・UI状態の定義が整ったデザインシステムは、AIコード生成の精度を引き上げる
- AIの精度を左右するのは見た目以上に意味の正確さ。命名・型・バリアントが意図を正しく伝えているかが鍵
- デザイナーが仕組みを理解し、エンジニアと共通言語を持つことの価値は、AI時代にさらに高まる
