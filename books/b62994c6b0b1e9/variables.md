---
title: "変数: コンポーネントが受け取る設定値"
---

Figmaのプロパティパネルは、コードの設計図そのものです。パネルに並ぶトグルやドロップダウン、あの一つひとつに型があることを意識したことはありますか？　この章を読むと、エンジニアに「このプロパティ、BooleanですかEnumですか？」と自分から確認できるようになります。型の会話ができるだけで、認識のズレによる手戻りが激減します。

# プロパティの型を解剖する

![Figma プロパティパネルとコードの対応関係](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-18.png)

ここからは、コンポーネントが外側から受け取る設定値——プロパティ——をくわしく見ていきます。Figmaのコンポーネントプロパティパネルに並んでいるトグルスイッチ、テキストフィールド、バリアントの切り替え。これらはコード上の変数と対応しています。

> **Notice:** この章で「変数」「プロパティ」と呼んでいるのは、コンポーネントに渡す設定値のことです。FigmaのVariables機能（デザイントークンを管理するしくみ）とは別の概念です。混同しやすいので注意してください。

Figmaのプロパティパネルを整理することは、コードの設計図を書くことでもあります。この設計図はAIコード生成の精度にも直結します。型が明確に定義されていれば、AIに渡したときに自社のルールに沿った精度の高いコードが返ってきやすくなります。

プロパティには型（Type）があります。Figmaのプロパティパネルで、トグルスイッチなのか、テキスト入力なのか、バリアントの切り替えなのか——その入力方式の違いが、コードでは型として定義されています。Notionのデータベースを思い浮かべてください。カラムを作るとき、テキスト・数値・チェックボックス・セレクト・日付……と種別を選びます。
あのカラムの種別が、ここでいう型にあたります。

Figmaのプロパティパネルでも同じことが起きています。トグルスイッチはBoolean、バリアント切り替えはEnum、テキスト入力はStringです。Figmaのプロパティパネルではテキスト入力欄に何でも自由に入れられますが、コードの世界では数値の 24 とテキストの "24" は別物です。このプロパティに入る値はテキストなのか、数字なのか、ON/OFFなのかを意識して設計すると、コードとの対応関係が明確になります。

ここでは、Boolean、Enum、String、Number、Dateといった基本の型に加え、配列やオブジェクトといったデータの構造についても解説します。聞き慣れない用語もありますが、ひとつずつFigmaの操作に対応づけていきます。

![プロパティの型: Figma での見え方とコードの対応](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-17.png)

以下の表は全体像です。まずはざっと眺めてみましょう。

| 型      | コードでの書き方（参考）                        | Figmaでの表現             |
| ------- | ----------------------------------------------- | ------------------------- |
| Boolean | `isDisabled: boolean`（ON/OFFの値）             | トグルスイッチ            |
| Enum    | `size: 'S' \| 'M' \| 'L'`（3つの中から1つ選ぶ） | バリアント（Variant）     |
| String  | `label: string`（自由なテキスト）               | テキスト入力              |
| Number  | `count: number`（数値）                         | テキスト入力              |
| Date    | `deadline: Date`（日付）                        | テキスト入力              |
| Array   | `items: Item[]`（データの一覧）                 | `Auto Layout`内の繰り返し |
| Object  | `user: User`（データのまとまり）                | 複数プロパティの集合      |
| Element | `icon: ReactNode`（別の部品を差し込む）         | `Instance Swap`           |

## 汎用ライブラリの変数設計をみてみる

Chakra UIやMUIなどの汎用ライブラリを見漁ったことのある方は、変数の設計が似通っていることに気づいているかもしれません。

実際に並べてみると、どのライブラリも Button・Input・Select・Tag・Switch・Checkbox といった基本部品を揃えており、それぞれが `size`・`variant`・`colorScheme`・`disabled` といった類似のプロパティを持っています。名前やAPIの細部は違っても、設計の骨格は共通しています。

![汎用ライブラリのコンポーネント例: MUI / Chakra UI / Ant Design](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-56.png)

これは偶然ではなく、UIの問題構造が同じだからです。ボタンには見た目のバリエーションとサイズが必要で、入力フィールドにはプレースホルダーと無効状態が必要——こうした要件は言語やフレームワークを問わず共通します。だからこそ、ここから先で扱う変数の型や設計パターンは、特定のライブラリに依存しない普遍的な知識として使えます。

## Boolean: 真偽値

スイッチのON/OFF、はい/いいえの2択です。コードでは`true`/`false`という値が入ります。

Figmaではプロパティパネルにあるトグルスイッチで指定するプロパティです。アイコンを表示するかどうか、読み込み中かどうか、といった存在や状態のオンオフを管理します。

たとえば、`isRequired`（必須かどうか）、`isDisabled`（操作できない状態かどうか）、`showIcon`（アイコンを表示するかどうか）。名前の通り、はい/いいえで答えられる性質をそのままプロパティにしたものです。

### Boolean の命名

Booleanのプロパティ名には2つのルールがあります。

ひとつは否定形を避けること。`isNotDisabled` ではなく `isDisabled`。Figmaでいえば、トグルスイッチの名前を「無効ではない」にするか「無効」にするかの違いです。二重否定は読み手を混乱させるだけです。

もうひとつは動詞で始めること。`is` は状態（`isDisabled`）、`has` はあるかないか（`hasBorder`）、`show` は表示するかどうか（`showIcon`）。プロパティ名を読むだけで、何のON/OFFかがわかります。

### Boolean が増えすぎたら Enum へ

Booleanはシンプルで使いやすい反面、増えすぎると矛盾が生まれます。トグルが3つあればON/OFFの組み合わせは8通り。そのほとんどは、ありえない状態を含んでいます。

たとえば、ボタンのサイズを `isSmall` と `isLarge` という2つのBooleanで管理したとします。どちらもOFFなら通常サイズ。では両方ONになったら？ 小さくて大きいボタンは存在しません。こうした矛盾が生まれる時点で、サイズは最初からEnum（`Small` / `Medium` / `Large` の選択式）にすべきだったということです。

同じことは表示位置にも当てはまります。Figmaのプロパティパネルに「左アイコン表示」「右アイコン表示」の2つのトグルが並んでいて両方ONにできてしまう状態を想像してください。`hasLeftIcon` と `hasRightIcon` を別々に持つとこの矛盾が生じます。これを1つのドロップダウン `iconPosition: 'left' / 'right' / 'none'` にまとめれば、常にひとつだけが選ばれます。これがBooleanからEnumへの移行です。

![Boolean の矛盾: 2つのトグルより1つの Enum](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-42.png)

Booleanを追加するときの確認ポイントです。

- そのON/OFFは本当に2択か？ 将来3択以上に増える可能性はないか
- 他のBooleanと組み合わせたとき、ありえない状態が生まれないか
- Figmaのバリアント（Enum）で表現したほうがシンプルにならないか
- ひとつのコンポーネントにBooleanが3つ以上並んでいないか

もうひとつ知っておきたいのは、Booleanには「まだ決まっていない」がないということです。Figmaのトグルスイッチと同じで、ONかOFFか、必ずどちらかの状態にあります。だからこそ、コンポーネントを新しく作ったとき、そのトグルの初期状態をONにするかOFFにするかをあらかじめ決めておく必要があります。

## Enum: 列挙型

あらかじめ用意された選択肢の中からひとつだけ選ぶ形式です。Notionデータベースのセレクトカラムと同じ考え方です。

FigmaのVariant（バリアント）がこれにあたります。たとえば、`size` なら `small` / `medium` / `large` のどれか、`variant` なら `primary` / `secondary` のどれか、というように選択肢をあらかじめ定義しておきます。Figmaのバリアントでサイズ = `S` / `M` / `L`を選ぶ操作を思い浮かべてください。プロパティパネルのドロップダウンから選ぶあの操作そのものが、Enumの概念です。

Enumの価値は、あえて制約することにあります。

String型は何でも入力できますが、自由すぎるとチームのなかでバラつきが生まれます。Enumにして選択肢を絞ることで、迷う場面が減り本質に集中できるようになる。選択肢の体系そのものが、コンポーネントの使い方を暗に伝えてくれます。

制約は、急いでいるときにこそ効きます。デッドライン直前、人は最も簡単な道を選びがちです。選択肢が自由すぎると「とりあえず」の判断が積み重なり、一貫性が崩れていく。あらかじめEnumで選択肢を整えておくことは、正しい選択を最も簡単にする環境設計です。

たとえば、余白をNumber型の自由入力にすると、14px、16px、18px…と微妙に違う値が画面ごとに増えていきます。これをSpacing Tokenにして `Small` / `Medium` / `Large` しか選べなくすれば、誰が組んでもリズムが整います。トークン化前は画面ごとに5種類以上の余白値が混在していたのが、トークン化後は3種類だけ——余白に関する議論が大幅に減るのは、デザインシステム導入のわかりやすい成功指標です。

### 選択肢の命名: 意味で名付ける

Enumの選択肢は、見た目ではなく意味で名付けます。よくあるのがこのようなものです。
みてのとおり、MECEであったり、粒度感がそろっていたりすることがわかります。
誰でも心当たりがあるかもしれませんが、選択肢の命名は重要である割にデザイナーが手癖でつけてしまいがちです。今は問題なくても、次の人が困る命名は克服しましょう。

| プロパティ  | 選択肢の例                            |
| ----------- | ------------------------------------- |
| size        | small / medium / large                |
| variant     | primary / secondary / outline / ghost |
| status      | success / warning / error / info      |
| colorScheme | blue / green / red / gray             |
| placement   | top / right / bottom / left           |
| intensity   | solid / subtle / outline              |
| orientation | horizontal / vertical                 |
| shape       | circle / square / rounded             |

それでは、個別の性質をもつ選択肢設計の論点をみていきます。

### Tシャツサイズ: 拡張可能なスケール

`size` の選択肢として広く使われているのがTシャツサイズです。`small` / `medium` / `large` という呼び方で、省略形なら `s` / `m` / `l`。基準となるサイズを `medium` に置き、そこから上下に展開していきます。

拡張が必要になったとき、上方向は `x-large` → `2x-large`（`xl` → `2xl`）、下方向は `x-small` → `2x-small`（`xs` → `2xs`）と伸ばせます。最初から全段階を用意する必要はありませんが、この拡張パスを頭に入れておくだけで、命名の破綻を防げます。

もうひとつ意識しておきたいのが、最も代表的な値をスケールの中に正しく位置づけることです。いま選択肢がひとつしかなくても、その値がスケールのどこにあるかを考えておく。よくある失敗は、なんとなく最初に作ったサイズを `size = default` と名付けてしまうパターンです。1年後には `default` / `small` / `smaller` / `tiny` の4段階に膨れ上がり、`default`が`large`なのか`medium`なのか答えられない——こうした事態は珍しくありません。

最初に作るものがひとつであっても、スケールの中での位置を決めて`medium`や`large`というように体系を前提として名付けます。`Default`はスケール上の位置を表さない名前です。だからこそ、最も代表的な値には`medium`という明確な位置づけを与えておきましょう。

### 色のセマンティクス: 見た目ではなく役割で名付ける

色についても同じことが言えます。`variant` = `Blue` としてしまうと、ブランドカラーが変わったときやダークモードに対応したときに名前と実際の色が矛盾します。

![色のセマンティクス: 見た目ではなく役割で名付ける](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-61.png)

色は意味で名付けると堅牢です。`variant` = `Primary` や `variant` = `Danger` のように、その色が果たす役割で呼ぶことで、中身の色が変わっても名前が壊れません。

なぜ見た目の色名が問題になるのか。プロダクトのライフサイクルの中で、色は思った以上に変わります。ブランドカラーの刷新、ダークモードの追加、アクセシビリティ改善によるコントラスト調整——いずれも色の値が変わる契機です。`variant: red` と名付けていたものが紫に変わったとき、名前と現実が矛盾し、コードとデザインの対応関係が壊れます。`variant: danger` であれば、色が何色になろうと意味は通ります。

この考え方はデザイントークンの設計にも直結します。トークンの章で扱ったように、`Tag`・`Badge`・`Callout` が同じセマンティックカラーを参照していれば、トークンの値をひとつ変えるだけですべてのコンポーネントに反映されます。逆にリテラルな色名で管理していると、コンポーネントごとに値を追いかける必要が生じます。

ボタンもバッジもタグも、同じセマンティックカラー体系に基づいて名付けることで、コンポーネント間の一貫性が保たれます。

### 設計の確認ポイント

- 選択肢の名前は見た目ではなく意味で付けているか（`Red` ではなく `Danger`）
- 将来の拡張を見越した命名になっているか（新しい選択肢を追加しても既存の名前が不自然にならないか）
- 選択肢の数は適切か（7つ以上あるなら設計を見直すサイン。選択肢が多すぎると使う側が迷い、管理も煩雑になります）
- 同じ意味の選択肢が別の名前で重複していないか

### 実践例: Tag と Badge

Enumの力が特に発揮されるのが、`Tag`、`Badge`、`Callout` のように色とサイズの組み合わせをまとめて管理するコンポーネントです。

実際のライブラリでも、Enumの設計が見た目の似たコンポーネントを整理する武器になっています。Figmaでいえば、`Badge`と`Tag`の両方に`size`（`S` / `M`）と`colorScheme`（`info` / `success` / `warning` / `error`）というバリアント軸を揃えておき、`Tag`にだけ「×ボタン表示」のトグルを追加する設計です。

[Chakra UI](https://chakra-ui.com/)はまさにこの構造で、[`Badge`](https://chakra-ui.com/docs/components/badge)と[`Tag`](https://chakra-ui.com/docs/components/tag)が同じ色の体系（`colorScheme`）と表現の種類（`variant`）——塗りつぶし（`solid`）、薄い背景色（`subtle`）、枠線のみ（`outline`）——を共有しつつ、`Tag`にだけ閉じるボタンの有無を切り替えるBooleanが加わっています。

色と強度の軸は共通の設計言語で揃え、機能の違いだけをBooleanで表現する。このパターンは自社のコンポーネント設計でもそのまま応用できます。

![Chakra UI: Badge と Tag の colorScheme バリエーション](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-16.png)

たとえば、`Tag`コンポーネントを考えてみてください。情報の種類を表す色（`info`: 青、`success`: 緑、`warning`: 黄、`error`: 赤）と、表示サイズ（`small` / `medium`）の掛け算になります。

これを色とサイズの2つのEnumで管理すれば、Figmaのバリアントは2軸のマトリクスになり、構造が明快です。

## String: 文字列

ボタンのラベルや入力欄のプレースホルダーなど、画面に表示されるテキストデータです。

ここでデザイナーが考えるべきはデータの不在です。もし文字列が空だったら、その領域は詰めるのか、あるいはプレースホルダーを出すのか。ユーザー名が極端に長かった場合、… で省略するのか、折り返すのか。これらはすべてプロパティの仕様として定義しておきたいところです。

![String型: テキストの振る舞い6パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-33.png)

文字列型のプロパティを追加するときに確認しておきたいことがあります。

- 空のとき何が起きるか決めたか（領域を詰める？ プレースホルダーを出す？）
- 最大文字数を超えたときの処理を決めたか（省略記号、折り返し、スクロール）
- 改行を含む可能性はあるか（1行テキストか複数行テキストか）
- 本当に自由入力が必要か（選択肢が決まっているならEnumにできないか）

日本語だけでデザインしていると見落としがちですが、同じ意味のテキストでも英語になると幅が1.5〜2倍に膨らむことがあります。たとえば、日本語で「確認」と表示していたボタンが、英語では「Confirm」になります。横幅が固定されたボタンでは、テキストが溢れるか省略されて読めなくなります。

多言語対応の予定がなくても、テキストの長さが変動する前提でコンポーネントを組んでおくことは、堅牢な設計につながります。

たとえば、アイコンとテキストが横に並ぶボタンで、テキストが長くなったときにどうするか。アイコンを非表示にしてテキストを優先するのか、テキストを省略記号で切るのか、折り返して高さを広げるのか。これはコンポーネントの仕様として事前に決めておきたい判断です。

もうひとつ気をつけたいのが、テキストの縦方向の振る舞いです。Figmaのテキストボックスは `Auto Height` に設定すれば中身に合わせて高さが変わりますが、コードでも同じ挙動になるかはフレームワークや実装方法によって異なります。行の高さ（Line Height）がコンポーネント全体の縦幅にどう影響するかは、デザインとコードで差が出やすいポイントです。

## Number: 数値

バッジのカウント数（通知が3件あるときの「3」）や評価スコア（星4.5）など、数値を示すデータです。

![Number型: 数値の表示ルール](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-45.png)

文字列と数値の違いは、スプレッドシートを思い浮かべるとわかりやすいでしょう。

セルに数字を入れると右寄せになり、テキストを入れると左寄せになります。あの挙動が示すとおり、数字と文字列は根本的に異なるデータ型です。数値は合計や比較、フォーマット変換などの計算ができるのに対し、文字列はあくまで文字の並びにすぎません。

999+ のように上限を超えた場合の表示ルールや、0のときに非表示にするかどうかといった仕様も、数値型のプロパティに付随する重要な設計判断です。

数値型のプロパティを扱うときに確認しておきたいことです。

- 上限・下限を超えたときの表示を決めたか（999+、0件のときなど）
- 0のとき非表示にするか、0と表示するか
- マイナスの値はありえるか（ポイント残高、差分表示など）
- 単位の表示はコンポーネントの責任か、外から渡すか（円、件、%）

## Date: 日付と時刻

カレンダーの予定日、メッセージのタイムスタンプ、クーポンの有効期限。日付や時刻を扱うデータです。
これはFigmaでは表現することができないため、Stringのプロパティで扱うことになるでしょう。

私たちが画面上で見ている 2月17日 や 3日前 といった表示は、裏側では 2026-02-17T14:00:00Z のような機械が読む形式のデータを変換したものです。スプレッドシートでも、セルに日付を入れるとカレンダー形式で表示されますが、中身は表示を変えても意味が維持される日付データですよね。それと同じで、日付データには裏側のデータと画面に出す見た目という二層構造があります。

![Date型: 日付の表示形式と設計判断](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-46.png)

日付型のプロパティを設計するときの確認ポイントです。

- 日付のフォーマットはコンポーネント内部で決めるか、外部で決めてテキストとして渡されるか
- タイムゾーンの考慮は必要か（海外ユーザーがいるサービスでは要注意）
- 相対表示（3日前）と絶対表示（2月17日）のどちらを使うか、切り替えるか
- 未来の日付と過去の日付で表示を変える必要はあるか（締め切りのカウントダウン、イベント開始までの残り時間など）

ここまでの5つの型（Boolean / Enum / String / Number / Date）で、コンポーネント設計に必要な基礎は揃いました。以降のArray・Object・Elementは、複雑なデータを扱うときに必要になる発展的な型です。今すぐ必要でなければ次の章に進んでも構いません。読み進める方のために、ここからはデータの構造（まとまり方）に関する型を見ていきます。

ひとつ実践的なコツを補足します。たとえば、更新日: 2026/01/01 と表示するUIがあるとき、Figma上のプロパティは 2026/01/01 のテキストだけにし、更新日というラベルはコンポーネント内に固定しておくと、実装との対応が明確になります。

## Array: 配列（リスト）

同じ種類のデータが複数あるとき、コンポーネントにはそのリストをまるごとプロパティとして渡します。タグの一覧、通知リスト、メニューの項目——こうしたケースです。

Figmaでいえば、同じコンポーネントを`Auto Layout`内に繰り返し配置する操作にあたります。コードではこれを配列として扱います。

![配列: 同じテンプレートに異なるデータを流し込む](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-62.png)

同じ器に異なるデータを流し込む——これが配列型のUIの特徴です。各要素のテキストの内容、`Tag`の有無、ステータスの色はそれぞれ異なりますが、コンポーネント自体は同じものが使い回されます。

![Array型: リストの4つの状態](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-34.png)

ただし、Figmaでは3件分のデータを置くと3件で固定されますが、実際のアプリでは0件になったり100件になったりします。デザイナーが意識しておきたいのは、0件・1件・大量にあるときのそれぞれの見え方です。

- 0件のとき何を表示するか（空状態のデザインは用意したか）
- 上限はあるか（無限に増えるのか、最大表示件数を設けるか）
- 大量にあるとき、無限スクロールかページネーションか
- 並び順は固定か、ユーザーが変えられるか

## Object: オブジェクト（データのまとまり）

名前・アイコン・ステータスのような、複数の情報がひとかたまりになっているケースです。

Notionでいえば、データベースの1行がこれにあたります。ユーザーという1行に、名前・アイコン画像・ステータスがセットで入っているイメージです。

![オブジェクト: 複数の値をひとかたまりで渡す](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-63.png)

たとえば、ユーザーカードに渡すユーザーというデータを考えてみてください。名前、アイコン画像、ステータス。これらをバラバラのプロパティとして渡すこともできますが、ドメインコンポーネントではユーザーの情報一式としてまとめて渡すほうが自然です。

Figmaのプロパティパネルでは、こうしたデータのまとまりを直接表現する方法がありません。名前・アイコン・ステータスをバラバラのプロパティとして並べるしかないのです。しかし、コード側ではユーザーというひとつのまとまり（オブジェクト）として渡せます。

デザイナーが意識しておきたいのは、このコンポーネントに渡すデータは、個別の値なのか、まとまりなのか、という点です。`Avatar`なら画像URLだけで十分（個別の値）。`UserCard`ならユーザーの情報一式が前提（まとまり）。この判断が、コンポーネントを汎用にするかドメイン専用にするかの分かれ道です。

Figmaのプロパティパネルで見比べてみると、この違いがはっきりします。`Avatar`のパネルには`image`、`altText`の2項目だけ。一方`UserCard`には`userName`、`userImage`、`rating`、`status`、`isVerified`とずらりと並びます。

プロパティが20個並んだコンポーネントは、使う側にとって何をどう設定すればいいかわからないものになります。逆に粒度が粗すぎると汎用性がなくなります。いま手元のFigmaで、プロパティが10個を超えているコンポーネントを探してみてください。それはドメイン専用として認識すべきサインかもしれません。

オブジェクトの中で特に気をつけたいのは、データの一部が欠けているケースです。ユーザー名はあるけどアイコン画像がない、評価スコアがまだ付いていない。こうした歯抜けのデータにどう対応するかを、コンポーネントの仕様として決めておく必要があります。

また、オブジェクトをまるごと受け取る設計は、そのコンポーネントが特定のドメインに紐づいていることを意味します。コンポーネント分割の章で触れたように、汎用コンポーネントは個々の値をバラバラに受け取り、ドメインコンポーネントはデータ一式をまとめて受け取るのが基本です。

Objectを受け取るコンポーネントを作ろうとしているなら、それはドメインコンポーネントとして位置づけるのが自然でしょう。

![Object型: 個別の値 vs データのまとまり](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-47.png)

## Element: 要素

ここまでの型（Boolean、Enum、String、Numberなど）はすべて、テキストや数値といったデータを渡すものでした。しかし、プロパティに渡したいのがデータではなく、別のコンポーネントそのものというケースがあります。

![Button のスロット構造: 差し込み口を設けることでバリアント爆発を防ぐ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-04.png)

Figmaで考えるとわかりやすいです。`Instance Swap Property`を使って、ある箇所にアイコンを差し込んだり、`Avatar`に差し替えたりします。

コードの世界ではこの仕組みをスロット（slot）と呼びます。Reactでは`ReactNode`あるいは`JSX.Element`型、SwiftUIでは`@ViewBuilder`、Flutterでは`Widget`型としてそれぞれ表現されます。ここでは便宜上Element型と総称します。好きなものを差し込める口を設けておく設計です。

たとえば、カードの説明文を表示する箇所を考えてみてください。通常はテキストを渡せば十分です。しかし、テキストの一部をリンクにしたい場合はどうでしょうか。String型ではここからここまでがリンクという情報を表現できません。リンクを含んだUIのかたまりをまるごと渡す必要があります。

あるいは、リストアイテムの左側に置くものが、ある画面ではアイコン、別の画面では`Avatar`。こうした場合にスロット（Element型のプロパティ）があれば、何を差し込むかは利用者に委ねられます。

スロットの威力がもっともわかりやすいのは、バリアントの爆発を防げる点です。

<!-- たとえを図示する -->

アイコン付きボタンの例で考えてみましょう。デザイナーは `LeftIcon` / `RightIcon` / `BothIcons` / `NoIcon` という4つのバリアントを作りがちです。しかし、スロットの発想を使えば、ボタンの左右に好きなものが入るエリアを用意するだけで済みます。アイコンでも、バッジでも、何も入れなくてもよい。

Figmaでは、`Instance Swap Property`を使ってスロットを表現します。設計のポイントは2つです。

- 何も入れないを選択肢に含める。空のプレースホルダーコンポーネントを候補に入れておけば、アイコン不要な場面でも対応できる
- 差し込める対象を制約する。`Instance Swap Property`で差し替え候補を同じカテゴリに限定し、意図しない使い方を防ぐ

設計時に考えておきたいのは、その箇所にテキストを渡すだけで本当に十分か、それとも将来的にUIのかたまりを渡す必要が出てこないか、という点です。最初はStringで足りていても、後からリンクやアイコン付きテキストが必要になるケースは少なくありません。

![Element型（スロット）: 差し込み口で中身を自由に](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-48.png)

コンポーネントを柔軟にする方法は2つあります。プロパティ（設定値）をどんどん増やす方法と、スロットのように小さな部品を差し替える方法です。前者をConfiguration（設定型）、後者をComposition（組み合わせ型）と呼びます。プロパティが10個、20個と膨らんできたら、それはスロット（Composition）への切り替えどきです。

![Configuration vs Composition: 設定の山か、組み合わせか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-50.png)

ここまで個々の型を見てきました。ここからは、複数のプロパティが組み合わさったときにどう振る舞うかを考えます。

# プロパティの直交性: 組み合わせが壊れない設計

実際のコンポーネントではプロパティが複数組み合わさって使われます。このとき大事になるのが、プロパティ同士が互いに干渉しないという性質です。これを直交性と呼びます。

あるプロパティの値を変えたとき、他のプロパティの意味や振る舞いまで変わってしまうなら、そのプロパティ同士は独立していません。Figmaでバリアントを設計するとき、この感覚があると組み合わせの破綻を未然に防げます。

## 直交している状態

`Button`に`size`（`S`・`M`・`L`）と`variant`（`primary`・`secondary`・`destructive`）の2つのプロパティがあるとします。`size`を`S`から`L`に変えても`variant`の見た目は変わらない。`variant`を`destructive`に変えても`size`は影響を受けない。3×3＝9通りすべてが成立します。これが直交している状態です。

![直交性: size と variant の組み合わせがすべて成立する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-05.png)

もし「`destructive`のときは`S`が使えない」「`secondary`の`L`だけ角丸が変わる」といった暗黙の制約があったら、組み合わせるたびにルール確認が必要になります。

もう一つの例を見ます。タグの部品に`colorScheme`（情報・成功・警告・エラー）と`variant`（塗りつぶし・薄い背景・背景なし）の2つのプロパティがあるとします。`colorScheme`は意味を表し、`variant`は濃度を表します。種類を変えても濃度の振る舞いは変わらないし、濃度を変えても種類の意味は変わりません。この2つは独立しています。

![直交性: colorScheme と variant の組み合わせマトリクス](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-28.png)

## 1つの組み合わせに2つの意味を持たせると何が起きるか

直交性が壊れるのは、1つのプロパティが複数の関心事をまとめて引き受けてしまうときです。

たとえば、ボタンの見た目を`style`というプロパティひとつで管理しているケースを考えます。選択肢は `primary`・`secondary`・`danger`・`ghost`。最初の3つは色の種類（意味）を表していますが、`ghost`だけは「背景なし」という色の強さを表しています。1つのプロパティに「色の種類」と「色の強さ」という2つの関心が混在しています。

この設計では、`ghost`のエラー色はどうなるのかという問いに答えられません。`style: ghost`は背景がないのだから、`danger`の赤い背景は出せない。「`ghost`のときはエラー表示に対応していません」という例外が生まれ、その例外はドキュメントに書かれ、やがて忘れられます。

`variant`（`solid` / `subtle` / `ghost`）と`colorScheme`（`primary` / `secondary` / `danger`）を分ければ、`colorScheme: danger` × `variant: ghost`の組み合わせは自然に成立します。赤いテキストだけのボタンが、マトリクスの1セルとして生まれる。例外のないシステムは、ドキュメントなしでも正しく使えます。

![直交性の崩れ: 1つのプロパティに混ぜる vs 分離する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-67.png)

## 設計時のチェックポイント

プロパティを設計するとき、次の3つを確認します。

- このプロパティの値を変えたとき、他のプロパティの意味や動きまで変わらないか
- 2つのプロパティの組み合わせに暗黙の優先順位が生まれていないか
- ひとつの値が複数の関心事（色の種類と色の強さ、サイズと形状など）をまとめて扱っていないか

直交性が保たれていると、プロパティを追加するたびに既存の組み合わせを紐解く必要がありません。逆に、プロパティ間に暗黙の依存があると、機能を足すたびに優先順位の整理が必要になり、そのルールは時間とともにチーム内で忘れられていきます。

Figmaの[Propstar](https://www.figma.com/community/plugin/1116018586739867857/propstar)というプラグインを使うと、コンポーネントのすべてのプロパティ組み合わせを一覧表示できます。直交性が保たれているかの確認や、プロパティのヌケモレの発見に便利です。

# トークンの共有: 複数コンポーネントの一貫性を保つ

ここまでは個々のコンポーネントのプロパティ設計を見てきました。もう一歩引いて、複数のコンポーネントにまたがる設計について触れておきます。

色やサイジングの体系は、複数のコンポーネントで使い回せるように設計しておくと便利です。こうした共通の値に名前をつけて一元管理する仕組みをトークンと呼びます。Figmaでいえばスタイルやバリアブルに近い概念です。

![トークンの共有: 複数コンポーネントの一貫性を保つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-06.png)

Figmaでは、`Tag`の色を変えたければ`Tag`のスタイルを編集し、`Callout`の色も変えたければ`Callout`のスタイルも別途編集する——というコンポーネントごとの作業になりがちです。

しかしコードの世界では、共通のトークンを参照する仕組みがあれば、トークンの値をひとつ変えるだけですべてのコンポーネントに反映されます。

たとえば、`Tag`の info と `Callout` の info が同じセマンティックカラーを参照していれば、色を変えたいときに一箇所の修正で両方に反映されます。バラバラに定義していると、デザイナーが個別に色を選ぶたびに微妙なズレが蓄積し、`Tag`は青いのに`Callout`は水色、という不一致がいつの間にか生まれます。

色だけの話ではありません。兄弟関係にあるコンポーネント（`Button` / `IconButton` / `CopyButton`など）では、縦幅やアイコンのサイズも共通のトークンを参照しておくと一貫性を保ちやすくなります。

こうしたトークンを一元管理しておけば、`Tag`の配色を微調整したいときに、共通構造を持つすべてのコンポーネントに変更が波及します。トークンを使わず個別のコンポーネントに値を直接書き込んでいたら、ひとつずつ直すことになります。

Figma上でデザイントークンを管理するプラグインとしては、[Tokens Studio](https://tokens.studio/)が広く使われています。JSONベースでトークンを定義でき、コードとの同期にも対応しています。

# Figmaだけでは伝わらない変数の性質: コードとの差分を知る

ここまで紹介した型はFigmaのプロパティパネルでもある程度表現できます。しかし、コードの変数にはFigmaだけでは伝えきれない性質がいくつかあります。知っておくだけで、エンジニアとの会話がぐっとスムーズになるポイントです。

## 必須と任意: デフォルト値で使いやすさが決まる

なぜこの区別が重要なのか。コンポーネントのプロパティが10個あるとき、そのすべてが毎回指定必須だとしたら、使うたびに10項目を埋める手間がかかります。

逆に、ほとんどが任意でデフォルト値を持っていれば、使う側は変えたいところだけを指定すればよい。必須と任意の設計は、コンポーネントの使いやすさを直接的に決めます。

![必須と任意: デフォルト値で使いやすさが決まる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-36.png)

必須を最小限にとどめ、よく使われる値をデフォルトに設定しておくことで、8割のユースケースは何も指定しなくてもそのまま使える状態を目指します。

コードでは、変数が必ず渡さなければならないか、省略してもよいかが明確に定義されます。省略できる変数には通常、デフォルト値が設定されています。

たとえば、ボタンコンポーネントの `size` が任意で、デフォルト値が `Medium` であれば、利用者が `size` を指定しなくても中サイズのボタンが表示されます。一方、`label` が必須であれば、テキストなしでボタンを使うことはできません。

Figmaのプロパティパネルには、必須かどうかや省略時のデフォルトを表現する仕組みがありません。すべてのプロパティに常に何らかの値が入った状態で表示されます。

そのため、何がデフォルトで何が意図的な指定なのかが区別できないのです。

これを補うには、Description欄に「デフォルト: Medium」のように明記しておくのがもっともシンプルです。また、何も指定しなかったときの見た目を最初のバリアントとして配置しておくと、利用者がこれがデフォルトかと直感的に理解できます。

ただし、デフォルト値は一度決めたら簡単には変えられません。コードの世界では、デフォルト値を変更すると、明示的に値を指定していなかったすべての箇所で表示が変わります。

`size`のデフォルトを`Medium`から`Small`に変えれば、何も指定していないボタンがすべて小さくなる。影響範囲が広いぶん、デフォルト値の決定はかなり慎重におこなう必要があります。

## 条件付き表示: Figmaとコードでプロパティの数がズレる理由

Figmaでコンポーネントを作るとき、ある要素を表示/非表示にするためにトグルを追加した経験はないでしょうか。エンジニアに「このトグル、コード側では要らないんですよ」と言われて戸惑ったことがあるかもしれません。Figmaの制約とコードの表現力の違いが現れる場面です。

たとえば、カードにサブタイトルを出すかどうかを切り替えたいケースを考えてみます。実はコード側では、この挙動をもっとシンプルに実現できます。

コード側ではサブタイトルのテキストというプロパティが1つあれば十分です。テキストが渡されれば表示し、渡されなければ領域ごと消える。1つのプロパティで中身と表示/非表示を同時に制御できます。

しかしFigmaでは、この挙動を再現するためにサブタイトルを表示するかどうかのトグルとサブタイトルのテキストという2つのプロパティが必要です。コードでは1つで済むことが、Figmaでは2つに分かれるわけです。

こうしたFigmaと実装のプロパティ数のズレは避けられません。大切なのは、このズレがあることをチームで認識し、ルール化しておくことです。

認識が共有されていないと「Figmaと実装でプロパティの数が合わない」という無駄な議論が繰り返されるためです。

![条件付き表示: Figmaでは2つ、コードでは1つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-37.png)

## プロパティ名の先読み: icon問題

ボタンにアイコンを付けられるようにしたいとします。左側にアイコンを1つ置くだけなので、プロパティ名を `icon` にしました。しばらくは問題なく使えます。

ところが数ヶ月後、右側にもアイコンを置きたいという要件が出てきます。右側用のプロパティを追加しようとして手が止まります。`icon` はすでに左側に使ってしまっている。右側を `iconRight` にすると、左が `icon` で右が `iconRight` という非対称な名前になります。かといって既存の `icon` を `iconLeft` にリネームすれば、すでにこのプロパティを使っているすべての箇所を修正しなければなりません。

最初から `iconLeft` と名付けていれば、`iconRight` を足すだけで済んだ話です。将来もう一方が増える可能性を予見できていたかどうかで、後の変更コストが大きく変わります。これは原則の章で触れた経路依存性そのものです。

この「先読み」はアイコンに限りません。ヘッダーだけ作ったあとにフッターが必要になるケース、画像用のプロパティを作ったあとに背景画像との区別が必要になるケースなど、1つだけに見えたものが対になる場面はよくあります。対になる可能性がある要素には、最初から位置や役割を含んだ名前をつけておくと安全です。

さらに、位置を表す語の選び方にも注意が要ります。left / right は物理的な方向を指すため、2つの前提を含んでいます。1つは水平方向であるという前提、もう1つは左から右に読む言語圏であるという前提です。

アラビア語やヘブライ語のように右から左に書く言語では、UIの配置が左右反転します。`iconLeft` と名付けたプロパティが、実際には右側に表示されることになり、名前と見た目が矛盾します。また、レスポンシブデザインでレイアウトの方向が変わる場合にも、left / right は意味を失います。

こうした理由から、物理方向ではなく論理方向で名付ける慣習があります。left / right の代わりに start / end、あるいは leading / trailing を使う方法です。CSSやSwiftUIにもこの考え方に基づいた仕組みが用意されています。

多言語対応の予定がないプロダクトでも、start / end で名付けておくことにデメリットはほとんどありません。将来の可能性を閉じない命名として、頭の片隅に置いておく価値があります。

ここまで、コンポーネントが受け取る設定値——プロパティ——の型と組み合わせを扱いました。次の章では、コンポーネントが取りうる状態の設計に移ります。
