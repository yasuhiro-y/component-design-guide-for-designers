---
title: "変数(1): コンポーネントの変数を解剖する"
---

Figmaのプロパティパネルは、コードの設計図そのものです。パネルに並ぶトグルやドロップダウン、あの一つひとつに型があることを意識したことはありますか？　この章を読むと、エンジニアに「このプロパティ、BooleanですかEnumですか？」と自分から確認できるようになります。型の会話ができるだけで、認識のズレによる手戻りが激減します。

プロパティの型を選ぶことは、コンポーネントの作り手と使い手の間に交わされる契約を定義することでもあります。Booleanは「2つの状態しかない」という約束であり、Enumは「この中から選んでほしい」という約束です。

# プロパティの型を解剖する

![Figma プロパティパネルとコードの対応関係](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-18.png)

ここからは、コンポーネントが外側から受け取る設定値——プロパティ——を詳しく見ていきます。Figmaのコンポーネントプロパティパネルに並んでいるトグルスイッチ、テキストフィールド、バリアントの切り替え。これらはコード上の変数と対応しています。

> **Notice:** この章で「変数」「プロパティ」と呼んでいるのは、コンポーネントに渡す設定値のことです。FigmaのVariables機能（デザイントークンを管理するしくみ）とは別の概念です。混同しやすいので注意してください。

Figmaのプロパティパネルを整理することは、コードの設計図を書くことでもあります。この設計図はAIコード生成の精度にも直結します。型が明確に定義されていれば、AIに渡したときに自社のルールに沿った精度の高いコードが返ってきやすくなります。

プロパティには型（Type）があります。Figmaのプロパティパネルで、トグルスイッチなのか、テキスト入力なのか、バリアントの切り替えなのか——その入力方式の違いが、コードでは型として定義されています。Notionのデータベースを思い浮かべてください。カラムを作るとき、テキスト・数値・チェックボックス・セレクト・日付……と種別を選びます。
あのカラムの種別が、ここでいう型にあたります。

Figmaのプロパティパネルでも同じことが起きています。トグルスイッチはBoolean、バリアント切り替えはEnum、テキスト入力はStringです。Figmaのプロパティパネルではテキスト入力欄に何でも自由に入れられますが、コードの世界では数値の 24 とテキストの "24" は別物です。このプロパティに入る値はテキストなのか、数字なのか、ON/OFFなのかを意識して設計すると、コードとの対応関係が明確になります。

ここでは、Boolean、Enum、String、Number、Dateといった基本の型に加え、配列やオブジェクトといったデータの構造についても解説します。聞き慣れない用語もありますが、ひとつずつFigmaの操作に対応づけていきます。

![プロパティの型: Figma での見え方とコードの対応](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-17.png)

以下の表は全体像です。まずはざっと眺めてみましょう。

| 型      | コードでの書き方（参考）                        | Figmaでの表現             |
| ------- | ----------------------------------------------- | ------------------------- |
| Boolean | `isDisabled: boolean`（ON/OFFの値）             | トグルスイッチ            |
| Enum    | `size: 'S' \| 'M' \| 'L'`（3つの中から1つ選ぶ） | バリアント（Variant）     |
| String  | `label: string`（自由なテキスト）               | テキスト入力              |
| Number  | `count: number`（数値）                         | テキスト入力              |
| Date    | `deadline: Date`（日付）                        | テキスト入力              |
| Array   | `items: Item[]`（データの一覧）                 | `Auto Layout`内の繰り返し |
| Object  | `user: User`（データのまとまり）                | 複数プロパティの集合      |
| Element | `icon: ReactNode`（別の部品を差し込む）         | `Instance Swap`           |

## 汎用ライブラリの変数設計をみてみる

Chakra UIやMUIなどの汎用ライブラリを見漁ったことのある方は、変数の設計が似通っていることに気づいているかもしれません。

実際に並べてみると、どのライブラリも Button・Input・Select・Tag・Switch・Checkbox といった基本部品を揃えており、それぞれが `size`・`variant`・`colorScheme`・`disabled` といった類似のプロパティを持っています。名前やAPIの細部は違っても、設計の骨格は共通しています。

![汎用ライブラリのコンポーネント例: MUI / Chakra UI / Ant Design](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-56.png)

これは偶然ではなく、UIの問題構造が同じだからです。ボタンには見た目のバリエーションとサイズが必要で、入力フィールドにはプレースホルダーと無効状態が必要——こうした要件は言語やフレームワークを問わず共通します。だからこそ、ここから先で扱う変数の型や設計パターンは、特定のライブラリに依存しない普遍的な知識として使えます。

## Boolean: 真偽値

スイッチのON/OFF、はい/いいえの2択です。コードでは`true`/`false`という値が入ります。

Figmaではプロパティパネルにあるトグルスイッチで指定するプロパティです。アイコンを表示するかどうか、読み込み中かどうか、といった存在や状態のオンオフを管理します。

たとえば、`isRequired`（必須かどうか）、`isDisabled`（操作できない状態かどうか）、`showIcon`（アイコンを表示するかどうか）。名前の通り、はい/いいえで答えられる性質をそのままプロパティにしたものです。

### Boolean の命名

Booleanのプロパティ名には2つのルールがあります。

ひとつは否定形を避けること。`isNotDisabled` ではなく `isDisabled`。Figmaでいえば、トグルスイッチの名前を「無効ではない」にするか「無効」にするかの違いです。二重否定は読み手を混乱させるだけです。

もうひとつは動詞で始めること。`is` は状態（`isDisabled`）、`has` はあるかないか（`hasBorder`）、`show` は表示するかどうか（`showIcon`）。プロパティ名を読むだけで、何のON/OFFかがわかります。

### Boolean が増えすぎたら Enum へ

Booleanはシンプルで使いやすい反面、増えすぎると矛盾が生まれます。トグルが3つあればON/OFFの組み合わせは8通り。そのほとんどは、ありえない状態を含んでいます。

たとえば、ボタンのサイズを `isSmall` と `isLarge` という2つのBooleanで管理したとします。どちらもOFFなら通常サイズ。では両方ONになったら？ 小さくて大きいボタンは存在しません。こうした矛盾が生まれる時点で、サイズは最初からEnum（`Small` / `Medium` / `Large` の選択式）にすべきだったということです。

同じことは表示位置にも当てはまります。Figmaのプロパティパネルに「左アイコン表示」「右アイコン表示」の2つのトグルが並んでいて両方ONにできてしまう状態を想像してください。`hasLeftIcon` と `hasRightIcon` を別々に持つとこの矛盾が生じます。これを1つのドロップダウン `iconPosition: 'left' / 'right' / 'none'` にまとめれば、常にひとつだけが選ばれます。これがBooleanからEnumへの移行です。

![Boolean の矛盾: 2つのトグルより1つの Enum](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-42.png)

![Boolean×2 の矛盾 vs Enum×1 のシンプルさ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-75.png)

Booleanを追加するときの確認ポイントです。

- そのON/OFFは本当に2択か？ 将来3択以上に増える可能性はないか
- 他のBooleanと組み合わせたとき、ありえない状態が生まれないか
- Figmaのバリアント（Enum）で表現したほうがシンプルにならないか
- ひとつのコンポーネントにBooleanが3つ以上並んでいないか

もうひとつ知っておきたいのは、Booleanには「まだ決まっていない」がないということです。Figmaのトグルスイッチと同じで、ONかOFFか、必ずどちらかの状態にあります。だからこそ、コンポーネントを新しく作ったとき、そのトグルの初期状態をONにするかOFFにするかをあらかじめ決めておく必要があります。

## Enum: 列挙型

あらかじめ用意された選択肢の中からひとつだけ選ぶ形式です。Notionデータベースのセレクトカラムと同じ考え方です。

FigmaのVariant（バリアント）がこれにあたります。たとえば、`size` なら `small` / `medium` / `large` のどれか、`variant` なら `primary` / `secondary` のどれか、というように選択肢をあらかじめ定義しておきます。Figmaのバリアントでサイズ = `S` / `M` / `L`を選ぶ操作を思い浮かべてください。プロパティパネルのドロップダウンから選ぶあの操作そのものが、Enumの概念です。

Enumの価値は、あえて制約することにあります。

String型は何でも入力できますが、自由すぎるとチームのなかでバラつきが生まれます。Enumにして選択肢を絞ることで、迷う場面が減り本質に集中できるようになる。選択肢の体系そのものが、コンポーネントの使い方を暗に伝えてくれます。

制約は、急いでいるときにこそ効きます。デッドライン直前、人は最も簡単な道を選びがちです。選択肢が自由すぎると「とりあえず」の判断が積み重なり、一貫性が崩れていく。あらかじめEnumで選択肢を整えておくことは、正しい選択を最も簡単にする環境設計です。

たとえば、余白をNumber型の自由入力にすると、14px、16px、18px…と微妙に違う値が画面ごとに増えていきます。これをSpacing Tokenにして `Small` / `Medium` / `Large` しか選べなくすれば、誰が組んでもリズムが整います。トークン化前は画面ごとに5種類以上の余白値が混在していたのが、トークン化後は3種類だけ——余白に関する議論が大幅に減るのは、デザインシステム導入のわかりやすい成功指標です。

### 選択肢の命名: 意味で名付ける

Enumの選択肢は、見た目ではなく意味で名付けます。よくあるのがこのようなものです。
みてのとおり、MECEであったり、粒度感がそろっていたりすることがわかります。
誰でも心当たりがあるかもしれませんが、選択肢の命名は重要である割にデザイナーが手癖でつけてしまいがちです。今は問題なくても、次の人が困る命名は克服しましょう。

| プロパティ  | 選択肢の例                            |
| ----------- | ------------------------------------- |
| size        | small / medium / large                |
| variant     | primary / secondary / outline / ghost |
| status      | success / warning / error / info      |
| colorScheme | blue / green / red / gray             |
| placement   | top / right / bottom / left           |
| intensity   | solid / subtle / outline              |
| orientation | horizontal / vertical                 |
| shape       | circle / square / rounded             |

それでは、個別の性質をもつ選択肢設計の論点をみていきます。

### Tシャツサイズ: 拡張可能なスケール

`size` の選択肢として広く使われているのがTシャツサイズです。`small` / `medium` / `large` という呼び方で、省略形なら `s` / `m` / `l`。基準となるサイズを `medium` に置き、そこから上下に展開していきます。

拡張が必要になったとき、上方向は `x-large` → `2x-large`（`xl` → `2xl`）、下方向は `x-small` → `2x-small`（`xs` → `2xs`）と伸ばせます。最初から全段階を用意する必要はありませんが、この拡張パスを頭に入れておくだけで、命名の破綻を防げます。

もうひとつ意識しておきたいのが、最も代表的な値をスケールの中に正しく位置づけることです。いま選択肢がひとつしかなくても、その値がスケールのどこにあるかを考えておく。よくある失敗は、なんとなく最初に作ったサイズを `size = default` と名付けてしまうパターンです。1年後には `default` / `small` / `smaller` / `tiny` の4段階に膨れ上がり、`default`が`large`なのか`medium`なのか答えられない——こうした事態は珍しくありません。

最初に作るものがひとつであっても、スケールの中での位置を決めて`medium`や`large`というように体系を前提として名付けます。`Default`はスケール上の位置を表さない名前です。だからこそ、最も代表的な値には`medium`という明確な位置づけを与えておきましょう。

### 色のセマンティクス: 見た目ではなく役割で名付ける

色についても同じことが言えます。`variant` = `Blue` としてしまうと、ブランドカラーが変わったときやダークモードに対応したときに名前と実際の色が矛盾します。

![色のセマンティクス: 見た目ではなく役割で名付ける](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-61.png)

色は意味で名付けると堅牢です。`variant` = `Primary` や `variant` = `Danger` のように、その色が果たす役割で呼ぶことで、中身の色が変わっても名前が壊れません。

なぜ見た目の色名が問題になるのか。プロダクトのライフサイクルの中で、色は思った以上に変わります。ブランドカラーの刷新、ダークモードの追加、アクセシビリティ改善によるコントラスト調整——いずれも色の値が変わる契機です。`variant: red` と名付けていたものが紫に変わったとき、名前と現実が矛盾し、コードとデザインの対応関係が壊れます。`variant: danger` であれば、色が何色になろうと意味は通ります。

この考え方はデザイントークンの設計にも直結します。トークンの章で扱ったように、`Tag`・`Badge`・`Callout` が同じセマンティックカラーを参照していれば、トークンの値をひとつ変えるだけですべてのコンポーネントに反映されます。逆にリテラルな色名で管理していると、コンポーネントごとに値を追いかける必要が生じます。

ボタンもバッジもタグも、同じセマンティックカラー体系に基づいて名付けることで、コンポーネント間の一貫性が保たれます。

### 設計の確認ポイント

- 選択肢の名前は見た目ではなく意味で付けているか（`Red` ではなく `Danger`）
- 将来の拡張を見越した命名になっているか（新しい選択肢を追加しても既存の名前が不自然にならないか）
- 選択肢の数は適切か（7つ以上あるなら設計を見直すサイン。選択肢が多すぎると使う側が迷い、管理も煩雑になります）
- 同じ意味の選択肢が別の名前で重複していないか

### 実践例: Tag と Badge

Enumの力が特に発揮されるのが、`Tag`、`Badge`、`Callout` のように色とサイズの組み合わせをまとめて管理するコンポーネントです。

実際のライブラリでも、Enumの設計が見た目の似たコンポーネントを整理する武器になっています。Figmaでいえば、`Badge`と`Tag`の両方に`size`（`S` / `M`）と`colorScheme`（`info` / `success` / `warning` / `error`）というバリアント軸を揃えておき、`Tag`にだけ「×ボタン表示」のトグルを追加する設計です。

[Chakra UI](https://chakra-ui.com/)はまさにこの構造で、[`Badge`](https://chakra-ui.com/docs/components/badge)と[`Tag`](https://chakra-ui.com/docs/components/tag)が同じ色の体系（`colorScheme`）と表現の種類（`variant`）——塗りつぶし（`solid`）、薄い背景色（`subtle`）、枠線のみ（`outline`）——を共有しつつ、`Tag`にだけ閉じるボタンの有無を切り替えるBooleanが加わっています。

色と強度の軸は共通の設計言語で揃え、機能の違いだけをBooleanで表現する。このパターンは自社のコンポーネント設計でもそのまま応用できます。

![Chakra UI: Badge と Tag の colorScheme バリエーション](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-16.png)

たとえば、`Tag`コンポーネントを考えてみてください。情報の種類を表す色（`info`: 青、`success`: 緑、`warning`: 黄、`error`: 赤）と、表示サイズ（`small` / `medium`）の掛け算になります。

これを色とサイズの2つのEnumで管理すれば、Figmaのバリアントは2軸のマトリクスになり、構造が明快です。

## String: 文字列

ボタンのラベルや入力欄のプレースホルダーなど、画面に表示されるテキストデータです。

ここでデザイナーが考えるべきはデータの不在です。もし文字列が空だったら、その領域は詰めるのか、あるいはプレースホルダーを出すのか。ユーザー名が極端に長かった場合、… で省略するのか、折り返すのか。これらはすべてプロパティの仕様として定義しておきたいところです。

![String型: テキストの振る舞い6パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-33.png)

文字列型のプロパティを追加するときに確認しておきたいことがあります。

- 空のとき何が起きるか決めたか（領域を詰める？ プレースホルダーを出す？）
- 最大文字数を超えたときの処理を決めたか（省略記号、折り返し、スクロール）
- 改行を含む可能性はあるか（1行テキストか複数行テキストか）
- 本当に自由入力が必要か（選択肢が決まっているならEnumにできないか）

日本語だけでデザインしていると見落としがちですが、同じ意味のテキストでも英語になると幅が1.5〜2倍に膨らむことがあります。たとえば、日本語で「確認」と表示していたボタンが、英語では「Confirm」になります。横幅が固定されたボタンでは、テキストが溢れるか省略されて読めなくなります。

多言語対応の予定がなくても、テキストの長さが変動する前提でコンポーネントを組んでおくことは、堅牢な設計につながります。

たとえば、アイコンとテキストが横に並ぶボタンで、テキストが長くなったときにどうするか。アイコンを非表示にしてテキストを優先するのか、テキストを省略記号で切るのか、折り返して高さを広げるのか。これはコンポーネントの仕様として事前に決めておきたい判断です。

もうひとつ気をつけたいのが、テキストの縦方向の振る舞いです。Figmaのテキストボックスは `Auto Height` に設定すれば中身に合わせて高さが変わりますが、コードでも同じ挙動になるかはフレームワークや実装方法によって異なります。行の高さ（Line Height）がコンポーネント全体の縦幅にどう影響するかは、デザインとコードで差が出やすいポイントです。

## Number: 数値

バッジのカウント数（通知が3件あるときの「3」）や評価スコア（星4.5）など、数値を示すデータです。

![Number型: 数値の表示ルール](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-45.png)

文字列と数値の違いは、スプレッドシートを思い浮かべるとわかりやすいでしょう。

セルに数字を入れると右寄せになり、テキストを入れると左寄せになります。あの挙動が示すとおり、数字と文字列は根本的に異なるデータ型です。数値は合計や比較、フォーマット変換などの計算ができるのに対し、文字列はあくまで文字の並びにすぎません。

999+ のように上限を超えた場合の表示ルールや、0のときに非表示にするかどうかといった仕様も、数値型のプロパティに付随する重要な設計判断です。

数値型のプロパティを扱うときに確認しておきたいことです。

- 上限・下限を超えたときの表示を決めたか（999+、0件のときなど）
- 0のとき非表示にするか、0と表示するか
- マイナスの値はありえるか（ポイント残高、差分表示など）
- 単位の表示はコンポーネントの責任か、外から渡すか（円、件、%）

## Date: 日付と時刻

カレンダーの予定日、メッセージのタイムスタンプ、クーポンの有効期限。日付や時刻を扱うデータです。
これはFigmaでは表現することができないため、Stringのプロパティで扱うことになるでしょう。

私たちが画面上で見ている 2月17日 や 3日前 といった表示は、裏側では 2026-02-17T14:00:00Z のような機械が読む形式のデータを変換したものです。スプレッドシートでも、セルに日付を入れるとカレンダー形式で表示されますが、中身は表示を変えても意味が維持される日付データですよね。それと同じで、日付データには裏側のデータと画面に出す見た目という二層構造があります。

![Date型: 日付の表示形式と設計判断](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-46.png)

日付型のプロパティを設計するときの確認ポイントです。

- 日付のフォーマットはコンポーネント内部で決めるか、外部で決めてテキストとして渡されるか
- タイムゾーンの考慮は必要か（海外ユーザーがいるサービスでは要注意）
- 相対表示（3日前）と絶対表示（2月17日）のどちらを使うか、切り替えるか
- 未来の日付と過去の日付で表示を変える必要はあるか（締め切りのカウントダウン、イベント開始までの残り時間など）

ここまでの5つの型（Boolean / Enum / String / Number / Date）で、コンポーネント設計に必要な基礎は揃いました。以降のArray・Object・Elementは、複雑なデータを扱うときに必要になる発展的な型です。今すぐ必要でなければ次の章に進んでも構いません。読み進める方のために、ここからはデータの構造（まとまり方）に関する型を見ていきます。

ひとつ実践的なコツを補足します。たとえば、更新日: 2026/01/01 と表示するUIがあるとき、Figma上のプロパティは 2026/01/01 のテキストだけにし、更新日というラベルはコンポーネント内に固定しておくと、実装との対応が明確になります。

## Array: 配列（リスト）

同じ種類のデータが複数あるとき、コンポーネントにはそのリストをまるごとプロパティとして渡します。タグの一覧、通知リスト、メニューの項目——こうしたケースです。

Figmaでいえば、同じコンポーネントを`Auto Layout`内に繰り返し配置する操作にあたります。コードではこれを配列として扱います。

![配列: 同じテンプレートに異なるデータを流し込む](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-62.png)

同じ器に異なるデータを流し込む——これが配列型のUIの特徴です。各要素のテキストの内容、`Tag`の有無、ステータスの色はそれぞれ異なりますが、コンポーネント自体は同じものが使い回されます。

![Array型: リストの4つの状態](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-34.png)

ただし、Figmaでは3件分のデータを置くと3件で固定されますが、実際のアプリでは0件になったり100件になったりします。デザイナーが意識しておきたいのは、0件・1件・大量にあるときのそれぞれの見え方です。

- 0件のとき何を表示するか（空状態のデザインは用意したか）
- 上限はあるか（無限に増えるのか、最大表示件数を設けるか）
- 大量にあるとき、無限スクロールかページネーションか
- 並び順は固定か、ユーザーが変えられるか

## Object: オブジェクト（データのまとまり）

名前・アイコン・ステータスのような、複数の情報がひとかたまりになっているケースです。

Notionでいえば、データベースの1行がこれにあたります。ユーザーという1行に、名前・アイコン画像・ステータスがセットで入っているイメージです。

![オブジェクト: 複数の値をひとかたまりで渡す](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-63.png)

たとえば、ユーザーカードに渡すユーザーというデータを考えてみてください。名前、アイコン画像、ステータス。これらをバラバラのプロパティとして渡すこともできますが、ドメインコンポーネントではユーザーの情報一式としてまとめて渡すほうが自然です。

Figmaのプロパティパネルでは、こうしたデータのまとまりを直接表現する方法がありません。名前・アイコン・ステータスをバラバラのプロパティとして並べるしかないのです。しかし、コード側ではユーザーというひとつのまとまり（オブジェクト）として渡せます。

デザイナーが意識しておきたいのは、このコンポーネントに渡すデータは、個別の値なのか、まとまりなのか、という点です。`Avatar`なら画像URLだけで十分（個別の値）。`UserCard`ならユーザーの情報一式が前提（まとまり）。この判断が、コンポーネントを汎用にするかドメイン専用にするかの分かれ道です。

Figmaのプロパティパネルで見比べてみると、この違いがはっきりします。`Avatar`のパネルには`image`、`altText`の2項目だけ。一方`UserCard`には`userName`、`userImage`、`rating`、`status`、`isVerified`とずらりと並びます。

プロパティが20個並んだコンポーネントは、使う側にとって何をどう設定すればいいかわからないものになります。逆に粒度が粗すぎると汎用性がなくなります。いま手元のFigmaで、プロパティが10個を超えているコンポーネントを探してみてください。それはドメイン専用として認識すべきサインかもしれません。

オブジェクトの中で特に気をつけたいのは、データの一部が欠けているケースです。ユーザー名はあるけどアイコン画像がない、評価スコアがまだ付いていない。こうした歯抜けのデータにどう対応するかを、コンポーネントの仕様として決めておく必要があります。

また、オブジェクトをまるごと受け取る設計は、そのコンポーネントが特定のドメインに紐づいていることを意味します。コンポーネント分割の章で触れたように、汎用コンポーネントは個々の値をバラバラに受け取り、ドメインコンポーネントはデータ一式をまとめて受け取るのが基本です。

Objectを受け取るコンポーネントを作ろうとしているなら、それはドメインコンポーネントとして位置づけるのが自然でしょう。

![Object型: 個別の値 vs データのまとまり](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-47.png)

## Element: 要素

ここまでの型（Boolean、Enum、String、Numberなど）はすべて、テキストや数値といったデータを渡すものでした。しかし、プロパティに渡したいのがデータではなく、別のコンポーネントそのものというケースがあります。

![Button のスロット構造: 差し込み口を設けることでバリアント爆発を防ぐ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-04.png)

Figmaで考えるとわかりやすいです。`Instance Swap Property`を使って、ある箇所にアイコンを差し込んだり、`Avatar`に差し替えたりします。

コードの世界ではこの仕組みをスロット（slot）と呼びます。Reactでは`ReactNode`あるいは`JSX.Element`型、SwiftUIでは`@ViewBuilder`、Flutterでは`Widget`型としてそれぞれ表現されます。ここでは便宜上Element型と総称します。好きなものを差し込める口を設けておく設計です。

たとえば、カードの説明文を表示する箇所を考えてみてください。通常はテキストを渡せば十分です。しかし、テキストの一部をリンクにしたい場合はどうでしょうか。String型ではここからここまでがリンクという情報を表現できません。リンクを含んだUIのかたまりをまるごと渡す必要があります。

あるいは、リストアイテムの左側に置くものが、ある画面ではアイコン、別の画面では`Avatar`。こうした場合にスロット（Element型のプロパティ）があれば、何を差し込むかは利用者に委ねられます。

スロットの威力がもっともわかりやすいのは、バリアントの爆発を防げる点です。

![バリアント爆発 vs スロット: 4つ作るか、1つで済ませるか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-71.png)

アイコン付きボタンの例で考えてみましょう。デザイナーは `LeftIcon` / `RightIcon` / `BothIcons` / `NoIcon` という4つのバリアントを作りがちです。しかし、スロットの発想を使えば、ボタンの左右に好きなものが入るエリアを用意するだけで済みます。アイコンでも、バッジでも、何も入れなくてもよい。

Figmaでは、`Instance Swap Property`を使ってスロットを表現します。設計のポイントは2つです。

- 何も入れないを選択肢に含める。空のプレースホルダーコンポーネントを候補に入れておけば、アイコン不要な場面でも対応できる
- 差し込める対象を制約する。`Instance Swap Property`で差し替え候補を同じカテゴリに限定し、意図しない使い方を防ぐ

設計時に考えておきたいのは、その箇所にテキストを渡すだけで本当に十分か、それとも将来的にUIのかたまりを渡す必要が出てこないか、という点です。最初はStringで足りていても、後からリンクやアイコン付きテキストが必要になるケースは少なくありません。

![Element型（スロット）: 差し込み口で中身を自由に](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-48.png)

コンポーネントを柔軟にする方法は2つあります。プロパティ（設定値）をどんどん増やす方法と、スロットのように小さな部品を差し替える方法です。前者をConfiguration（設定型）、後者をComposition（組み合わせ型）と呼びます。プロパティが10個、20個と膨らんできたら、それはスロット（Composition）への切り替えどきです。

![Configuration vs Composition: 設定の山か、組み合わせか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-50.png)

ここまで個々の型を見てきました。次の章では、これらの型が複数組み合わさったときにどう振る舞うか——プロパティの設計と運用に踏み込みます。
