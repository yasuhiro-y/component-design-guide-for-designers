---
title: "現実的な問題への対処: 壊れ方を設計する"
---

# 運用で直面する課題と対処法

ここまではコンポーネントをどう設計するかを扱ってきました。ここからは、設計したコンポーネントを運用する中で直面する現実的な課題と、その対処法を扱います。

原則の章で触れた経路依存性——初期の選択が未来を制約する性質——がある以上、完璧な初期判断には限界があります。それでも、変更コストを下げる手立てはあります。ここでは3つの防御策を扱います。古いものを安全に終わらせるライフサイクル管理、既存の利用者を壊さない変更の作法、そして100%準拠を求めない例外の設計です。

![安全な変更と破壊的変更: 増やすのは簡単、変えるのは大変](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-27.png)

# 安全な変更と破壊的変更: Figmaの修正がコードを壊すとき

コンポーネントのライフサイクルと密接に関わるのが、変更の安全性という概念です。

まず大前提として、増やすのは簡単で、減らすのと変えるのは大変です。棚に本を1冊追加するのは簡単ですが、すでに置いてある本の背ラベルを全部貼り替えるのは大変な作業です。

コンポーネントの変更もまったく同じ構造をしています。デザイナーがFigma上で気軽におこなう修正が、コード側では既存の実装を壊す破壊的変更（Breaking Change）になり得ます。

この感覚をデザイナーが持っているかどうかで、エンジニアとの連携のスムーズさが大きく変わります。

## 追加は安全、変更と削除は危険

安全な変更とは、既存の実装に影響を与えない変更のことです。新しいバリアントの追加、新しい任意プロパティの追加がこれにあたります。たとえば、ボタンに `variant` = `warning` を新しく追加しても、いま使われている `primary` や `secondary` のボタンは何も変わりません。

一方、破壊的変更とは、既存のコードがエラーを起こしたり、意図しない見た目になったりする変更です。具体的には、プロパティ名の変更、`Enum`の選択肢の削除や名称変更、新しい必須プロパティの追加などが該当します。Figma上で typo を直したいだけだからとプロパティ名を変えると、コード側ではそのプロパティを参照しているすべての箇所でエラーが起きます。

この区別を知っていると、「プロパティ名を変えたいけど今はやめておいて、次のメジャーアップデート（V2）で新旧並行稼働させながら移行しよう」といった判断ができるようになります。

エンジニアがよく口にする「後方互換性」とは、まさにこの話です。冒頭の原則で述べた慣習（Convention）と直結しています。既存を壊さない変更ができる設計は、新メンバーが安心して機能を追加できる土台になります。

Figmaではプロパティを自由に変更でき、インスタンスは自動で追従しますが、コードの世界ではそうはいきません。この非対称性を意識しておくだけで、変更の提案のしかたや移行計画の立て方が変わってきます。

増やすのは安全、変えるのは大変。ソフトウェア設計にはこれに近い考え方として開放閉鎖の原則（OCP: Open-Closed Principle）があります。拡張には開かれているが、修正には閉じられているべき、という設計指針です。コンポーネント設計でも、新バリアントの追加は歓迎しつつ、既存プロパティの変更は慎重に——という姿勢に通じます。

# 例外を許容する設計: 100%準拠は目指さない

デザインシステムに100%準拠を最初から目指すと、運用の負荷が高くなりすぎることがあります。結果として、システム自体が使われなくなるケースも珍しくありません。

90%の定型と10%の例外を最初から織り込んでおくくらいがちょうどよいでしょう。FigmaとコードのUIが完全一致している必要もありません。インターフェース（プロパティの名前と型）が一致していることのほうが、チームの共通理解にとってはるかに重要です。

未整備な規則は後から一括で差し替えしやすいように作っておくこともできます。

たとえば、色の値をハードコードせずトークンで管理しておけば、後から一括変更できます。コンポーネント化されていない要素をいつコンポーネント化するかの基準も決めておくとよいでしょう。「3回以上同じUIが登場したらコンポーネント化を検討する」のようなシンプルなルールで十分です。

# 既存コンポーネントでは理想のデザインが実現できないとき

デザインシステムを運用していると、ありもののコンポーネントではやりたいデザインができない、という場面によく出くわします。

このとき、FigmaでいきなりDetach（コンポーネントとの紐付けを解除すること）してゼロから作り直すのではなく、段階的に検討できるオプションを整理しておくと、チーム全体の判断がブレにくくなります。

判断の軸が共有されていれば、人によって対応が変わる問題を防げるためです。

## 4つの選択肢

1. 既存コンポーネントの組み合わせで解決できないか？ まず試すべきは、今あるコンポーネントの組み合わせやスロットの活用で目的を達成できないかの検討です。
2. バリアントやプロパティの追加で対応できないか？ 既存コンポーネントに新しいバリアントやプロパティを足すことで、ユースケースをカバーできることがあります。ただし、1つのコンポーネントに機能を詰め込みすぎると複雑になるので、追加が妥当かどうかはチームで判断します
3. 新しいコンポーネントとして切り出すべきか？ 既存とは明確に目的が異なるなら、別のコンポーネントとして新設するのが正解です。その際は命名やレイヤーの配置も含めて設計します
4. 一回限りの例外として許容するか？ 一度きりのキャンペーンページや実験的なUIなら、コンポーネント化せずに個別対応と割り切る選択肢もあります。ただし、同じ例外がN回発生したらコンポーネント化を検討する、というルールをセットにしておきます

このフローをチーム内で共有しておくだけで、サイレントなDetachが減り、デザインシステムへのフィードバックが仕組みとして回るようになります。

![既存コンポーネントで実現できないとき: 4つの選択肢](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-43.png)

ただし、こうしたグレーゾーンはデザイナー間で連携せずにデザインシステムから外れた実装が増える原因になりがちです。例外への対処はしっかり共有・議論し、論点を資産にしていく姿勢をチーム全体で持ちたいところです。

デザインシステムから外れた実装が発生したとき、それを失敗と見なすかデータと見なすかで、チームの文化は大きく変わります。このコンポーネントだけ使えなかったという声は設計の盲点を示していますし、毎回カスタマイズが必要だったというパターンは新しいバリアントの候補を教えてくれています。逸脱を罰するのではなく、逸脱からシステムを改善するフィードバックループを回すこと。違反を取り締まる「トークン警察」ではなく、正しい選択が自然にできる環境を設計することが、強制よりもはるかに高い準拠率につながります。

生態系になぞらえれば、Detachされたコンポーネントは「突然変異」です。突然変異のすべてが有害なわけではありません。有用な変異はシステムに昇格し、そうでないものは淘汰される。「これを使いなさい」と指示するだけの規範的なシステムより、「これを組み合わせて新しいものも作れる」と可能性を開く生成的なシステムのほうが、こうした進化を受け入れやすくなります。デザインシステムは石碑ではなく生態系です。

![デザインシステムの進化サイクル](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-51.png)

次にコンポーネントを変更するとき、エンジニアに「これは破壊的変更になりますか？」と聞いてみてください。その一言で、移行計画の議論がスムーズに始まります。

ここまで、コンポーネントの運用で直面する現実的な課題を扱いました。ここからは視点を変えて、コンポーネントが外側から受け取る設定値——プロパティ——の設計に踏み込みます。

# コンポーネントのライフサイクル: 終わらせる設計

デザイナーがコンポーネントの廃止プロセスを知っておくべき理由は、Figma上のマスターコンポーネントを消すとき、それがどこに影響するかを判断できるようになるためです。

コンポーネントは作ることに目が行きがちですが、システム運用で本当に難しいのは捨てることです。終わらせるタイミングは誰も教えてくれません。

プロダクトが成長すれば、コンポーネントは必ず古くなります。そして、実装では、古い方を残したまま新しいものを追加し、徐々に移行することがよくおこなわれます。

新しいボタンを作ったとき、古いボタンをどう扱うか？

ここに方針がないと、使われなくなったコンポーネントがゾンビのように残り続けます。新メンバーがこれ使っていいんですか？と迷うことになります。

## 非推奨の告知と削除

もう使わないでねという意思表示をシステムに組み込んでおく。Figmaなら、コンポーネント名の先頭に [Deprecated]（非推奨：もう使わないでねという印）をつけたり、説明欄に代わりの `NewButton` を明記したり、背景色を目立つ色にする方法があります。コード側でも同様の非推奨マークを付けることで、使おうとしたときに警告が出るしくみがあります。

たとえば、古い `ListItem` と新しい `ListItemV2` が両方存在しているとします。[Deprecated] マークがなければ、新しくチームに入ったデザイナーは2つを見比べて、どちらを使うべきか悩みます。そして多くの場合、慣れている古いほうを選んでしまう。こうして移行が進まなくなります。

[Deprecated]マークなしで新旧コンポーネントを並行運用した結果、1年後に`ListItem`（初代）と`ListItemV2`（改良版）と`NewListItem`（実験版）の3つが共存していたこともあります。新メンバーは最も新しそうな名前を選びますが、実は最新版は`ListItemV2`で、`NewListItem`は実験的に作られて放置されたものでした。

作る責任と同じくらい、終わらせる責任を持つこと。これがデザインシステムを長く健全に保つためのポイントです。

![コンポーネントのライフサイクル](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-22.png)
