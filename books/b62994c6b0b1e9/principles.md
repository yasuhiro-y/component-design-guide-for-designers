---
title: "原則: コンポーネントライブラリがめざすもの"
---

Figma（あるいはSketch）のおかげで、デザイナーもコンポーネントの概念には馴染んできたのではないでしょうか。

コンポーネントという言葉は広い意味で使われます。ソフトウェアのモジュール、ハードウェアの部品、ビジネスプロセスの構成要素——いずれも「コンポーネント」と呼ばれることがあります。
この記事では、UIを構成する再利用可能な部品に限定して扱います。Figmaのコンポーネント機能で作るマスターコンポーネントとインスタンスの関係や、コードの関数コンポーネントがこれにあたります。

なぜ私たちはコンポーネントという単位で考えるのでしょうか。

それは、プロダクトを変更しやすくし、一貫性を保つためです。

Kevin Muldoonは[What Design Systems Actually Do](https://www.designsystemscollective.com/what-design-systems-actually-do-ea8a3daba32a)の中で、デザインシステムが提供する価値を間接化・カプセル化・制約・意味の符号化・合成・慣習という6つの抽象化で整理しています。この章では、その6つを土台にデザインシステムの考え方を紹介します。これらを押さえておくと、後の章で登場するプラクティスの背景が見通せるようになります。

これらは独立したチェックリストではなく、互いに補強し合い、ときに緊張関係を生む体系です。たとえば、制約は判断の負荷を下げますが、強すぎると合成の自由度を損ないます。カプセル化は複雑さを隠しますが、隠しすぎると慣習の形成を妨げます。このバランス感覚こそが、原則を現場に適用する際の要諦です。

# 間接化（Indirection）: 一箇所を直せば全部直る

トークンやマスターコンポーネントを介して、変更を一箇所に集約する仕組み。これが間接化です。「再利用性」と「変更のしやすさ」は、同じメカニズムの表と裏です。

同じものを何度も作らない。一度作った品質をどこでも再現できる——これはユーザー体験の安定に直結します。Figmaでマスターコンポーネントを更新すれば、すべてのインスタンスに変更が反映される。コードでも同様です。ボタンの押し心地やエラーの表示方法が画面ごとにバラバラだと、ユーザーは使うたびに学び直す必要があります。

組織の視点で見れば、コンポーネント化はコスト削減であると同時に、品質への投資にレバレッジをかける仕組みです。共通のコンポーネントがなければ、同じUIを作るたびにデザイナーごとの判断が入り、品質のばらつきを引き起こします。組織として決めたデザインをコンポーネントに落とし込んでおけば、誰が使っても同じ品質が再現でき、特定のデザイナーへの依存もなくなる。

さらに重要なのは、あるデザイナーやエンジニアが磨き上げた優れた設計判断が、コンポーネントを通じて組織全体に伝播するという点です（あるいは逆もしかりですが――）。アクセシビリティへの配慮、インタラクションの細やかさ、エッジケースへの対処——こうした品質は、個々の画面を作るたびにゼロから積み上げるのでは到底行き渡りません。コンポーネントに一度閉じ込めてしまえば、それを使うすべてのユースケースが恩恵を受けます。

たとえば、ブランドカラーを青から赤に変更するとします（別の意味で大変ですね！）。バラバラに実装されていたら、ボタンのある画面すべてをひとつずつ直さなければなりません。コンポーネントで管理されていれば、トークンの値をひとつ書き換えるだけで済みます。

実際にはブランドカラーの全面変更より、プライマリボタンの角丸を8pxから12pxに統一する、フォントサイズのベースを14pxから16pxに上げるといった地味な変更のほうが頻繁に起こります。こうした変更も、コンポーネント化されていれば一箇所の修正で全画面に反映できます。
デザイナーが少人数でも大規模なプロダクトを運用できるのは、このレバレッジが効いているからです。同じUIを1から作り直す工数が減り、新しい機能の開発に時間を使えるようになります。

![間接化: 1箇所の変更がすべてに届く](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-23.png)

Nathan Curtisは「[And You Thought Buttons Were Easy?](https://medium.com/eightshapes-llc/and-you-thought-buttons-were-easy-26eb5b5c1871)」の中で、ボタンひとつをデザイン・実装・テストするコストを$20,000（300万円）と見積もり、50チームがそれぞれ作れば$1,000,000（1億5000万円）になると試算しています。
（単価の設定が極端なので、1/10程度でイメージしたらよいかと思いますが、考え方としてはこういうことです）

間接化は、このコストを1回分に圧縮する仕組みです。そして圧縮されるのはコストだけではありません。1チームが丁寧に作ったコンポーネントを50チームが使えば、最高の品質もまた50チームに届きます。

# カプセル化（Encapsulation）: 複雑さを隠す

内部の複雑さを隠し、使う側にはシンプルなインターフェースだけを見せる。これがカプセル化です。ひとことで言えば、**ひとつの部品にひとつの責任を持たせること**でもあります。

ボタンを例に考えてみましょう。ラベルと背景色だけのシンプルな部品に見えますが、その裏には膨大な設計判断が隠れています。`Hover`・`Pressed`・`Disabled`・`Focus`のインタラクション状態、`primary`・`secondary`・`destructive`のバリアント、アイコンの有無と位置、ライト/ダークテーマ——これらの組み合わせだけで数百にのぼります。カプセル化されたボタンコンポーネントは、この複雑さを隠して「variant と size を選ぶだけ」にしてくれます。

![ボタンの複雑さ: シンプルに見えて設計判断の山](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-55.png)

たとえば、`UserCard`コンポーネントの中に、ユーザーデータを取得するロジックが埋め込まれていたとします。画面上ではきれいに動きます。しかし、同じカードを別の画面で「お気に入り一覧」に使いたくなったとき、データ取得先が決め打ちになっているので使い回せません。見た目だけ欲しいのに、データ取得のロジックがくっついてくるからです。

結果として、ほぼ同じ見た目の`UserCard2`が生まれます。この種の「似て非なるコンポーネント」の増殖は、カプセル化が崩れている兆候です。

もし`UserCard`が「受け取ったデータを表示する」ことだけに責任を持ち、「どこからデータを取ってくるか」を呼び出す側に任せていれば、どの画面でもそのまま使い回せます。Figmaでいえば、マスターコンポーネントが見え方を決め、インスタンス側がテキストや画像を差し替える関係と同じです。

この考え方があると、Figmaで修正したとき何に影響するかが予測でき、エンジニアに聞く前に安全な変更範囲を判断できます。バグ修正の影響範囲が局所化され、ある画面を直したら別の画面が壊れた、という事故を防げます。

## 3つの分離レイヤー

カプセル化は、コンポーネント設計のさまざまな場面で顔を出します。この記事では、以下の3つのレイヤーを順番に扱っていきます。

![カプセル化: 3つの分離レイヤー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-24.png)

- **見た目とデータの分離**: コンポーネントは表示に専念し、どんなデータを取ってきて渡すかは呼び出す側が担う
- **構造とスタイルの分離**: 骨組みと見た目の装飾を切り離す。後述するHeadless UIの思想。[Shadcn/ui](https://ui.shadcn.com/)はこの分離をライブラリレベルで体現した実例で、[Radix UI](https://www.radix-ui.com/primitives)が提供する骨組み（振る舞い＋アクセシビリティ）に[Tailwind CSS](https://tailwindcss.com/)で見た目を上書きする構成になっている
- **汎用とドメインの分離**: どこでも使える部品（`Button`や`Avatar`）と、特定の機能に特化した部品（`JobCard`）を混ぜない。コンポーネント分割の章で詳しく扱う

`UserCard`ひとつをとっても、3つの分離が見えます。見た目（レイアウトや色）とデータ（ユーザー名やアイコンURL）は分離すべきですし、骨組み（`Auto Layout`の構造）とスタイル（色・角丸）も分けられます。`UserCard`自体はドメインコンポーネントですが、その中で使う`Card`（枠）や`Avatar`（アイコン）は汎用コンポーネントです。

責任を分けておくからこそ、片方だけを変えたり、別の組み合わせで再利用したりできます。レイアウトの章で扱う、コンポーネントの中身（`padding`）と配置（`margin`）を分ける話も、カプセル化そのものです。

# 制約（Constraint）: 選択肢を絞り、判断の負荷を下げる

レストランで「10品のコース」と「何でもお作りします」のどちらが注文しやすいでしょうか。選択肢を意図的に絞ることで、判断の負荷を下げる。これが制約の原則です。

色を例にとりましょう。ディスプレイが表現できる色は約1680万色です。しかし、プロダクトで使う色が1680万色あったら、誰もデザインの一貫性を保てません。10色程度のセマンティックカラーに絞ることで、どの画面でも意味のある配色が再現できるようになります。

スペーシングも同じです。`margin`や`padding`に「好きな数字を入れてよい」とすると、14px, 17px, 23pxのような半端な値が乱立します。4/8/12/16/24/32のスケールに制約すれば、誰が作っても整ったリズムが生まれます。

![制約: 選択肢を絞り、判断の負荷を下げる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-53.png)

変数の章で扱うプロパティの型も制約の一形態です。Booleanは2択、EnumはN択、Stringは自由入力。型が厳しいほど誤用が減り、型がゆるいほど柔軟性が増します。

[Ross Horbiの試算](https://medium.com/@rosshorbi/how-i-created-a-design-system-for-buttons-cfebbc55106e)によると、とあるボタンの取りうる姿の組み合わせはサイズ4段階 × アイコン有無4パターン × スタイル5種 × 状態5種 × テーマ2種 = 960バリアントに達します。制約なしにすべてを自由設計すると破綻するのは明白です。

ただし、制約が強すぎると例外的なユースケースに対応できなくなります。制約と柔軟性のバランスをどうとるか。後の章では柔軟性と秩序のバランスについても考えます。

# 意味の符号化（Semantic Encoding）: 見た目ではなく意味で名付ける

Figmaで赤い塗りの四角形を描いたとします。これは「エラー表示」なのか「セール価格の強調」なのか、見た目だけでは判断できません。赤いボタンが「削除」を表す場合もあれば「エラー」を表す場合もある。

コンポーネントを設計するとき、「視覚的に正確か」と同じくらい「このコンポーネントが表現する意味は何か」を言語化しておくことが大切です。

この視点は、命名の章で扱う「色は意味で名付ける」原則にもつながります。

好例がRadix UIの[`Dialog`](https://www.radix-ui.com/primitives/docs/components/dialog)と[`AlertDialog`](https://www.radix-ui.com/primitives/docs/components/alert-dialog)です。どちらもオーバーレイ付きのモーダルウィンドウで、ピクセル単位ではほぼ同じ外観です。

しかし`Dialog`は背景クリックで閉じられる汎用モーダルであるのに対し、`AlertDialog`は「本当に削除しますか？」のような確認用で、背景クリックでは閉じられません。見た目ではなく、ユーザーに強制する操作の意味が違うから別コンポーネントになっています。

![Radix UI: Dialog と AlertDialog の違い](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-11.png)

アクセシビリティの国際標準規格（[WAI-ARIA](https://www.w3.org/WAI/ARIA/apg/)）でも、スクリーンリーダーに「通常のダイアログ」と「警告ダイアログ」を区別して伝える仕組みが用意されており、この設計判断はその規格に基づいています。意味を正しく符号化することは、アクセシビリティにも直結します。

# 合成（Composition）: 小さな部品を組み合わせる

レゴブロックを思い出してください。同じブロックの組み合わせで、家もロボットも作れます。コンポーネント設計でも同じことが起こります。

4つの小さな部品——`Avatar`、`Text`、`Badge`、`Button`——があるとします。これらを組み合わせるだけで、`UserCard`（Avatar + Text + Badge）にも`NotificationItem`（Badge + Text + Button）にもなります。部品そのものを増やさなくても、配置を変えるだけでバリエーションが生まれるのです。

![合成: 小さな部品を組み合わせて大きなUIを構築する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-54.png)

Figmaのコンポーネントネスト（コンポーネントの中にコンポーネントを入れること）は、まさに合成そのものです。

コンポーネントを柔軟にする方法には、設定値を増やすConfiguration（設定型）と、差し込み口を設けるComposition（合成型）の2つのアプローチがあります。設定値を増やしすぎるとプロパティが肥大化しますが、差し込み口を設ければ利用者が自由に中身を入れ替えられます。この2つのアプローチの違いは、変数の章でElement型（スロット）として詳しく扱います。

合成が強力なのは、バリエーションの増え方が線形ではなく組み合わせ的（combinatorial）だからです。4つの部品を個別に使えば4通りですが、組み合わせれば数十通りのUIが生まれます。部品の数を足し算で増やすのではなく、組み合わせの可能性を掛け算で広げる——この発想の転換が、デザインシステムのスケーラビリティを支えています。

# 慣習（Convention）: 暗黙知を形式化する

あなた以外の誰かが、安全に拡張できるか。

見落とされがちですが、チームの暗黙知を形式化したルール——命名規則やディレクトリ構造——がその土台をつくります。

プロダクトは成功するほど大きくなります。機能が増え、画面が増え、関わる人が増えます。コンポーネント、トークン、プロパティの選択肢——これらはすべて、プロダクトの歴史とともに誰かが増やしていくものです。

たとえば、ボタンのデザインを変える`variant`に`primary`と`secondary`しかない状態で、新しいデザイナーが「警告用のボタンが欲しい」と思ったとします。命名規則が明確であれば`destructive`や`warning`を自然に追加できます。ルールが曖昧であれば、`red-button`や`btn-alert`のような名前が生まれ、体系が崩れていきます。

体系がない場合、次のような時系列を辿るでしょう。`variant`名が色名・略称・英語混在でバラバラです。

1. `variant`: `primary` / `secondary` が存在する
2. 警告用が欲しい → `red-button` を追加
3. 控えめなボタンも欲しい → `btn-light` を追加
4. 半年後、`primary` / `secondary` / `red-button` / `btn-light` / `outline-gray` が混在し、新メンバーが `red-button` と `btn-light` の違いは何ですか？と聞く。答えられる人がいない

![慣習: ルールの有無が半年後の品質を決める](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-41.png)

最初の2人目が正しく拡張できたかどうかは、10人目の生産性を大きく左右します。新メンバーが既存の仕組みに沿って迷わず貢献でき、チームが大きくなっても生産性が落ちにくい。これが慣習のビジネスインパクトです。

慣習には、もうひとつ見逃せない効果があります。それは、チーム内の優れたプラクティスを組織全体に広げる媒体になるということです。あるデザイナーがアクセシビリティに配慮した命名規則を考案したとき、それが個人のノウハウに留まるか、チームの慣習として根づくかで、到達範囲はまるで違います。慣習とは、個人の知恵を組織の資産に変換する仕組みです。

拡張するために参照する体系をルール化することに加え、実装やFigmaファイルから類推可能であることが重要です。これはコンポーネントに限らず、トークンの命名体系、Enumの選択肢、ディレクトリ構造、あらゆる設計判断に通じる問いです。

# 補足: 経路依存性（Path Dependency）——初期の選択が未来を縛る

経路依存性（path dependency）とは、初期に選んだ道がその後の選択肢を制約し、後戻りが難しくなる現象のことです。Figmaでたとえるなら、最初に`Auto Layout`なしで画面を作り始めてしまい、50画面できたところで`Auto Layout`に移行しようとしたら、全画面を作り直す必要が生じ、結局対応がなされず、また51画面目が生まれるという状況。このように、過去の偶然おこなわれた選択が、巡り巡って適切な仕切り直しの機運すらも奪ってしまう状況です。

この現象はライブラリの選択、命名、ディレクトリ構造——デザインシステムのあらゆる要素に関連します。いくつか例を見てみましょう。

たとえば、立ち上げ期に[MUI](https://mui.com/)を採用して管理画面を作ったケースを考えてみてください。最初は開発スピードが出て順調でした。

ところが1年後、ユーザー向け画面にも独自のデザインを入れたくなったとき、`MUI`のスタイル上書きがいたるところに広がっていて、Headless UIに乗り換えようにも影響範囲が大きすぎて踏み切れない。

![経路依存性: 初期の選択が未来を縛る](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-39.png)

命名も同じです。初期に`Card`と名付けたコンポーネントが50画面で使われたあとに「やっぱり`Tile`のほうが適切だった」と気づいても、Figma・コード・ドキュメント・チームの会話すべてに染みこんだ名前を変えるコストは、最初に決めるコストとは比べものになりません。

こうした構造は、デザインシステムのあらゆる層に潜んでいます。ディレクトリ構造、プロパティ設計、どれも時間が経つほど方向転換が難しくなります。

拡張性のない設計がどれくらいのコストを生むか、極端ですが具体的に見積もってみましょう。デザイナーとエンジニアの時給をそれぞれ5,000円と仮定します。

一覧画面の `Card` コンポーネントを「まずはシンプルに」と、画像・タイトル・説明文を縦に並べただけの固定レイアウトで作りました。実装とすり合わせMTGを含めて約3.5万円。ここまでは順調です。

3ヶ月後、カードの右上に「NEW」バッジを載せたいという要件が出ます。ところが、カードの内部構造にバッジを置くスペースが想定されていません。無理やりCSSを上書きして画像の上にバッジを重ねる応急処置をします。「どう直すか」の打ち合わせも含めて約2.75万円。動くけれど、設計としてはガムテープで貼った状態です。

さらに2ヶ月後、「横並びのカードも欲しい」という要件が来ます。画像が左・テキストが右に並ぶレイアウトです。しかしカードの中身は縦積み前提で作られているので、横に並べ替えるには内部をほぼ作り直す必要があります。しかもすでに15画面で使われているため、全画面の確認も必要です。デザインの検証・実装のやり直し・全画面のリグレッション確認・影響範囲の調査会議を合わせて約9.5万円。

累計15.75万円。最初から「中身を差し替えられる構造」「縦横を切り替えられる口」を設けていれば、初期コストが1〜2万円上乗せになる代わりに後の2回の手戻りはほぼ発生しませんでした。「あとで考える」は多くの場合「あとで倍額を払う」です。しかも、手戻りのたびに他の機能開発が止まる機会損失や、「またやり直しか」というチームの士気への影響は、この金額には含まれていません。

経路依存性の厄介さをさらに際立たせるのが、追加と削除のコストの非対称性です。コンポーネントに新しいプロパティやバリアントを追加するのは比較的簡単です。コードを数行足し、Figmaにバリアントをひとつ加えるだけ。既存の利用箇所には影響しません。一方、一度追加したものを削除するのは桁違いに大変です。

たとえば、ボタンに`ghost`というバリアントを追加した場面を考えてみてください。追加したその日は5分の作業です。しかし半年後、「`ghost`は`outline`と役割が重複しているから統合しよう」と判断したとき何が起きるでしょうか。

- `ghost`を使っている全画面を洗い出す必要がある
- 各画面で`outline`に置き換えて問題ないか個別に判断する
- Figmaのインスタンス、コード、テスト、ドキュメントをすべて更新する
- 「なぜ`ghost`がなくなったのか」をチームに説明し、合意を得る

5分で追加したものを削除するのに、数日から数週間かかることは珍しくありません。そして、この非対称性は時間とともに拡大していきます。使われている画面が10のときに削除するのと、100に増えてから削除するのでは、コストが文字通り桁違いです。使われる期間が長いほど、チームの語彙に染みこみ、ドキュメントに書かれ、新メンバーがそれを前提に学習する。削除のコストは線形ではなく、時間に対して加速度的に上がっていきます。

この性質を知っていると、「とりあえず追加しておこう」という判断の重みが変わります。追加はほぼ無料に見えますが、実際にはその瞬間から将来の削除コストが積み上がり始めています。慎重に追加し、使われなくなったものは早めに非推奨（deprecated）にする——この姿勢が、長く使えるコンポーネントライブラリを支えます。

だからこそ初期の設計判断は慎重に決める価値がありますが、未来にわたってスケーラブルな判断を最初から下せるかというとそうもいきません。結局これは、どれくらい先のことまで見据えて設計・実行できるかという問題にもなっていきます。ただ、先を見通すにも手を動かすにもリソースが要るので、現実にはこうした性質を頭に入れながら後で改修しやすくしておくか、あるタイミングでコストを払ってやりきるか、あるいは散らかったままで割り切るか——チームの状況に応じた落としどころを探ることになります。

# 意図的な妥協: 場当たりを「設計」にする

6つの原則と経路依存性の力学を理解したとしても、現実にはすべてを理想通りに進められる場面はほとんどありません。リリースは来週、エンジニアは2人、デザイナーは兼務——こうした状況で「原則を完全に守れるまで出せない」とは言えません。

場当たり的な対処は、どのプロダクトでも必ず発生します。問題は場当たり的であること自体ではなく、なんとなくやって、なんとなく定着してしまうことです。

なんとなく`Card`と名付けたが本当にそれでよいか検討していない。なんとなくBooleanにしたが、3つ目の選択肢が出てきたらどうなるか考えていない。こうした「考えていない」が積み重なると、経路依存性の力学が効いてきて、後から見たときに「なぜこうなっているのか」を誰も説明できない状態になります。

場当たり的な対処を意図的な妥協に変えるのに、大きな手間は要りません。

- **「なぜ今こうするか」を一言残す。** Figmaのコメントやコードのコメントに「本来はEnumだが、選択肢が確定していないためStringで仮置き」と書くだけで、後から見た人が修正の判断材料を得られる
- **後で直しやすい方向に倒す。** 名前を仮で決めるなら、少なくとも一括置換しやすい一意な名前にする。型を仮で決めるなら、より厳密な型への移行が非破壊的変更になる方向を選ぶ（Stringで仮置き → 後でEnumに絞る、のほうが逆よりも安全）
- **「今はやらない」と「やらなくていい」を区別する。** 意識的に先送りした判断はチーム内で共有し、何が起きたら着手するかのトリガーを決めておく。トリガーがないと、先送りは風化して既成事実になる

原則を知らずに場当たり的に進めるのと、原則を知ったうえで意図的に妥協するのでは、見た目は同じでも半年後の改善のしやすさがまるで違います。理想を知っているからこそ、「今はどこまでやり、どこを後に回すか」という線引きができるのです。

# 一般化と個別化のバランス: どちらに寄せるか

コンポーネントをより多くの場面で使えるようにしたいとき、一般化と個別化のどちらに寄せるかが問題になります。

一般化とは、さまざまな文脈で使えるよう抽象度を上げることです。`Button` はどんなページでも使えますが、特定のページに最適化されてはいません。個別化とは、特定の文脈に合わせて最適化することです。`ShiftApplyButton` は求人応募画面に完璧にフィットしますが、他の画面では使えません。

この緊張関係は、デザインシステムのあらゆる設計判断に顔を出します。

- **コンポーネントの粒度**: 汎用コンポーネントとドメインコンポーネントの線引き
- **プロパティの型**: Enum（選択肢を限定する一般化）とString（自由入力を許す個別化）の選択
- **共通化のタイミング**: 似たUIを早期にまとめるか、個別のまま育てるか
- **柔軟性の設計**: 設定値で制御するか（一般化）、差し込み口を設けて利用者に委ねるか（個別化）

一般化しすぎると、どの文脈でも使えるがどの文脈にも最適ではないコンポーネントが生まれます。プロパティは膨張し、条件分岐が増え、「このプロパティは何のために存在するのか」を誰も説明できなくなる。

個別化しすぎると、似た見た目のコンポーネントが乱立し、変更のたびに複数のコンポーネントを同時に修正する羽目になります。一箇所を直せば全部直るという間接化のメリットが失われます。

最適解はプロダクトのフェーズやチームの規模によって変わります。立ち上げ期は個別化寄りで素早く作り、パターンが見えてきたら一般化する。成熟期には一般化された基盤を維持しつつ、ドメイン固有の要件は個別のコンポーネントで吸収する。

大事なのは、いま自分たちがこのスペクトラムのどこにいるかを自覚し、意図的に選ぶことです。なんとなく共通化する、なんとなく専用のものを作る——この「なんとなく」が、経路依存性を通じて後から修正しにくい構造を生みます。この緊張関係は以降の章で繰り返し登場しますが、正解がひとつに定まらないからこそ、判断の軸を持っておくことに価値があります。

---

以上の6つの原則——間接化・カプセル化・制約・意味の符号化・合成・慣習——は、後の章で登場する具体的なプラクティスの土台になります。すべてを一度に実現する必要はありません。自分たちのシステムがどの原則をカバーしていて、どこが手薄かを把握しておくと、自組織が強化すべきポイントが見えてきます。

経路依存性はこれらの原則そのものではありませんが、原則を適用する際に常に意識しておくべき力学です。初期の設計判断がどれほど後に響くかを知っていれば、6つの原則への向き合い方も変わります。

デザインシステムは、チームの認知リソースを再配分します。ボタンの色やサイズで悩む時間がなくなった分、ユーザーの課題解決や情報設計に集中できる。工数の削減と思考の質の向上に加え、間接化の節で見たように、優れた設計判断がシステムを通じて組織全体に行き渡るレバレッジも生まれます。

換言すれば、デザインシステムとは認知的余白を生み出す仕組みです。定型的な判断をシステムに委ね、人間の注意力をまだ答えのない問いに向ける。この再配分の効果は、関わる人数が増え、判断の頻度が上がるほど顕著になります。

//todo ここのジレンマについて書く
難しいのは、デザインシステムへの向き合いに時間をかけすぎてしまうことは、かえって答えのない問いに向きあう時間を没却しているのではないか？（つまり、今どこのどの時間軸にフォーカスするのか？という問い）

# デザインシステムがないとどうなるか

原則を押さえたところで、ここまでの話を裏側から見てみます。デザインシステムがない、あるいは機能していない状態で何が起きるか。

**デザイナーの視点。** デザインの判断基準が個人の頭の中に閉じます。ボタンのスタイルや余白のルールが明文化されていないため、デザイナーごとに微妙に異なるUIが生まれ、プロダクト全体の一貫性が人の記憶力に依存します。新しいメンバーは暗黙のルールを一つずつ学ぶ必要があり、チームが大きくなるほどこの負荷は増えていきます。

**エンジニアの視点。** デザインとコードの間に共通の語彙がないため、デザインカンプの解釈が毎回発生します。同じ意図の見た目が画面ごとに異なる実装として積み重なり、プレゼンテーション層に技術的負債が蓄積します。コードベースの中で似た役割のコンポーネントが散在し、どれが正で何が派生なのかを把握するコストが機能追加のたびに増大します。

**PdMの視点。** プロダクトの一貫性が、設計ルールではなく個別のレビューに頼る状態になります。UIの変更（ブランドカラーの刷新、トーンの統一など）を実施しようとしたとき、影響範囲の特定自体がプロジェクトになる。デザインレビューが視覚的な細部の指摘に時間を取られ、ユーザー体験や情報設計の議論に到達しにくくなります。

**マネージャーの視点。** プロダクトの成長とともにUI開発の速度が鈍化していきます。画面数が増えるほど暗黙の規約も増え、それを知っている人がボトルネックになる。チーム横断でUIの一貫性を保つには、システムによる担保ではなく人による調整が必要になり、コミュニケーションコストがチームの人数に比例して膨らみます。デザインシステムへの投資判断を先送りするほど、あとから導入するコストが上がっていく——これも経路依存性の一種です。

![デザインシステムがない世界: 4つの立場から見た課題](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-73.png)

いずれの立場にも共通するのは、すでに決まっているべきことが決まっていないために、同じ判断を繰り返しているという構造です。デザインシステムは、この繰り返しを仕組みとして吸収し、チームの認知リソースを本来の問題解決に向けるためのものです。同時に、デザインシステムがないということは、誰かが苦労して見つけた優れた解決策——たとえばエラー表示の最適なパターンや、アクセシビリティを満たす配色——が個人の手元に留まり、組織全体に還元される経路がないということでもあります。

ただし、デザインシステムの導入がつねに正解というわけではありません。立ち上げ期のプロダクトでは、UIの方向性自体がまだ固まっていないことがあります。その段階で体系化に投資すると、試行錯誤の速度を落とし、まだ見えていない要件に対して早すぎる最適化をしてしまうリスクがあります。少人数のチームでは暗黙の共有で十分に回っている場合もあり、仕組み化のコストが利益を上回ることもあります。

逆に、すでに回っているプロダクトに後からデザインシステムを整備していくのも簡単ではありません。既存のコードやデザインファイルとの整合性を取りながら段階的に移行する必要があり、投資対効果が見合うやり方を模索しながら進めることになります。改修頻度が高くない領域であれば、無理に統一せず現状のままにしておくほうが合理的なこともあります。

デザインシステムが効くのは、チームや画面の数が増え、暗黙知だけでは一貫性を維持できなくなった段階で、かつUIの変更が継続的に発生する領域です。自分たちがいまどのフェーズにいるか、どこに投資すべきかを見極めることが出発点になります。

原則を押さえたうえで、次いで、これらの原則をどのような手段で実現するか——構築戦略の選択について検討します。
