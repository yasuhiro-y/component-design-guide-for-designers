---
title: "原則: コンポーネントライブラリがめざすもの"
---

Figma（あるいはSketch）のおかげで、デザイナーもコンポーネントの概念には馴染んできたのではないでしょうか。

コンポーネントという言葉は広い意味で使われます。ソフトウェアのモジュール、ハードウェアの部品、ビジネスプロセスの構成要素——いずれも「コンポーネント」と呼ばれることがあります。
この記事では、UIを構成する再利用可能な部品に限定して扱います。Figmaのコンポーネント機能で作るマスターコンポーネントとインスタンスの関係や、コードの関数コンポーネントがこれにあたります。

なぜ私たちはコンポーネントという単位で考えるのでしょうか。

それは、プロダクトを変更しやすくし、一貫性を保つためです。

Kevin Muldoonは[What Design Systems Actually Do](https://www.designsystemscollective.com/what-design-systems-actually-do-ea8a3daba32a)の中で、デザインシステムが提供する価値を間接化・カプセル化・制約・意味の符号化・合成・慣習という6つの抽象化で整理しています。この章では、その6つを土台にデザインシステムの考え方を紹介します。これらを押さえておくと、後の章で登場するプラクティスの背景が見通せるようになります。

# 間接化（Indirection）: 一箇所を直せば全部直る

トークンやマスターコンポーネントを介して、変更を一箇所に集約する仕組み。これが間接化です。「再利用性」と「変更のしやすさ」は、同じメカニズムの表と裏です。

同じものを何度も作らない。一度作った品質をどこでも再現できる——これはユーザー体験の安定に直結します。Figmaでマスターコンポーネントを更新すれば、すべてのインスタンスに変更が反映される。コードでも同様です。ボタンの押し心地やエラーの表示方法が画面ごとにバラバラだと、ユーザーは使うたびに学び直す必要があります。

組織の視点で見れば、コンポーネント化はデザインと実装のコスト削減そのものです。共通のコンポーネントがなければ、同じUIを作るたびにデザイナーごとの判断が入り、品質のばらつきを引き起こします。組織として決めたデザインをコンポーネントに落とし込んでおけば、誰が使っても同じ品質が再現でき、特定のデザイナーへの依存もなくなる。

たとえば、ブランドカラーを青から赤に変更するとします（別の意味で大変ですね！）。バラバラに実装されていたら、ボタンのある画面すべてをひとつずつ直さなければなりません。コンポーネントで管理されていれば、トークンの値をひとつ書き換えるだけで済みます。

実際にはブランドカラーの全面変更より、プライマリボタンの角丸を8pxから12pxに統一する、フォントサイズのベースを14pxから16pxに上げるといった地味な変更のほうが頻繁に起こります。こうした変更も、コンポーネント化されていれば一箇所の修正で全画面に反映できます。
デザイナーが少人数でも大規模なプロダクトを運用できるのは、このレバレッジが効いているからです。同じUIを1から作り直す工数が減り、新しい機能の開発に時間を使えるようになります。

![間接化: 1箇所の変更がすべてに届く](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-23.png)

Nathan Curtisは「[And You Thought Buttons Were Easy?](https://medium.com/eightshapes-llc/and-you-thought-buttons-were-easy-26eb5b5c1871)」の中で、ボタンひとつをデザイン・実装・テストするコストを$20,000（300万円）と見積もり、50チームがそれぞれ作れば$1,000,000（1億5000万円）になると試算しています。
（単価の設定が極端なので、1/10程度でイメージしたらよいかと思いますが、考え方としてはこういうことです）

間接化は、このコストを1回分に圧縮する仕組みです。

# カプセル化（Encapsulation）: 複雑さを隠す

内部の複雑さを隠し、使う側にはシンプルなインターフェースだけを見せる。これがカプセル化です。ひとことで言えば、**ひとつの部品にひとつの責任を持たせること**でもあります。

ボタンを例に考えてみましょう。ラベルと背景色だけのシンプルな部品に見えますが、その裏には膨大な設計判断が隠れています。`Hover`・`Pressed`・`Disabled`・`Focus`のインタラクション状態、`primary`・`secondary`・`destructive`のバリアント、アイコンの有無と位置、ライト/ダークテーマ——これらの組み合わせだけで数百にのぼります。カプセル化されたボタンコンポーネントは、この複雑さを隠して「variant と size を選ぶだけ」にしてくれます。

![ボタンの複雑さ: シンプルに見えて設計判断の山](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-55.png)

たとえば、`UserCard`コンポーネントの中に、ユーザーデータを取得するロジックが埋め込まれていたとします。画面上ではきれいに動きます。しかし、同じカードを別の画面で「お気に入り一覧」に使いたくなったとき、データ取得先が決め打ちになっているので使い回せません。見た目だけ欲しいのに、データ取得のロジックがくっついてくるからです。

結果として、ほぼ同じ見た目の`UserCard2`が生まれます。この種の「似て非なるコンポーネント」の増殖は、カプセル化が崩れている兆候です。

もし`UserCard`が「受け取ったデータを表示する」ことだけに責任を持ち、「どこからデータを取ってくるか」を呼び出す側に任せていれば、どの画面でもそのまま使い回せます。Figmaでいえば、マスターコンポーネントが見え方を決め、インスタンス側がテキストや画像を差し替える関係と同じです。

この考え方があると、Figmaで修正したとき何に影響するかが予測でき、エンジニアに聞く前に安全な変更範囲を判断できます。バグ修正の影響範囲が局所化され、ある画面を直したら別の画面が壊れた、という事故を防げます。

## 3つの分離レイヤー

カプセル化は、コンポーネント設計のさまざまな場面で顔を出します。この記事では、以下の3つのレイヤーを順番に扱っていきます。

![カプセル化: 3つの分離レイヤー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-24.png)

- **見た目とデータの分離**: コンポーネントは表示に専念し、どんなデータを取ってきて渡すかは呼び出す側が担う
- **構造とスタイルの分離**: 骨組みと見た目の装飾を切り離す。後述するHeadless UIの思想。[Shadcn/ui](https://ui.shadcn.com/)はこの分離をライブラリレベルで体現した実例で、[Radix UI](https://www.radix-ui.com/primitives)が提供する骨組み（振る舞い＋アクセシビリティ）に[Tailwind CSS](https://tailwindcss.com/)で見た目を上書きする構成になっている
- **汎用とドメインの分離**: どこでも使える部品（`Button`や`Avatar`）と、特定の機能に特化した部品（`JobCard`）を混ぜない。コンポーネント分割の章でくわしく扱う

`UserCard`ひとつをとっても、3つの分離が見えます。見た目（レイアウトや色）とデータ（ユーザー名やアイコンURL）は分離すべきですし、骨組み（`Auto Layout`の構造）とスタイル（色・角丸）も分けられます。`UserCard`自体はドメインコンポーネントですが、その中で使う`Card`（枠）や`Avatar`（アイコン）は汎用コンポーネントです。

責任を分けておくからこそ、片方だけを変えたり、別の組み合わせで再利用したりできます。レイアウトの章で扱う、コンポーネントの中身（`padding`）と配置（`margin`）を分ける話も、カプセル化そのものです。

# 制約（Constraint）: 選択肢を絞り、判断の負荷を下げる

レストランで「10品のコース」と「何でもお作りします」のどちらが注文しやすいでしょうか。選択肢を意図的に絞ることで、判断の負荷を下げる。これが制約の原則です。

色を例にとりましょう。ディスプレイが表現できる色は約1680万色です。しかし、プロダクトで使う色が1680万色あったら、誰もデザインの一貫性を保てません。10色程度のセマンティックカラーに絞ることで、どの画面でも意味のある配色が再現できるようになります。

スペーシングも同じです。`margin`や`padding`に「好きな数字を入れてよい」とすると、14px, 17px, 23pxのような半端な値が乱立します。4/8/12/16/24/32のスケールに制約すれば、誰が作っても整ったリズムが生まれます。

![制約: 選択肢を絞り、判断の負荷を下げる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-53.png)

変数の章で扱うプロパティの型も制約の一形態です。Booleanは2択、EnumはN択、Stringは自由入力。型が厳しいほど誤用が減り、型がゆるいほど柔軟性が増します。

[Ross Horbiの試算](https://medium.com/@rosshorbi/how-i-created-a-design-system-for-buttons-cfebbc55106e)によると、とあるボタンの取りうる姿の組み合わせはサイズ4段階 × アイコン有無4パターン × スタイル5種 × 状態5種 × テーマ2種 = 960バリアントに達します。制約なしにすべてを自由設計すると破綻するのは明白です。

ただし、制約が強すぎると例外的なユースケースに対応できなくなります。制約と柔軟性のバランスをどうとるか。後の章では柔軟性と秩序のバランスについても考えます。

# 意味の符号化（Semantic Encoding）: 見た目ではなく意味で名付ける

Figmaで赤い塗りの四角形を描いたとします。これは「エラー表示」なのか「セール価格の強調」なのか、見た目だけでは判断できません。赤いボタンが「削除」を表す場合もあれば「エラー」を表す場合もある。

コンポーネントを設計するとき、「視覚的に正確か」と同じくらい「このコンポーネントが表現する意味は何か」を言語化しておくことが大切です。

この視点は、命名の章で扱う「色は意味で名付ける」原則にもつながります。

好例がRadix UIの[`Dialog`](https://www.radix-ui.com/primitives/docs/components/dialog)と[`AlertDialog`](https://www.radix-ui.com/primitives/docs/components/alert-dialog)です。どちらもオーバーレイ付きのモーダルウィンドウで、ピクセル単位ではほぼ同じ外観です。

しかし`Dialog`は背景クリックで閉じられる汎用モーダルであるのに対し、`AlertDialog`は「本当に削除しますか？」のような確認用で、背景クリックでは閉じられません。見た目ではなく、ユーザーに強制する操作の意味が違うから別コンポーネントになっています。

![Radix UI: Dialog と AlertDialog の違い](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-11.png)

アクセシビリティの国際標準規格（[WAI-ARIA](https://www.w3.org/WAI/ARIA/apg/)）でも、スクリーンリーダーに「通常のダイアログ」と「警告ダイアログ」を区別して伝える仕組みが用意されており、この設計判断はその規格に基づいています。意味を正しく符号化することは、アクセシビリティにも直結します。

# 合成（Composition）: 小さな部品を組み合わせる

レゴブロックを思い出してください。同じブロックの組み合わせで、家もロボットも作れます。コンポーネント設計でも同じことが起こります。

4つの小さな部品——`Avatar`、`Text`、`Badge`、`Button`——があるとします。これらを組み合わせるだけで、`UserCard`（Avatar + Text + Badge）にも`NotificationItem`（Badge + Text + Button）にもなります。部品そのものを増やさなくても、配置を変えるだけでバリエーションが生まれるのです。

![合成: 小さな部品を組み合わせて大きなUIを構築する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-54.png)

Figmaのコンポーネントネスト（コンポーネントの中にコンポーネントを入れること）は、まさに合成そのものです。

コンポーネントを柔軟にする方法には、設定値を増やすConfiguration（設定型）と、差し込み口を設けるComposition（合成型）の2つのアプローチがあります。設定値を増やしすぎるとプロパティが肥大化しますが、差し込み口を設ければ利用者が自由に中身を入れ替えられます。この2つのアプローチの違いは、変数の章でElement型（スロット）として詳しく扱います。

部品を増やさずにバリエーションを増やせること。これが合成の力であり、デザインシステムのスケーラビリティを支える考え方です。

# 慣習（Convention）: 暗黙知を形式化する

あなた以外の誰かが、安全に拡張できるか。

見落とされがちですが、チームの暗黙知を形式化したルール——命名規則やディレクトリ構造——がその土台をつくります。

プロダクトは成功するほど大きくなります。機能が増え、画面が増え、関わる人が増えます。コンポーネント、トークン、プロパティの選択肢——これらはすべて、プロダクトの歴史とともに誰かが増やしていくものです。

たとえば、ボタンのデザインを変える`variant`に`primary`と`secondary`しかない状態で、新しいデザイナーが「警告用のボタンが欲しい」と思ったとします。命名規則が明確であれば`destructive`や`warning`を自然に追加できます。ルールが曖昧であれば、`red-button`や`btn-alert`のような名前が生まれ、体系が崩れていきます。

体系がない場合、次のような時系列を辿るでしょう。`variant`名が色名・略称・英語混在でバラバラです。

1. `variant`: `primary` / `secondary` が存在する
2. 警告用が欲しい → `red-button` を追加
3. 控えめなボタンも欲しい → `btn-light` を追加
4. 半年後、`primary` / `secondary` / `red-button` / `btn-light` / `outline-gray` が混在し、新メンバーが `red-button` と `btn-light` の違いは何ですか？と聞く。答えられる人がいない

![慣習: ルールの有無が半年後の品質を決める](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-41.png)

最初の2人目が正しく拡張できたかどうかは、10人目の生産性を大きく左右します。新メンバーが既存の仕組みに沿って迷わず貢献でき、チームが大きくなっても生産性が落ちにくい。これが慣習のビジネスインパクトです。

拡張するために参照する体系をルール化することに加え、実装やFigmaファイルから類推可能であることが重要です。これはコンポーネントに限らず、トークンの命名体系、Enumの選択肢、ディレクトリ構造、あらゆる設計判断に通じる問いです。

# 経路依存性（Path Dependency）: 初期の選択が未来を縛る

経路依存性（path dependency）とは、初期に選んだ道がその後の選択肢を制約し、後戻りが難しくなる現象のことです。Figmaでたとえるなら、最初に`Auto Layout`なしで画面を作り始めてしまい、50画面できたところで`Auto Layout`に移行しようとしたら、全画面を作り直す必要が生じ、結局対応がなされず、また51画面目が生まれるという状況。このように、過去の偶然おこなわれた選択が、巡り巡って適切な仕切り直しの機運すらも奪ってしまう状況です。

この現象はライブラリの選択、命名、ディレクトリ構造——デザインシステムのあらゆる要素に関連します。いくつか例を見てみましょう。

たとえば、立ち上げ期に[MUI](https://mui.com/)を採用して管理画面を作ったケースを考えてみてください。最初は開発スピードが出て順調でした。

ところが1年後、ユーザー向け画面にも独自のデザインを入れたくなったとき、`MUI`のスタイル上書きがいたるところに広がっていて、Headless UIに乗り換えようにも影響範囲が大きすぎて踏み切れない。

![経路依存性: 初期の選択が未来を縛る](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-39.png)

命名も同じです。初期に`Card`と名付けたコンポーネントが50画面で使われたあとに「やっぱり`Tile`のほうが適切だった」と気づいても、Figma・コード・ドキュメント・チームの会話すべてに染みこんだ名前を変えるコストは、最初に決めるコストとは比べものになりません。

こうした構造は、デザインシステムのあらゆる層に潜んでいます。ディレクトリ構造、プロパティ設計、どれも時間が経つほど方向転換が難しくなります。

経路依存性の厄介さをさらに際立たせるのが、追加と削除のコストの非対称性です。コンポーネントに新しいプロパティやバリアントを追加するのは比較的簡単です。コードを数行足し、Figmaにバリアントをひとつ加えるだけ。既存の利用箇所には影響しません。一方、一度追加したものを削除するのは桁違いに大変です。

たとえば、ボタンに`ghost`というバリアントを追加した場面を考えてみてください。追加したその日は5分の作業です。しかし半年後、「`ghost`は`outline`と役割が重複しているから統合しよう」と判断したとき何が起きるでしょうか。

- `ghost`を使っている全画面を洗い出す必要がある
- 各画面で`outline`に置き換えて問題ないか個別に判断する
- Figmaのインスタンス、コード、テスト、ドキュメントをすべて更新する
- 「なぜ`ghost`がなくなったのか」をチームに説明し、合意を得る

5分で追加したものを削除するのに、数日から数週間かかることは珍しくありません。そして、この非対称性は時間とともに拡大していきます。使われている画面が10のときに削除するのと、100に増えてから削除するのでは、コストが文字通り桁違いです。使われる期間が長いほど、チームの語彙に染みこみ、ドキュメントに書かれ、新メンバーがそれを前提に学習する。削除のコストは線形ではなく、時間に対して加速度的に上がっていきます。

この性質を知っていると、「とりあえず追加しておこう」という判断の重みが変わります。追加はほぼ無料に見えますが、実際にはその瞬間から将来の削除コストが積み上がり始めています。慎重に追加し、使われなくなったものは早めに非推奨（deprecated）にする——この姿勢が、長く使えるコンポーネントライブラリを支えます。

だからこそ初期の設計判断は慎重に決める価値がありますが、未来にわたってスケーラブルな判断を最初から下せるかというとそうもいきません。結局これは、どれくらい先のことまで見据えて設計・実行できるかという問題にもなっていきます。ただ、先を見通すにも手を動かすにもリソースが要るので、現実にはこうした性質を頭に入れながら後で改修しやすくしておくか、あるタイミングでコストを払ってやりきるか、あるいは散らかったままで割り切るか——チームの状況に応じた落としどころを探ることになります。

---

以上の7つの原則——間接化・カプセル化・制約・意味の符号化・合成・慣習・経路依存性——は、後の章で登場する具体的なプラクティスの土台になります。すべてを一度に実現する必要はありません。自分たちのシステムがどの原則をカバーしていて、どこが手薄かを把握しておくと、自組織が強化すべきポイントが見えてきます。

デザインシステムは、チームの認知リソースを再配分します。ボタンの色やサイズで悩む時間がなくなった分、ユーザーの課題解決や情報設計に集中できる。工数の削減だけでなく、思考の質が上がることも大きな効果です。

# デザインシステムがないとどうなるか

原則を押さえたところで、ここまでの話を裏側から見てみます。デザインシステムがない、あるいは機能していない状態で何が起きるか。

**デザイナーの視点。** デザインの判断基準が個人の頭の中に閉じます。ボタンのスタイルや余白のルールが明文化されていないため、デザイナーごとに微妙に異なるUIが生まれ、プロダクト全体の一貫性が人の記憶力に依存します。新しいメンバーは暗黙のルールを一つずつ学ぶ必要があり、チームが大きくなるほどこの負荷は増えていきます。

**エンジニアの視点。** デザインとコードの間に共通の語彙がないため、デザインカンプの解釈が毎回発生します。同じ意図の見た目が画面ごとに異なる実装として積み重なり、プレゼンテーション層に技術的負債が蓄積します。コードベースの中で似た役割のコンポーネントが散在し、どれが正で何が派生なのかを把握するコストが機能追加のたびに増大します。

**PdMの視点。** プロダクトの一貫性が、設計ルールではなく個別のレビューに頼る状態になります。UIの変更（ブランドカラーの刷新、トーンの統一など）を実施しようとしたとき、影響範囲の特定自体がプロジェクトになる。デザインレビューが視覚的な細部の指摘に時間を取られ、ユーザー体験や情報設計の議論に到達しにくくなります。

**マネージャーの視点。** プロダクトの成長とともにUI開発の速度が鈍化していきます。画面数が増えるほど暗黙の規約も増え、それを知っている人がボトルネックになる。チーム横断でUIの一貫性を保つには、システムによる担保ではなく人による調整が必要になり、コミュニケーションコストがチームの人数に比例して膨らみます。デザインシステムへの投資判断を先送りするほど、あとから導入するコストが上がっていく——これも経路依存性の一種です。

![デザインシステムがない世界: 4つの立場から見た課題](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-73.png)

いずれの立場にも共通するのは、すでに決まっているべきことが決まっていないために、同じ判断を繰り返しているという構造です。デザインシステムは、この繰り返しを仕組みとして吸収し、チームの認知リソースを本来の問題解決に向けるためのものです。

ただし、デザインシステムの導入がつねに正解というわけではありません。立ち上げ期のプロダクトでは、UIの方向性自体がまだ固まっていないことがあります。その段階で体系化に投資すると、試行錯誤の速度を落とし、まだ見えていない要件に対して早すぎる最適化をしてしまうリスクがあります。少人数のチームでは暗黙の共有で十分に回っている場合もあり、仕組み化のコストが利益を上回ることもあります。

逆に、すでに回っているプロダクトに後からデザインシステムを整備していくのも簡単ではありません。既存のコードやデザインファイルとの整合性を取りながら段階的に移行する必要があり、投資対効果が見合うやり方を模索しながら進めることになります。改修頻度が高くない領域であれば、無理に統一せず現状のままにしておくほうが合理的なこともあります。

デザインシステムが効くのは、チームや画面の数が増え、暗黙知だけでは一貫性を維持できなくなった段階で、かつUIの変更が継続的に発生する領域です。自分たちがいまどのフェーズにいるか、どこに投資すべきかを見極めることが出発点になります。

原則を押さえたうえで、次は重要な選択、デザインシステムの構築方法の選択肢を見ていきます。
