---
title: "コンポーネント分割: 何をどう分けるか"
---

ボタン、カード、モーダル——同じ名前のコンポーネントなのに、デザイナーとエンジニアの頭の中にある形が違う。そんなすれ違いの多くは分割の基準を策定・共有していないことから生まれます。

# コンポーネント設計の考慮事項

ひとつのコンポーネントについて検討すべき要素は多岐にわたります。大まかに次のような考慮事項があります。

![コンポーネント設計の8つの観点](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-31.png)

- 階層: どこに位置するか
- 名前: コンポーネント名、プロパティ名、値の名前
- プロパティ: 何を受け取り、どんな型か。必須か任意か
- 見た目: バリアント、色、サイズ、レイアウト
- 状態: Loading / Error / Empty / Partial / Ideal
- 依存関係: 何に依存し、何から利用されるか
- トークン: どのデザイントークンを参照するか
- 振る舞い: 幅の伸縮、レスポンシブ対応

ボタンひとつとっても、これだけの要素が同時に存在します。どれかひとつだけを決めればよいのではなく、これらが絡み合ってコンポーネントの設計になります。この記事の各章では、それぞれの要素を掘り下げていきます。

仮にFigmaとコードの一致性を目指す場合、コンポーネントの命名・ディレクトリ・責務範囲を後から変更するコストが大きい場合が多いです。デザイナー同士の連携、エンジニアとの連携、使用している箇所の改修。利用箇所が多いほど大変です。

だからこそ、個別のコンポーネントをどう名付け、位置づけるかは、誰でも同じ判断ができるよう組織内で整備することが重要です。そして、コンポーネント分割の思想は、コンポーネントの命名とディレクトリ分けに影響し、デザインシステムのオペレーションの基礎となります。

# コンポーネント化するか？

前提として、UIはコンポーネント化せずに画面に直接作り込むこともできます。

Figmaでいえば、マスターコンポーネントにせず通常のフレームとして描くことに相当します。つまり、画面に映るものすべてがコンポーネント化されている必要は（技術的には）ありません。

では、何をコンポーネント化すると組織が最も恩恵を受けられるのでしょうか。判断の軸としては、一箇所を直せば全部直る状態にしたい・連続性をもって拡張したい場合にコンポーネント化する。

コンポーネント化されているということは、そのコンポーネントを拡張したり、類似するものはそのコンポーネントのやり方に従うという道を開いていることです。つまり、単なる1画面に登場するUI以上に、組織的な合意や規範が詰まっていると捉えることができます。

実務ではいくつかの基準が使われています。

- よく使われるUIや汎用用途のものだけをコンポーネント化する
- 2回以上使用されたらコンポーネント化する
- 今後再利用される可能性のあるUIをコンポーネント化する
- 再利用性を問わず、画面上のすべての要素をコンポーネント化する

この考え方の背景にあるのがSSOT（Single Source of Truth）——真実の情報源はひとつだけ、という原則です。原則の章で紹介した間接化の考え方そのものです。Figmaでいえば、コンポーネントのマスターを1つ持ち、全画面でそのインスタンスを使う。マスターを更新すれば全インスタンスに反映される。

たとえば、フッターのリンク一覧。今は1画面にしか置いていなくても、将来2画面目に必要になったとき、コピー&ペーストで増やすとリンクの追加漏れが起きます。コンポーネント化しておけば、元を直すだけで全画面に反映されます。

一方で、見た目が似ているからといって何でも共通化すればよいわけではありません。この判断については「早すぎる共通化の罠」でくわしく扱います。

迷ったときは、以下のようなフローをチームではなしてみるといいかもしれません。

![コンポーネント化の判断フロー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-01.png)

# コンポーネントの分割方法: 3つのアプローチ

コンポーネントの整理方法にはいくつかのアプローチがあり、チームの規模やプロダクトの複雑さに応じて使い分けます。代表的な3つを取り上げます。

## Atomic Design: 複雑さで分ける

[Atomic Design](https://atomicdesign.bradfrost.com/)は、Brad Frost氏が提唱したUIの構造化手法です。化学のメタファーを用いて、UIを以下の5つの階層に分類します。

- Atoms（原子）: ボタン、ラベル、入力フィールドなど、これ以上分割できない最小のUI要素
- Molecules（分子）: 原子を組み合わせた小さな機能単位。検索バーなど
- Organisms（有機体）: 分子や原子を組み合わせた、ひとまとまりのUI領域。ヘッダーやカードリストなど
- Templates: Organismsを配置したページの骨格。実データではなくワイヤーフレーム的な構造
- Pages: Templatesに実データを流し込んだ、最終的な画面

このアプローチは、小さな部品からUIを積み上げるという考え方を広く浸透させました。

![Atomic Design: 5つの階層](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-40.png)

ところが、実際に使ってみるとやっかいなのは、`molecules`と`organisms`の境界線が人によってバラバラになることです。ボタンと入力フォームを組み合わせたら分子なのか、それが特定の検索窓になったら有機体なのか。

実際には、ある程度くずした運用をしている場合が多いです。たとえば、`atoms`と`molecules`の2層のみを使い、`organisms`との境界線に悩む時間を省くという判断もあります。

Atomic Designは日本のサービスでも導入事例が豊富であり、そして辛みやその解決も多く発信されています。

## Feature-Sliced Design: 目的で分ける

Atomic Designはコンポーネントの構造で分類する考え方でした。もうひとつ、何のための部品かで分類する考え方があります。[Feature-Sliced Design](https://feature-sliced.design/)（FSD）と呼ばれる手法のエッセンスです。

Figmaのページやセクションをどう整理するかを考えるときにも使える視点なので、ここでは3つのレイヤーに絞って紹介します。

**UI Kit レイヤー** — どのプロダクトでも使い回せる、汎用的なUI部品です。`Button`、`Input`、`Avatar`、`Badge`など。

**Features / Domain レイヤー** — 特定のサービスやデータに紐づくコンポーネントです。商品カード、ユーザープロフィール、お気に入りボタンなど。

**Widgets / Templates レイヤー** — 上の2つを組み合わせて作る、大きなかたまりです。ヘッダー、フォーム全体、商品一覧セクションなど。

大事なのは矢印の方向です。上のレイヤーは下のレイヤーを使えますが、逆はありません。

ECサイトで具体的にイメージしてみましょう。

![Feature-Sliced Design の3層構造](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-02.png)

- UI Kit: `Button`、`Input`、`Card`、`Tag` — どんなサービスにも使い回せる
- Domain: `ProductCard`（商品の情報を表示する）、`CartItem`（カート内の1行） — ECサイトのデータに依存する
- Widgets: `ProductListSection`（`ProductCard`の一覧＋フィルター）、`CheckoutForm`（`CartItem`の一覧＋決済ボタン） — Domainの部品を組み合わせた画面の骨格

`ProductCard`は`Button`や`Badge`を使いますが、`Button`が`ProductCard`の存在を前提にすることはありません。

この一方通行が崩れると何が起きるか。`Button`が`UserCard`に依存していたら、`UserCard`を変更するたびに`Button`まで壊れるかもしれません。一方通行であれば、影響は常に下流（利用する側）にしか伝わりません。

Figmaで考えると直感的です。`Button`コンポーネントが`UserCard`のインスタンスを内部に含んでいたら、おかしいですよね。それと同じ感覚です。

この方式のメリットは、依存の方向が明確になることで影響範囲の予測がしやすくなる点です。UI Kitを修正しても影響はそれを使うDomain以上のレイヤーに限られ、Widgetsの変更がUI Kitに波及することはありません。レイヤーごとに責務が分かれているため、コンポーネントが増えても構造が破綻しにくく、新しいメンバーもどの階層に手を入れるべきか判断しやすくなります。

この考え方は、後述の汎用・ドメインの考え方にも重複するところがみられます。

## フラットに置く: 階層なしで並べる

すべてのコンポーネントを階層なしにひと箇所にまとめるシンプルな方法です。コンポーネント数が少ないうちは、分類に悩む必要がなく、見通しもよいため十分に機能します。Figmaでいえば、ページやセクションを分けず、すべてのコンポーネントを1つのページにフラットに並べている状態です。小規模なプロダクトでは有効な選択肢です。

ただし、コンポーネントが増えてくるとどこに何があるか分からない問題が目立ってきたり、責務設計に規律がないまま発展しがちです。コンポーネント数が20〜30を超えてきたら（これは厳密なルールではなく、ファイルを開いたときに一覧性を失い始める目安です）、前述のような階層化を検討するとよいでしょう。

見通しが悪くなってから整理するより、少し早めに構造を入れるほうが移行コストが小さくなります。

# 汎用とドメインの分離: どこでも使える部品と専用の部品

Atomic Design、FSD、フラット配置と3つのアプローチを見てきました。ここからは、Feature-Sliced Designにも内包されていた、汎用・ドメインの軸を深く見ていきます。
そのコンポーネントが汎用的(generics, general)なものか、ドメイン(domain, feature)に関連するものかという分類です。

![汎用コンポーネントとドメインコンポーネントの依存関係](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-03.png)

これは汎用ライブラリにはない、インハウスならではの論点です。実務で頻繁に直面するにもかかわらず、体系的に語られることが少ないテーマでもあります。

なぜデザイナーがこの区別を知る必要があるのか。この境界を意識しないと「なんでも入る万能コンポーネント」か「どこにも使い回せない専用コンポーネント」の両極端に振れやすいからです。

汎用とドメインの境界を引くことで、プロパティの肥大化と亜種の増殖を同時に防げます。

この境界を設ける目的は、コンポーネントが使える範囲を限定することです。
汎用コンポーネントはどこからでも呼び出せますが、ドメインコンポーネントは特定の機能の文脈でのみ使う、という規約です。

この判断はコンポーネントを作るタイミングでおこなうことが有効です。一度汎用として作ったコンポーネントに、特定の機能でしか使わない表示ルールが入り込むと、後から切り離すコストが高まります。
逆に、最初からドメイン専用として作っておけば、汎用化が必要になったときに方針が明確になります。

Material DesignやAnt Designなどの汎用ライブラリは、あらゆるサービスでの利用を想定しているため、汎用コンポーネントのみで構成されています。

それぞれみていきましょう。

## 汎用コンポーネント: どのサービスでも使える部品

何にでも利用可能なコンポーネント——それが汎用コンポーネントです。

![汎用コンポーネントの例: どのサービスでも使い回せる部品](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-59.png)

たとえば、ボタンは会員登録にも退会にも使われます。このレイヤーのコンポーネントは、特定のデータ構造に依存しないよう設計します。ユーザー名を表示するボタンではなく、テキストを表示するボタン。

汎用かどうかを判断するわかりやすい基準は、まったく別のサービスでもそのまま使えるかどうかです。自社のサービス名やデータモデルに依存しなくても機能するなら汎用コンポーネント、特定のサービスの文脈がないと意味をなさないならドメインコンポーネントと考えるとわかりやすいでしょう。

このことから、汎用コンポーネントは特定のビジネスロジック（業務固有のルールや判断）を内包しないのが原則です。たとえば、求人サイトで`Button`コンポーネントを汎用的に扱うのであれば、「履歴書不要」という文言をコンポーネントに直接埋め込むのは避けるべきでしょう。これは、コンポーネントの設計の中に「ドメイン知識をもっている」と呼ばれる状態です。

逆に、任意のテキストを渡して変えられるようにすることはOK。ボタンはあくまで「押せる」というインタラクションだけを提供し、押された後に何をするか、何とテキストを表示するかは呼び出し側に委ねます。

正しい設計は、`label` プロパティを通じて外からテキストを渡す形です。`<Button label="履歴書不要で応募する" />` のように使えば、同じButtonコンポーネントが「ログイン」にも「購入する」にも使い回せます。

汎用コンポーネントはどこでも使い回せるため、デザインシステムの基盤として強力であり、プロダクトをまたいで共有もできます。一方で、汎用性を高めようとするあまりプロパティが増えすぎて複雑になりがち。

特定画面や特定ドメインでしか使わない機能は後述のドメインコンポーネントに切り出します。

## ドメインコンポーネント: 特定のデータに特化した部品

特定のデータを表示するための専用コンポーネントです。

![ドメインコンポーネントの例: 特定のデータ構造に特化した部品](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-60.png)

たとえば、ECサービスにおける商品カードを考えてみましょう。

商品名、価格、サムネイル画像、在庫状態といった特定のデータを表示することに特化しています。どんなデータが来るか決まっているからこそ、価格のフォーマットや在庫切れ時の表示といった表示ルールをコンポーネント内部に閉じ込められるのです。

あるいは特定の機能に紐づいたUIがプロダクト内のあちこちで使い回されるなら、ドメインコンポーネント化します。逆に、見た目が似ているだけで入るデータや役割がバラバラなら、汎用の`Card`コンポーネントを組み合わせるほうが適切です。

この汎用とドメインの違いは、後述する変数の章で扱うデータの受け取り方にも深く関わってきます。

汎用コンポーネントはプロパティごとに個々の値をバラバラに受け取り、ドメインコンポーネントはデータ一式をまるごと受け取ることが可能、という設計の違いです。

コンポーネントを汎用かドメインかに位置づけることで、使える範囲や使い方が明確になります。また、デザイン管理するのは汎用コンポーネントまで・ドメインコンポーネントは実装者が任意に作る、というように線引きするのもひとつの考え方です。

もちろん、すべてがきれいに分かれるケースばかりではありません。次のセクションでは、実務で判断に迷う境界線上のケースを扱います。

## 汎用とドメインの境界: 答えが一意に決まらないケース

ところで、汎用とドメインも、きれいに分類できないケースも出てきます。
チャット機能の吹き出し（バブル）を例に考えてみましょう。

チャットの吹き出しはドメインか、ボタンのような汎用部品か。

![汎用かドメインか: 視点で答えが変わる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-32.png)

ロジックの複雑さに着目するか、扱うデータの特化度に着目するかで答えが変わります。

ロジックの観点で見れば、テキストを表示するだけであり、またボタンのようにあらゆるサービスで登場しうるという意味では汎用ともいえます。

一方、扱うデータの特化度で見れば、送信者・タイムスタンプ・既読状態といったチャット固有の構造に依存しているので、ドメインともいえます。

特定のオブジェクトにそのまま対応する設計をするのであれば、ドメインコンポーネントとして整理したほうが実務上便利でしょう。

このように、答えが一意に決まらないケースがあります。

社内でこうした境界線上の例をケーススタディとして議論し、自分たちの判断基準を育てていくことです。判断を積み重ねた記録自体が、チームのナレッジになります。

# 早すぎる共通化の罠: 見た目が似ていても目的が違う

プログラミングにはDRY（Don't Repeat Yourself＝重複をなくせ、という開発の格言）という有名な原則があります。しかし近年、エンジニアの間では[AHA（Avoid Hasty Abstractions）](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)＝あわてて共通化するな、という反論も広まっています。

たとえば、2つの画面に見た目がよく似たカードがあったとします。
同じ部品だからとひとつの`Card`コンポーネントにまとめました。ところが後日、片方には「いいねボタン」が追加され、もう片方は「スワイプで消せる」ようになりました。

結果、`hasLikeButton` と `isSwipeable` という互いに無関係なプロパティがひとつのコンポーネントに混在し、全体像を把握しづらい複雑なコンポーネントができあがります。

見た目が似ていることと、目的やドメインが同じことは別の話です。

![早すぎる共通化の罠: プロパティ肥大化](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-20.png)

無理にひとつに統合するよりも、あえて別々のコンポーネントとして持っておくほうが、将来の変更に強くなることがあります。

共通化の判断は、実際に同じパターンが繰り返し現れてからでも遅くありません。

プログラミングの格言に「3回同じパターンが出て初めて共通化せよ（Rule of Three）」があります。2つ似た画面を見てすぐにマスターコンポーネントを作りたくなりますが、3つ目のユースケースが出るまで待つことで、本当に必要なプロパティの形が見えてきます。

この罠は、実在するライブラリの設計判断を見ると鮮明になります。MUIの[`Chip`](https://mui.com/material-ui/react-chip/)と[`Badge`](https://mui.com/material-ui/react-badge/)は、どちらも丸みを帯びた小さな部品ですが、別コンポーネントです。Figmaでの見分け方は明快で、`Chip`はクリックや削除ができるインタラクティブな要素、`Badge`は`Avatar`やアイコンの右上に重ねて配置する通知ドット（アプリアイコンの赤丸の数字）です。

// mui, antの例は見た目がぜんぜん似てないので、そりゃ別こんぽーねんとだろwwwって感じである。どうにかしてほしい

![MUI: Chip（操作できる）と Badge（見るだけ）](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-12.png)

Ant Designでも[`Tag`](https://ant.design/components/tag/)（カテゴリやステータスのラベル）と[`Badge`](https://ant.design/components/badge/)（件数や状態を示すドット）は別コンポーネントとして提供されています。

![Ant Design: Tag と Badge](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-13.png)

見た目の類似ではなく、「触れるかどうか」「何を伝えるか」で分けることが実装上合理的な場合もあれば、スタイルの共用を念頭に共通化することのほうが組織の方針に適している場合もあります。

# ネイティブ要素とカスタムコンポーネント: OSの部品をどこまで活かすか

このセクションはモバイルアプリ中心の話です。

モバイルアプリの構築方法は大きく2つあります。

iOS/Androidそれぞれのネイティブ言語で作る方法と、[React Native](https://reactnative.dev/)や`Flutter`のようなクロスプラットフォームのフレームワークで一度に両方を作る方法です。どちらを選ぶかはエンジニアリングチームの判断要素が多いのですが、デザイナーとして知っておくべきポイントがあります。

いずれのフレームワークにも、ネイティブ要素が存在します。実装で悩みがちなのが、iOSやAndroidのネイティブ要素をどこまで活かすかという問題です。

たとえば、日付選択やセレクトボックス、トースト通知やアクションシート。Figmaではユースケースやブランドを反映した凝ったデザインを作りたくなりますが、これらをゼロからカスタム実装するコストは大きい。加えて、アクセシビリティやOSアップデートへの追従という面でもリスクを負います。

ネイティブUIを採用するメリットは、ユーザーが慣れ親しんだ操作感を提供できるだけでなく、OSのアップデートに自動で追従できることです。Appleが新しいデザイン言語を導入しても、Androidがインタラクションを改善しても、ネイティブUIを使っていればそのメリットを享受できます。

ただし、クロスプラットフォームフレームワーク（FlutterやReact Nativeなど）を使っている場合、事情が異なります。これらのフレームワークはネイティブUIを部分的に独自再現しているため、OSアップデートのメリットをそのまま受けられないことがあります。

いずれの構築方法であっても、デザイナーとして押さえておきたい方針は共通です。

- 基本的には、OS標準のUIをリスペクトする
- 独自性がブランドの核心でない限り、複雑な入力フォームなどはネイティブの挙動に寄せる
- どうしてもカスタムする場合でも、OS標準の挙動をベースにし、必要な部分だけを上書きすることで、挙動の安定性を確保する（Webの場合はHeadless UIの活用も有効）

ネイティブUIの活用方針やフレームワークの選定は、デザインだけでは決めきれない領域です。エンジニアリングチームの技術的な知見と、プロダクトの将来計画をふまえた組織的な判断が必要です。デザインの管理においては、ネイティブUIはデザインシステムのコンポーネントライブラリとは別の枠組みで参照用として用意しておくのが現実的です。

# 命名: デザインシステムで最も長く残るもの

命名は、デザインデータ上ではあまり意識しなくてもよいのですが、実装においては名前がすべてといっても過言ではありません。

Figmaでのコンポーネントはなんとなくインスタンスをコピー&ペーストで配置しますが、フロントエンドやモバイルの実装では、コンポーネント名でコンポーネントを呼び出します。名前を変更するということは、すべての呼び出し箇所を修正するということです。

一度決めたらなるべく変えない（ぐらいの気持ちで設計する）。議論になったことはその場でルール化してドキュメントに残しておかなければ、同じ議論や調整が繰り返されることになります。

コンポーネントの設計にはさまざまな命名が発生します。`Frame 1` や `Property 1` のような命名でFigmaデータを作っても、コード側では必ず命名がおこなわれます。であれば、デザイナーが意味や意図をもとに命名に参加することは意義深いはずです。

命名は設計の一部です。最初につけた名前がそのままコードに入り、ドキュメントに引用され、チームの会話に定着します。後から変えるコストは思った以上に高くなりがちです。

加えて、命名規則が整理されていると、[Cursor](https://www.cursor.com/)や[GitHub Copilot](https://github.com/features/copilot)などのAIコード生成ツールが自社の命名体系に沿った補完をします。逆に、命名がバラバラだとAIもバラバラなコードを生成し、不整合が増えます。

いくつかの勘所をご紹介します。

## 状態やバリエーションを名前に含めない

これは後述する変数の章でも扱う、コンポーネントの状態管理に直結する話です。先にここで概要を押さえておきましょう。

避けたいのは、コンポーネントの名前に状態やバリエーションを含めてしまうことです。たとえば、`RedButton` や `LoadingButton` ではなく、`Button` という名前にして、Figmaのバリアントで `variant` = `danger`、プロパティで `isLoading` = ON のように切り替える設計にします。

なぜかというと、状態やバリエーションを名前に含めると、組み合わせの数だけコンポーネントが増えていくからです。`RedButton` と `LoadingButton` と `SmallButton` が別々に存在していたら、`SmallRedLoadingButton` が必要になった瞬間に命名が破綻します。名前は「何であるか」だけを表し、「いまどんな状態か」はプロパティで表現する。この切り分けが管理のしやすさを決めます。

![命名: 状態を名前に含めると組み合わせが爆発する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-26.png)

バリアント名は役割で選びます。[Nick Babichの分類](https://uxplanet.org/buttons-in-ui-design-four-common-styles-f6bd02468388)では、ボタンを Solid（塗りつぶし）・Ghost（枠線のみ）・Icon-only・FAB（フローティング）の4スタイルに整理しています。`variant`に色名（`Blue`）ではなく、このように表現スタイル（`ghost`）や役割（`primary`）で名付けると、テーマ変更に耐える命名になります。

ただし、利用可能範囲が広いコンポーネントに、1箇所の利用のための改変・拡張がおこなわれるような場合は切り出したほうが管理しやすい場合もあります。

プロパティ名や値の選択肢の命名については、変数の章でくわしく扱います。

見た目が近いコンポーネントをどう名付けるかは、実在するライブラリの判断が参考になります。

Radix UIは`Dialog`（通常のダイアログ）と`AlertDialog`（警告を伴うダイアログ）で「意味の違い」を明示しています。外見はほぼ同じモーダルですが、名前を見るだけで用途の違いが伝わります。

MUIは`Chip`（ユーザーが操作する部品）と`Badge`（見るだけの通知ドット）で「インタラクションの有無」を名前に反映しています。名前がコンポーネントの役割を正確に伝えるからこそ、使う側が迷わずに済みます。

## データモデルとAPI名称: コードの用語と揃える

実装の世界には、バックエンドのデータモデルやAPIで使われている用語体系があります。たとえば、ユーザーの情報は `User`、求人は `Job`、勤怠は `Attendance` といった名前で管理されており、APIのレスポンスにもこれらの名前がそのまま使われています。

ドメインコンポーネントを設計するとき、この用語体系と合わせるかどうかは重要な設計判断です。

ドメインコンポーネントの場合。APIが返す `Shift` というデータを表示するカードなら、`ShiftCard` と名付けるのが自然です。`ShiftCard` というコンポーネント名を見れば、`Shift` のデータを受け取って表示するのだなとすぐにわかります。

Figmaのコンポーネント名、コードのコンポーネント名、APIのデータ名が同じ語彙で通じていれば、会話のたびに頭の中で翻訳する手間がなくなります。

一方、汎用コンポーネントの場合。`Avatar`、`Card`、`Badge` といったUI Kit層の部品は、特定のデータモデルに依存しない名前をつけます。`UserAvatar` ではなく `Avatar`。`ShiftCard` ではなく `Card`。汎用コンポーネントの強みはどのデータにも使えることなので、特定のデータ名をつけた瞬間にその汎用性が失われます。

汎用の`Card`コンポーネントにデータモデルの名前を混ぜてしまうと、別のデータに使いたくなったときに名前が矛盾します。逆に、ドメインコンポーネントに抽象的な名前をつけると、何のデータを表示するのかがぱっと見で分からなくなります。

合わせるべきところで合わせ、離すべきところで離す。この判断の軸になるのは、そのコンポーネントが特定の情報やデータ構造に依存しているかどうかです。

ドメインコンポーネントの命名でAPIの用語体系と合わせたいとき、いくつかの具体的な方法があります。

- APIレスポンス（JSON）を見せてもらい、データがどんな名前で管理されているか確認する
- SwaggerやGraphQLのスキーマを閲覧し、エンティティ名やフィールド名を把握する
- AIに「うちのコードベースではこのデータは何という変数名で扱われていますか？」と聞く

命名で悩む時間を減らし、コードとデザインの語彙を最初から揃えることで、翻訳コストのない設計が可能になります。

![データモデルとコンポーネント名: 揃えるか、離すか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-66.png)

ここまで、コンポーネントの分割・分類・命名という設計のルールを整理してきました。ルールだけでは対処しきれない現実もあります。次の章では、設計したルールが現実にぶつかったときにどう対処するかを扱います。
