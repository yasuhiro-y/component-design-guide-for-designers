# はじめに

こんにちは、タイミーの横田です。

デザインシステムのコンポーネント設計論にフォーカスし、長年さまざまな現場でデザイナーやエンジニアと議論してきた内容を記事にまとめました。

この領域は教科書で学ぶのがとても難しく、実際にコードを書いたり、エンジニアと議論したりする中で泥臭く体得していくものです。そして、同じ組織の中でも、デザインシステムを構築する側と利用する側のデザイナーの間には、感覚に大きな溝がしばしばあります。

Figmaで画面をつくるデザインは、一枚のキャンバスに最終形を描く作業に近いものでした。しかしデザインシステムでは、レゴブロックの突起の形状を設計し、誰でもお城を作れるようにする。絵を描くから建築するへのマインドシフトが必要です。

私はこれまで、自社・他社でその時々のデザインシステムを設計し、組織にインストールするということを何度も経験してきました。デザインシステム自体をどう運用するかについては書籍なども増えてきましたが、実装とデザインを細部で連動させることにいたっては、言語化されていない経験則がたくさんあることを感じていました。

この記事では、デザイナー・エンジニアが日常的に向き合うコンポーネントの設計にフォーカスしてデザインシステムの考え方を整理します。以下の2点を目指します。

1. コードを書かないデザイナーにデザインシステム的な考え方に関するリファレンスを提供する
2. 手探りでデザインシステムを構築しようとする方々に、論点のガイドを提供する

タイミーでどのように実践しているかについては、note の紹介記事にまとめています。本書ではAIに読み込ませて使ったり、よりさまざまな文脈の組織で活用したりできる汎用的なガイドを提供することを優先しています。

さて、デザイナーがどのようにデザインを運用するかは開発工数に大きく影響します。さらには、開発工数やコミュニケーション効率は、デザインによる問題解決の速度にも構造的に影響します。同じチームを別の世界線で比較することはできません。デザインの仕方がチーム全体の生産性にレバレッジをかけるという視点は、あまり語られてきませんでした。

昨今、生成AIによってデザイナーがコードに触れる敷居は大きく下がりました。AIがコードを書いてくれるからこそ、構造の設計を理解する価値が高まっています。それがプロダクトへの関わり方をより深くする機会になります。

デザインシステムへの投資をフェーズによってはおこなわず、短期の価値創出を優先する考え方もあります。しかし現在ではAIの支援で実装コストが下がっており、デザインシステム自体がAIの実装精度をさらに高める好循環につながるポテンシャルがあります。これをAIにコンテキストとして渡すだけで、自社のコンポーネントを使った正確なコードが返ってくるようになります。

取り入れるかはあくまで状況次第ではありますが、デザインシステムの存在価値は現在〜今後の基準で再検討する価値があると考えます。AIがさらに発達してから取り入れる、恩恵を受けられるメンバーが増えてから取り入れる、あるいは後から移行しやすい土台だけ先に整えておく。段階的な選択肢もあります。

この記事は7つの章で構成されています。

- 急いでいる方: コンポーネント分割と変数の2章だけで、日常の設計判断に必要な知識の大半がカバーできます
- じっくり読む方: 原則→戦略→分割→現実的な問題→変数→レイアウト→アセットの順に、抽象から具体へ進みます
- 特定の課題がある方: 気になる章から拾い読みしても問題ありません

もしも読み終えたら、コンポーネントの設計に対する解像度は劇的に向上しているのではないかと思います。

- この記事では、React / Swift / Kotlin / Flutterといった技術スタックを問わず、デザインシステムの構築・運用でアプリでもWebでもよく遭遇する課題を、コンポーネント設計論として体系化することを試みました。わかりやすいよう、馴染み深いFigmaやNotionにたとえるように心がけました。
- デザインシステムに関する諸概念は近年整備が進んだこともあり、登場する用語にはデファクトスタンダードが存在しない場合があります。社内で馴染む呼び方があれば読み替えてください。
- さまざまなファクターをごく総花的に扱います。すべて完璧に理解・運用することよりも、実践を通じて自社にあったやり方を見つけることのほうが重要と考えています。
- 必ずしも実装に連動することがデザインシステムの要件であるとは考えていませんが、この記事は、デザインとコードの一致性をある程度高めることのメリットを念頭に書いています（ややもすれば過激かもしれません）。参考になる部分だけ取り入れるとよいと思います。

# 原則: コンポーネントライブラリがめざすもの

FigmaやSketchのおかげで、デザイナーもコンポーネントの概念には馴染んできたのではないでしょうか。

コンポーネントという言葉は広い意味で使われます。ソフトウェアのモジュール、ハードウェアの部品、ビジネスプロセスの構成要素——いずれも「コンポーネント」と呼ばれることがあります。
この記事では、UIを構成する再利用可能な部品に限定して扱います。Figmaのコンポーネント機能で作るマスターコンポーネントとインスタンスの関係や、コードの関数コンポーネントがこれにあたります。

なぜ私たちはコンポーネントという単位で考えるのでしょうか。

それは、プロダクトを変更しやすくし、一貫性を保つためです。

まずはコンポーネント指向の設計論で知られるいくつかの原則を紹介します。これらを押さえておくと、後の章で登場するプラクティスの背景が見通せるようになります。

## 再利用性と一貫性: 同じものを何度も作らない

まず、再利用性と一貫性です。

同じものを何度も作らない。一度作った品質をどこでも再現できることは、ユーザー体験の安定につながります。Figmaでマスターコンポーネントを更新すれば、すべてのインスタンスに変更が反映されます。コードでも同様です。ボタンの押し心地やエラーの表示方法が画面ごとにバラバラだと、ユーザーは使うたびに学び直す必要があります。

組織の視点で見れば、コンポーネント化はデザインと実装のコスト削減につながります。共通のコンポーネントがなければ、同じUIを作るたびにデザイナーごとの判断が入り、品質のばらつきを引き起こします。組織として決めたデザインをコンポーネントに落とし込んでおけば、誰が使っても同じ品質が再現でき、特定のデザイナーに依存せずに一貫性を維持できます。

![再利用性: 1箇所の変更がすべてに届く](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-23.png)
*再利用性: 1箇所の変更がすべてに届く*

## 変更のしやすさ: 一箇所を直せば全体に届く

次に、広範囲の変更のしやすさです。たとえば、仕様やブランドカラーが変わったとき、一箇所を変えれば全プロダクトに反映できること。これがコンポーネント指向の大きなメリットのひとつです。

たとえば、ブランドカラーを青から赤に変更するとします（別の意味で大変ですね！）。

バラバラに実装されていたら、ボタンのある画面すべてをひとつずつ直さなければなりません。コンポーネントで管理されていれば、トークンの値をひとつ書き換えるだけで済みます。

実際にはブランドカラーの全面変更より、プライマリボタンの角丸を8pxから12pxに統一する、フォントサイズのベースを14pxから16pxに上げるといった地味な変更のほうが頻繁に起こります。こうした変更も、コンポーネント化されていれば一箇所の修正で全画面に反映できます。

デザイナーが少人数でも大規模なプロダクトを運用できるのは、このレバレッジが効いているからです。Figmaでもコードでも同様です。

## 拡張のしやすさ: 他の誰かが安全に追加できるか

再利用性と変更のしやすさに加えて、見落とされがちな原則がもうひとつあります。あなた以外の誰かが、安全に拡張できるかという視点です。たとえば、新しいデザイナーがチームに入ったとき、既存のルールを壊さずに新しい選択肢を追加できるかどうかです。

一般的に、プロダクトは成功するほど大きくなります。機能が増え、画面が増え、関わる人が増えます。コンポーネント、トークン、プロパティの選択肢——これらはすべて、プロダクトの歴史とともに誰かが増やしていくものです。

- 新しいデザイナーがチームに加わったとき
- 事業の拡大で新しいステータスが必要になったとき
- ブランドリニューアルで色のバリエーションが増えたとき

たとえば、ボタンのデザインを変える variant に primary と secondary しかない状態で、新しいデザイナーが「警告用のボタンが欲しい」と思ったとします。命名規則が明確であれば destructive や warning を自然に追加できます。ルールが曖昧であれば、red-button や btn-alert のような名前が生まれ、体系が崩れていきます。

体系がない場合、次のような時系列を辿るでしょう。variant名が色名・略称・英語混在でバラバラです。

1. variant: primary / secondary が存在する
2. 警告用が欲しい → red-button を追加
3. 控えめなボタンも欲しい → btn-light を追加
4. 半年後、primary / secondary / red-button / btn-light / outline-gray が混在し、新メンバーが red-button と btn-light の違いは何ですか？と聞く。答えられる人がいない

最初の2人目が正しく拡張できたかどうかは、10人目の生産性を決定するでしょう。

![命名の体系: ルールの有無が半年後の品質を決める](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-41.png)
*命名の体系: ルールの有無が半年後の品質を決める*

拡張するために参照する体系をルール化することに加え、実装やFigmaファイルから類推可能であることが重要です。これはコンポーネントに限らず、トークンの命名体系、Enumの選択肢、ディレクトリ構造、あらゆる設計判断に通じる問いです。

## 経路依存性: 初期の選択が未来を縛る

経路依存性（path dependency）とは、初期に選んだ道がその後の選択肢を制約し、後戻りが難しくなる現象のことです。Figmaでたとえるなら、最初にAuto Layoutなしで画面を作り始めてしまい、50画面できたところでAuto Layoutに移行しようとしたら、全画面を作り直す羽目になるようなものです。

この現象はライブラリの選択、命名、ディレクトリ構造——デザインシステムのあらゆる要素に関連します。いくつか例を見てみましょう。

たとえば、立ち上げ期に[MUI](https://mui.com/)を採用して管理画面を作ったケースを考えてみてください。最初は開発スピードが出て順調でした。ところが1年後、ユーザー向け画面にも独自のデザインを入れたくなったとき、MUIのスタイル上書きがいたるところに広がっていて、Headless UIに乗り換えようにも影響範囲が大きすぎて踏み切れない。

命名も同じです。初期に `Card` と名付けたコンポーネントが50画面で使われたあとに「やっぱり `Tile` のほうが適切だった」と気づいても、Figma・コード・ドキュメント・チームの会話すべてに染みこんだ名前を変えるコストは、最初に決めるコストとは比べものになりません。

こうした構造は、デザインシステムのあらゆる層に潜んでいます。ディレクトリ構造、プロパティ設計、どれも時間が経つほど方向転換が難しくなります。

だからこそ初期の設計判断は慎重に決める価値がありますが、完璧な判断を最初から下せるわけでもありません。後半の「現実的な問題への対処」で、経路依存性に対する具体的な防御策を扱います。

![経路依存性: 初期の選択が未来を縛る](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-39.png)
*経路依存性: 初期の選択が未来を縛る*

## 関心の分離: ひとつの部品にひとつの責任

コンポーネントの設計は柔軟性がある分、都合でさまざまな要素が詰め込まれ、結局当初めざしていた再利用性や拡張性が破綻する場合があります。

こうした破綻を防ぐために、責任を明確に切り分ける考え方があります。関心の分離と呼ばれます。身近な例で説明します。

たとえば、Figmaでデザインしていると、田中太郎という名前や¥1,500という金額のように、具体的なデータを入れて体験を考えます。しかし、コンポーネントとして設計する際は、具体的なデータに依存しなくても成り立つかどうかを検討する必要があります。

このコンポーネントは、どんなデータが来ても壊れないか？ ユーザー名が極端に長くても、金額が桁あふれしても大丈夫か？

コンポーネント自身が見せ方に責任を持てば、それを利用する側はデータを用意することに集中できます。

関心の分離が崩れると何が起きるか。

たとえば、`UserCard`コンポーネントの中に、Userというデータを受け取って表示するロジックが埋め込まれていたとします。見た目はきれいに動きます。

しかし、同じカードを別の画面で「お気に入り一覧」に使いたくなったとき、そのカードはUser APIの呼び出し先が決め打ちになっているので使い回せません。見た目だけ欲しいのに、データ取得のロジックがくっついてくるからです。

結果として、ほぼ同じ見た目の`UserCard2`が生まれます。この種の「似て非なるコンポーネント」の増殖は、関心の分離が崩れている兆候です。

この考え方を意識できていると、見た目を変えたいのか、データの出し方を変えたいのかが会話の中で自然に切り分けられるようになり、チーム内の連携がスムーズになります。

ひとことで言えば、ひとつの部品にひとつの責任を持たせること。

これが関心の分離の核心です。この考え方があると、Figmaで修正したとき何に影響するかが予測でき、エンジニアに聞く前に安全な変更範囲を判断できます。この記事の各章で、以下のレイヤーを順番に扱っていきます。

- 見た目とデータの分離: コンポーネントが表示に専念し、どんなデータを取ってきて渡すかは呼び出す側が担う。Figmaでいえば、マスターコンポーネントがどう見えるかを決め、インスタンス側がどんなテキストや画像を入れるかを差し替える関係
- 構造とスタイルの分離: 骨組みと見た目の装飾を切り離すこと。後述するHeadless UIの思想。Figmaでいえば、Auto Layoutで組んだ骨組みに、後からスタイルをあてる考え方に近い。[Shadcn/ui](https://ui.shadcn.com/)はこの分離をライブラリレベルで体現した実例で、[Radix UI](https://www.radix-ui.com/primitives)が提供する骨組み（振る舞い＋アクセシビリティ）に[Tailwind CSS](https://tailwindcss.com/)で見た目を上書きする構成になっている
- 汎用とドメインの分離: どこでも使える部品と、特定の機能に特化した部品を混ぜない。Figmaでいえば、どの画面でも使う`Button`と、求人詳細画面専用の`JobCard`を別々に管理すること。コンポーネント分割の章でくわしく扱う

これらはすべて後の章でくわしく扱います。いまは名前だけ覚えておけば十分です。
以下の例はいま完全に理解できなくても問題ありません。記事を読み進めるうちに自然とつながりが見えてきます。

![関心の分離: 3つのレイヤー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-24.png)
*関心の分離: 3つのレイヤー*

たとえば、`UserCard`というコンポーネントひとつをとっても、これらの分離が見えてきます。上記の場合では、`UserCard`の見た目（レイアウトや色）とデータ（ユーザー名やアイコンURL）は分離すべきですし、骨組み（Auto Layoutの構造）とスタイル（色・角丸）も分けられます。`UserCard`自体はドメインコンポーネントですが、その中で使う`Card`（枠）や`Avatar`（アイコン）は汎用コンポーネントです。

これらのレイヤーを意識すると、何をどこに置くべきかの論点がクリアになります。責任を分けておくからこそ、片方だけを変えたり、別の組み合わせで再利用したりできます。この分離の考え方は、後のレイアウトの章で具体的に効いてきます。コンポーネントの中身（padding）と配置（margin）の責任を分ける話は、関心の分離そのものです。

関心の分離をもう一段深めると、見た目と意味の分離にも行きつきます。

Figmaで赤い塗りの四角形を描いたとします。これは「エラー表示」なのか「セール価格の強調」なのか、見た目だけでは判断できません。見た目としてはまったく同じピクセルでも、文脈によって意味が変わることがあります。赤いボタンが「削除」を表す場合もあれば「エラー」を表す場合もある。見た目が正確に再現されていても、意味が伝わらなければユーザー体験としては不十分です。コンポーネントを設計するとき、「視覚的に正確か」と同じくらい「このコンポーネントが表現する意味は何か」を言語化しておくことが大切です。この視点は、命名の章で扱う「色は意味で名付ける」原則にもつながります。

例として、「見た目と意味の分離」を徹底しているのがRadix UIの[`Dialog`](https://www.radix-ui.com/primitives/docs/components/dialog)と[`AlertDialog`](https://www.radix-ui.com/primitives/docs/components/alert-dialog)です。どちらもオーバーレイ付きのモーダルウィンドウで、ピクセル単位ではほぼ同じ外観です。しかし`Dialog`は背景クリックで閉じられる汎用モーダルであるのに対し、`AlertDialog`は「本当に削除しますか？」のような確認用で、背景クリックでは閉じられません。見た目ではなく、ユーザーに強制する操作の意味が違うから別コンポーネントになっています。アクセシビリティの国際標準規格でも、スクリーンリーダーに「通常のダイアログ」と「警告ダイアログ」を区別して伝えるための仕組みが用意されており、この設計判断はその規格に基づいています。見た目の一致と意味の不一致を分けて考える好例です。

![Radix UI: Dialog と AlertDialog の違い](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-11.png)
*Radix UI: Dialog と AlertDialog の違い*

## これらの原則は、なぜビジネスにも効くのか

ここまで紹介した4つの原則は、技術的な話のように聞こえるかもしれません。しかし、それぞれがビジネスの成果に直結しています。

- 再利用性 — 同じUIを1から作り直す工数が減り、新しい機能の開発に時間を使える
- 変更のしやすさ — ブランドリニューアルや仕様変更のリードタイムが短くなり、市場の変化にすばやく対応できる
- 拡張のしやすさ — 新メンバーが既存の仕組みに沿って迷わず貢献でき、チームが大きくなっても生産性が落ちにくい
- 関心の分離 — バグ修正の影響範囲が局所化され、ある画面を直したら別の画面が壊れた、という事故を防げる

デザインシステムへの投資は、目の前の画面をきれいにすることだけが目的ではありません。開発速度、品質の安定、チームのスケーラビリティといった、プロダクト組織全体の成長を支えるインフラへの投資です。この視点を持って設計されたデザインシステムは、それを活用した工数の見通しがたちやすかったり、改修する際に考慮する範囲が特定されていたりするメリットを享受することができます。

再利用性・変更のしやすさ・拡張のしやすさ・関心の分離——この4つの原則を押さえたうえで、次はこの原則をどんな戦略で実現するかの選択肢を見ていきます。

# 構築戦略: どう作るかを選ぶ

コンポーネント設計の具体に入る前に、デザインシステムの構築戦略のパターンをおさえます。

しばしば、プロダクトが生まれる際、それをどう構築するかの検討は入念におこなわれない場合があります。立ち上げの状況では、やはりそれ以上に重要と思われる事情があります。

ある構築方法を選んだ日が、2年後のリブランドの可否を決めていた——そんなことが起こりえます。構築戦略の選択は、その後の自由度や拡大効率を大きく左右します。

ここで紹介する戦略の違いは、デザイナーの日々のワークフローにも影響します。汎用コンポーネントライブラリを採用するなら既存テンプレートのカスタマイズが中心になり、Headless UIベースなら全状態を自分でデザインする責任が生まれます。どちらを選ぶかで、あなたの仕事の範囲が変わります。

自社のフェーズやリソースに合わせて適切な戦略を選ぶ必要があります。

![構築戦略の4パターン: コストと自由度のトレードオフ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-25.png)
*構築戦略の4パターン: コストと自由度のトレードオフ*

## 汎用ライブラリの活用: MUIやChakra UIを土台にする

外部公開されているライブラリをそのまま活用する方法です。[Material UI](https://mui.com/)、[Chakra UI](https://chakra-ui.com/)、[Ant Design](https://ant.design/)などがこれにあたります。どんなサービスにも使える汎用のコンポーネント群です。

すでにひと通りのコンポーネントがそろっているため、すぐに開発を始められるのが強みです。`Button`、`Input`、`Modal`、`Table`など、基本的なUI部品はすべて用意されています。とくに初期フェーズのスタートアップや、管理画面のような機能性重視のプロダクトでは、採用するメリットが大きいです。

一方で、どこかで見たことのあるデザインになりがちです。ライブラリの設計思想に強く依存するため、そこから外れた独自のUIを実現しようとすると、かえって実装コストが高まる場合があります。独自性のあるデザインや機能をもつToCサービスでは、カスタマイズの限界がネックになることがあります。

汎用ライブラリがコードとして提供されている場合、対応する言語やフレームワークはライブラリごとに異なります。WebではReactが多いですが、[Material Design](https://m3.material.io/)は[Jetpack Compose](https://developer.android.com/compose)、[Flutter](https://flutter.dev/)、Angularなどさまざまな環境向けに頒布されています。汎用ライブラリの採用は自社の技術スタックに深く依存します。

また、こうした外部ライブラリへの依存にはいくつか技術的なリスクもあります。ライブラリのアップデートに追従するコストです。大きなバージョンアップで互換性のない変更が含まれると、自社のコード全体を見直す必要が出てきます。カスタマイズしていた部分が動かなくなることもあります。次に、ライブラリ自体の存続リスク。オープンソースのライブラリはメンテナーの運営に依存します。開発が停滞したり、サポート終了になったりすれば、別のライブラリへ移行する大がかりな作業が発生します。

とはいえ、上記のリスクは見通しが不明瞭なプロダクト開発において、短期的なメリットを優先できるのであれば有力な選択肢です。

## フルスクラッチでの構築: 自社専用をゼロから作る

自社専用のデザインシステムをゼロから構成するパターン。

[SmartHR UI](https://github.com/kufu/smarthr-ui)や、[デジタル庁デザインシステム](https://design.digital.go.jp/)などがよい例です。たとえば、SmartHR UIでは、コンポーネント名やプロパティ名を日本語の業務用語に合わせて設計しており、ドメインとの一致を優先する判断が見られます。自社の設計思想を100%反映でき、事業領域に特化したコンポーネントを最適化して、ユーザー体験の質を追求できます。

ただし、作るのにも維持するのにもコストがかかります。ボタンひとつとっても、マウスを乗せたときの変化、キーボードで選択したときの枠線、アクセシビリティ対応など、考えるべき点は山ほどあります。これらをすべて自社でメンテナンスし続ける心づもりが必要です。

後ほど言及しますが、すでに稼働中のプロダクトに後からデザインシステムを適用する場合、BtoCのサービスの場合はこのパターンに至ることがおおいです。

## Headless UIの活用: 見た目を持たないライブラリ

ここ数年で注目されているのがHeadless UIです。Radix UI、[React Aria](https://react-aria.adobe.com/)、[Headless UI](https://headlessui.com/)といったライブラリがあり、多くのプロダクトで採用が進んでいます。

これらは見た目を持たず、機能だけを提供するライブラリです。Figmaでたとえるなら、Auto Layoutの構造だけが用意されていて、色・フォント・角丸は一切ついていない状態のコンポーネント集です。見た目は自分たちで自由にデザインします。

たとえば、ドロップダウンメニューやモーダル、`Combobox`といったコンポーネントは、アクセシビリティへの対応がとても複雑です。これを自社でゼロから正しく実装するのは大変です。Headless UIを使えば、この複雑な裏側のロジックはライブラリに任せつつ、見た目だけを自社のスタイルで自由にあてることができます。車輪の再発明を防ぎながら、自由度を確保できます。

Headless UIの設計思想がよく表れているのが、見た目が似たコンポーネントの分類です。Radix UIには、いずれもドロップダウン的な見た目の[`Select`](https://www.radix-ui.com/primitives/docs/components/select)、[`DropdownMenu`](https://www.radix-ui.com/primitives/docs/components/dropdown-menu)、[`ContextMenu`](https://www.radix-ui.com/primitives/docs/components/context-menu)が別々のコンポーネントとして存在します。`Select`はリストから値を選ぶUI、`DropdownMenu`はメニューからアクションを実行するUI、`ContextMenu`は右クリックで開く操作メニュー。Headless UIライブラリも同様に、[`Listbox`](https://headlessui.com/react/listbox)はドロップダウンで1つ選ぶUI、[`Combobox`](https://headlessui.com/react/combobox)は入力しながら候補が絞られる検索付き選択UI、[`Menu`](https://headlessui.com/react/menu)はアクション一覧、というように分離しています。ポップオーバーが開いて項目が並ぶという見た目は共通しているのに、なぜ分けるのか。それはユーザーが何をしたいか——値を選ぶのか、アクションを実行するのか、検索してから選ぶのか——が違うからです。見た目ではなくインタラクションの目的でコンポーネントを分ける。これがHeadless UIの設計思想であり、後述する「汎用とドメインの分離」にも通じる考え方です。

![Radix UI: 見た目が似た3つのコンポーネント](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-14.png)
*Radix UI: 見た目が似た3つのコンポーネント*

スタイリングは自分たちでおこなう必要があるため、MUIなどの完結型ライブラリに比べれば初期の手間はかかります。しかし、長期的な運用のしやすさを考えれば、初期コストを払う価値は十分にあります（コンポーネント間の一貫性を保ちながら各コンポーネントをスタイリングするのはAIが得意そうです）。

デザイナーにとっては、MUIのように既成のFigmaテンプレートをカスタマイズするのではなく、骨組みに対して自分たちでゼロからスタイルを設計することになります。自由度は高い反面、すべての状態（Hover / Pressed / Disabled / Focus）を自分たちで定義する責任が生まれます。また、公開されているFigmaテンプレートを自社に合うように加工することになりますが、テンプレートが部分的に実装に足りていない場合がよくあります。必要な分だけ最低限取り入れるという割り切りも有効です。

## ハイブリッド戦略: 組み合わせて使う

いくつかのパターンを紹介しましたが、現実的にはこれらを組み合わせることが有力です。

たとえば、`Button`、`Input`、`Checkbox`といった部品はHeadless UIをベースに自社スタイルをあてて構築し、ドメイン固有の部品は自社で独自に開発する。あるいは、プラットフォームが分かれていれば、管理画面はMUIをそのまま使い、ユーザー向けアプリはフルスクラッチで作るなど、組み合わせ方はさまざまです。

また、ベースはフルスクラッチでありながら、一部の実装が複雑なコンポーネントについてはHeadless UIや汎用ライブラリから拝借するという実装方法も存在します（その場合、実装方法の乖離が少ない選択肢が検討されます）。

なんとなく作るのではなく、短期・長期両面でリソースと目的を天秤にかけ、ここはライブラリに頼る・ここは自社の独自性を追求する、という線引きをなるべく初期に議論することが望ましいです。後になるほど方針転換のコストが大きくなるためです。

## 後発導入: 稼働中のプロダクトにシステムを入れる

すでにデザインシステムなしで開発が進んでいるプロダクトに、後からシステムを導入するケースも少なくありません（いや、ほとんどそうだから大変なのです）。

なぜ後発導入が難しいのかを理解しておくと、戦略を立てやすくなります。
ゼロから作るプロダクトなら最初からコンポーネントを揃えられますが、稼働中のサービスにはすでに動いているUIが資産として存在しているからです。ユーザー影響や改修範囲などを考えると、この資産を壊さずに、新しい仕組みに段階的に置き換えていく必要があります。一度に変えると、QA（品質確認）の範囲が爆発し、リグレッション（意図しない既存機能の破壊）が起きやすくなるためです。
このため、再現性や段階的移行の負荷の観点から、フルスクラッチに近い構築になることが多いです。

ただし、中長期的なメリットを見据えたHeadless UIや既存ライブラリの活用も含めて、エンジニアリングチームと早い段階で議論しましょう。技術スタックや既存コードとの相性によって、最適な戦略は大きく変わります。

後発導入で実践的なのは、以下の3ステップです。

1. トークンから入る。 コンポーネントの前に、色・フォントサイズ・余白のトークンを定義して既存コードに適用する。見た目はほぼ変わらないが、後からの一括変更が可能になる。これがもっとも低リスクで効果の高い出発点です
2. 新規画面から準拠する。 既存画面は触らず、新しく作る画面だけをデザインシステムに沿って設計する。新規画面は100%準拠というルールを置くことで、デザインシステムの利用実績が自然に積み上がります
3. 既存画面は優先度をつけて段階的に移行する。 ユーザーの利用頻度が高い画面や、変更が予定されている画面から置き換えていきます

![後発導入: 稼働中プロダクトへの3ステップ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-44.png)
*後発導入: 稼働中プロダクトへの3ステップ*

古いUIと新しいUIが一時的に混在する状態は、どのプロダクトでも起こりうるものです。

混在期間は避けられないと受け入れたうえで、その期間を管理することに意識を向けましょう。全部揃うまで出せないではなく、揃ったところから価値を出すという方針が現実的です。

## 戦略を選ぶ前に: ボトルネックはどこか

構築戦略を決める前に、自分たちのチームで何が本当のボトルネックなのかを診断することが重要です。従来、ボトルネックはUIの実装スピードにありました。しかしAIがコードを書く時代には、事情が変わりつつあります。

実装スピード以上に、フィードバックループの速度——良い決定をするために必要な情報がチーム内で時間内に集まるか、変更の影響を正確に把握できるか——といった「決定の質」が、より大きなレバレッジを持つ段階に入ってきています。たとえば、コンポーネントの分割方針を変えたいとき、影響範囲を30分で把握できるチームと3日かかるチームでは、意思決定の速度が桁違いです。

デザインシステムへの投資も、この視点で優先度を判断すると、自社にとって最も効果的な出発点が見えてきます。

構築戦略と土台の話はここまで。
以降からひとつひとつのコンポーネントをどう設計するか？の具体的な議論に入ります。

# コンポーネント分割: 何をどう分けるか

ボタン、カード、モーダル——同じ名前のコンポーネントなのに、デザイナーとエンジニアの頭の中にある形が違う。そんなすれ違いの多くは分割の基準を策定・共有していないことから生まれます。

ひとつのコンポーネントについて検討すべき要素は多岐にわたります。大まかに次のような考慮事項があります。

- 階層: どこに位置するか
- 名前: コンポーネント名、プロパティ名、値の名前
- プロパティ: 何を受け取り、どんな型か。必須か任意か
- 見た目: バリアント、色、サイズ、レイアウト
- 状態: Loading / Error / Empty / Partial / Ideal
- 依存関係: 何に依存し、何から利用されるか
- トークン: どのデザイントークンを参照するか
- 振る舞い: 幅の伸縮、レスポンシブ対応

ボタンひとつとっても、これだけの要素が同時に存在します。どれかひとつだけを決めればよいのではなく、これらが絡み合ってコンポーネントの設計になります。この記事の各章では、それぞれの要素を掘り下げていきます。

![コンポーネント設計の8つの観点](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-31.png)
*コンポーネント設計の8つの観点*

仮にFigmaとコードの一致性を目指す場合、コンポーネントの命名・ディレクトリ・責務範囲を後から変更するコストが大きい場合が多いです。デザイナー同士の連携、エンジニアとの連携、使用している箇所の改修。利用箇所が多いほど大変です。

だからこそ、個別のコンポーネントをどう名付け、位置づけるかは、誰でも同じ判断ができるよう組織内で整備することが重要です。

## コンポーネント化するか？

前提として、UIはコンポーネント化せずに画面に直接作り込むこともできます。

Figmaでいえば、マスターコンポーネントにせず通常のフレームとして描くことに相当します。つまり、画面に映るものすべてがコンポーネント化されている必要はありません。

では、何をコンポーネント化すると組織が最も恩恵を受けられるのでしょうか。判断の軸はシンプルです。一箇所を直せば全部直る状態にしたいなら、コンポーネント化する。

それ以外は個別対応で構いません。実務ではいくつかの基準が使われています。

- よく使われるUIや汎用用途のものだけをコンポーネント化する
- 2回以上使用されたらコンポーネント化する
- 今後再利用される可能性のあるUIをコンポーネント化する
- 再利用性を問わず、画面上のすべての要素をコンポーネント化する

この考え方はSSOT（Single Source of Truth）と呼ばれます。真実の情報源はひとつだけ、という意味です。Figmaでいえば、コンポーネントのマスターを1つ持ち、全画面でそのインスタンスを使う。マスターを更新すれば全インスタンスに反映される。

たとえば、フッターのリンク一覧。今は1画面にしか置いていなくても、将来2画面目に必要になったとき、コピー&ペーストで増やすとリンクの追加漏れが起きます。コンポーネント化しておけば、元を直すだけで全画面に反映されます。

一方で、見た目が似ているからといって何でも共通化すればよいわけではありません。この判断については「早すぎる共通化の罠」でくわしく扱います。

迷ったときは、以下のフローで判断できます。

![コンポーネント化の判断フロー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-01.png)
*コンポーネント化の判断フロー*
## コンポーネントの分割方法: 3つのアプローチ

コンポーネントの整理方法にはいくつかのアプローチがあります。チームの規模やプロダクトの複雑さに応じて使い分けます。簡単にではありますが、代表的な3つのアプローチを紹介します。

### Atomic Design: 大きさで分ける

[Atomic Design](https://atomicdesign.bradfrost.com/)は、Brad Frost氏が提唱したUIの構造化手法です。化学のメタファーを用いて、UIを以下の5つの階層に分類します。

- Atoms（原子）: ボタン、ラベル、入力フィールドなど、これ以上分割できない最小のUI要素
- Molecules（分子）: 原子を組み合わせた小さな機能単位。検索バーなど
- Organisms（有機体）: 分子や原子を組み合わせた、ひとまとまりのUI領域。ヘッダーやカードリストなど
- Templates: Organismsを配置したページの骨格。実データではなくワイヤーフレーム的な構造
- Pages: Templatesに実データを流し込んだ、最終的な画面

このアプローチは、小さな部品からUIを積み上げるという考え方を広く浸透させました。

ところが、実際に使ってみるとやっかいなのは、moleculesとorganismsの境界線が人によってバラバラになることです。ボタンと入力フォームを組み合わせたら分子なのか、それが特定の検索窓になったら有機体なのか。

実際には、ある程度くずした運用をしている場合が多いです。たとえば、atomsとmoleculesの2層のみを使い、organismsとの境界線に悩む時間を省くという判断もあります。

![Atomic Design: 5つの階層](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-40.png)
*Atomic Design: 5つの階層*

### Feature-Sliced Design: 目的で分ける

Atomic Designは見た目のサイズで分類する考え方でした。もうひとつ、何のための部品かで分類する考え方があります。[Feature-Sliced Design](https://feature-sliced.design/)（FSD）と呼ばれる手法のエッセンスです。

Figmaのページやセクションをどう整理するかを考えるときにも使える視点なので、ここでは3つのレイヤーに絞って紹介します。

**UI Kit レイヤー** — どのプロダクトでも使い回せる、汎用的なUI部品です。`Button`、`Input`、`Avatar`、`Badge`など。

**Features / Domain レイヤー** — 特定のサービスやデータに紐づくコンポーネントです。商品カード、ユーザープロフィール、お気に入りボタンなど。

**Widgets / Templates レイヤー** — 上の2つを組み合わせて作る、大きなかたまりです。ヘッダー、フォーム全体、商品一覧セクションなど。

![Feature-Sliced Design の3層構造](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-02.png)
*Feature-Sliced Design の3層構造*
大事なのは矢印の方向です。上のレイヤーは下のレイヤーを使えますが、逆はありません。

ECサイトで具体的にイメージしてみましょう。

- UI Kit: `Button`、`Input`、`Card`、`Tag` — どんなサービスにも使い回せる
- Domain: `ProductCard`（商品の情報を表示する）、`CartItem`（カート内の1行） — ECサイトのデータに依存する
- Widgets: `ProductListSection`（`ProductCard`の一覧＋フィルター）、`CheckoutForm`（`CartItem`の一覧＋決済ボタン） — Domainの部品を組み合わせた画面の骨格

`ProductCard`は`Button`や`Badge`を使いますが、`Button`が`ProductCard`の存在を前提にすることはありません。

この一方通行が崩れると何が起きるか。`Button`が`UserCard`に依存していたら、`UserCard`を変更するたびに`Button`まで壊れるかもしれません。一方通行であれば、影響は常に下流（利用する側）にしか伝わりません。

Figmaで考えると直感的です。`Button`コンポーネントが`UserCard`のインスタンスを内部に含んでいたら、おかしいですよね。それと同じ感覚です。

### フラットに置く: 階層なしで並べる

すべてのコンポーネントを階層なしにひと箇所にまとめるシンプルな方法です。コンポーネント数が少ないうちは、分類に悩む必要がなく、見通しもよいため十分に機能します。Figmaでいえば、ページやセクションを分けず、すべてのコンポーネントを1つのページにフラットに並べている状態です。小規模なプロダクトでは有効な選択肢です。

ただし、コンポーネントが増えてくるとどこに何があるか分からない問題が目立ってきたり、責務設計に規律がないまま発展しがちです。コンポーネント数が20〜30を超えてきたら（これは厳密なルールではなく、ファイルを開いたときに一覧性を失い始める目安です）、前述のような階層化を検討するとよいでしょう。見通しが悪くなってから整理するより、少し早めに構造を入れるほうが移行コストが小さくなります。

## 汎用とドメインの分離: どこでも使える部品と専用の部品

Atomic Design、FSD、フラット配置と3つのアプローチを見てきました。ここからは、Feature-Sliced Designにも内包されていた、汎用・ドメインの軸を深く見ていきます。
そのコンポーネントが汎用的(generics, general)なものか、ドメイン(domain, feature)に関連するものかという分類です。

これは汎用ライブラリにはない、インハウスならではの論点です。実務で頻繁に直面するにもかかわらず、体系的に語られることが少ないテーマでもあります。

なぜデザイナーがこの区別を知る必要があるのか。
この境界を意識しないとなんでも入る万能コンポーネントかどこにも使い回せない専用コンポーネントの両極端に振れやすいからです。汎用とドメインの境界を引くことで、プロパティの肥大化と亜種の増殖を同時に防げます。

![汎用コンポーネントとドメインコンポーネントの依存関係](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-03.png)
*汎用コンポーネントとドメインコンポーネントの依存関係*
この境界を設ける目的は、コンポーネントが使える範囲を限定することです。
汎用コンポーネントはどこからでも呼び出せますが、ドメインコンポーネントは特定の機能の文脈でのみ使う、という規約です。

この判断はコンポーネントを作るタイミングでおこなうことが有効です。一度汎用として作ったコンポーネントに、特定の機能でしか使わない表示ルールが入り込むと、後から切り離すコストが高まります。
逆に、最初からドメイン専用として作っておけば、汎用化が必要になったときに方針が明確になります。

Material DesignやAnt Designなどの汎用ライブラリは、あらゆるサービスでの利用を想定しているため、汎用コンポーネントのみで構成されています。

それぞれみていきましょう。

### 汎用コンポーネント: どのサービスでも使える部品

何にでも利用可能なコンポーネントです。

たとえば、ボタンは会員登録にも退会にも使われます。このレイヤーのコンポーネントは、特定のデータ構造に依存しないようにします。ユーザー名を表示するボタンではなく、テキストを表示するボタンです。

汎用かどうかを判断するわかりやすい基準は、まったく別のサービスでもそのまま使えるかどうかです。

自社のサービス名やデータモデルに依存しなくても機能するなら汎用コンポーネント、特定のサービスの文脈がないと意味をなさないならドメインコンポーネント、と考えるとわかりやすいです。

上記のことから、汎用コンポーネントは特定のビジネスロジック（業務固有のルールや判断）を内包しないのが原則です。
たとえば、求人サイトで`Button`コンポーネントを汎用的に扱うのであれば、「履歴書不要」という文言をコンポーネントに直接埋め込むのは避けるべきです。これは、コンポーネントの設計の中に「ドメイン知識をもっている」と呼ばれます。
逆に、任意のテキストを渡して変えられるようにすることはOKです。ボタンはあくまで押せるというインタラクションだけを提供し、押された後に何をするか、何とテキストを表示するかは呼び出し側に委ねます。正しい設計は、`label` プロパティを通じて外からテキストを渡す形です。`<Button label="履歴書不要で応募する" />` のように使えば、同じButtonコンポーネントが「ログイン」にも「購入する」にも使い回せます。

汎用コンポーネントはどこでも使い回せるため、デザインシステムの基盤として強力であり、プロダクトをまたいで共有もできます。一方で、汎用性を高めようとするあまりプロパティが増えすぎて複雑になりがちです。

特定画面や特定ドメインでしか使わない機能は後述のドメインコンポーネントに切り出します。

### ドメインコンポーネント: 特定のデータに特化した部品

特定のデータを表示するための専用コンポーネントです。

たとえば、ECサービスにおける商品カードを考えてみましょう。

商品名、価格、サムネイル画像、在庫状態といった特定のデータを表示することに特化しています。どんなデータが来るか決まっているからこそ、価格のフォーマットや在庫切れ時の表示といった表示ルールをコンポーネント内部に閉じ込められるのです。

あるいは特定の機能に紐づいたUIがプロダクト内のあちこちで使い回されるなら、ドメインコンポーネント化します。逆に、見た目が似ているだけで入るデータや役割がバラバラなら、汎用の`Card`コンポーネントを組み合わせるほうが適切です。

この汎用とドメインの違いは、後述する変数の章で扱うデータの受け取り方にも深く関わってきます。
汎用コンポーネントはプロパティごとに個々の値をバラバラに受け取り、ドメインコンポーネントはデータ一式をまるごと受け取ることが可能、という設計の違いです。

コンポーネントを汎用かドメインかに位置づけることで、使える範囲や使い方が明確になります。また、デザイン管理するのは汎用コンポーネントまで・ドメインコンポーネントは実装者が任意に作る、というように線引きするのもひとつの考え方です。

もちろん、すべてがきれいに分かれるケースばかりではありません。次のセクションでは、実務で判断に迷う境界線上のケースを扱います。

### 汎用とドメインの境界: 答えが一意に決まらないケース

ところで、汎用とドメインも、きれいに分類できないケースも出てきます。
チャット機能の吹き出し（バブル）を例に考えてみましょう。

チャットの吹き出しはドメインか、ボタンのような汎用部品か。

ロジックの複雑さに着目するか、扱うデータの特化度に着目するかで答えが変わります。

ロジックの観点で見れば、テキストを表示するだけであり、またボタンのようにあらゆるサービスで登場しうるという意味では汎用ともいえます。
一方、扱うデータの特化度で見れば、送信者・タイムスタンプ・既読状態といったチャット固有の構造に依存しているので、ドメインともいえます。

特定のオブジェクトにそのまま対応する設計をするのであれば、ドメインコンポーネントとして整理したほうが実務上便利でしょう。

このように、答えが一意に決まらないケースがあります。

![汎用かドメインか: 視点で答えが変わる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-32.png)
*汎用かドメインか: 同じコンポーネントでも視点で答えが変わる*
社内でこうした境界線上の例をケーススタディとして議論し、自分たちの判断基準を育てていくことです。判断を積み重ねた記録自体が、チームのナレッジになります。

## 早すぎる共通化の罠: 見た目が似ていても目的が違う

プログラミングにはDRY（Don't Repeat Yourself＝重複をなくせ、という開発の格言）という有名な原則があります。しかし近年、エンジニアの間では[AHA（Avoid Hasty Abstractions）](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)＝あわてて共通化するな、という反論も広まっています。

たとえば、2つの画面に見た目がよく似たカードがあったとします。
同じ部品だからとひとつの`Card`コンポーネントにまとめました。ところが後日、片方には「いいねボタン」が追加され、もう片方は「スワイプで消せる」ようになりました。

結果、hasLikeButton と isSwipeable という互いに無関係なプロパティがひとつのコンポーネントに混在し、全体像を把握しづらい複雑なコンポーネントができあがります。

![早すぎる共通化の罠: プロパティ肥大化](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-20.png)
*早すぎる共通化の罠: プロパティ肥大化*

見た目が似ていることと、目的やドメインが同じことは別の話です。

無理にひとつに統合するよりも、あえて別々のコンポーネントとして持っておくほうが、将来の変更に強くなることがあります。共通化の判断は、実際に同じパターンが繰り返し現れてからでも遅くありません。

この罠は、実在するライブラリの設計判断を見ると鮮明になります。MUIの[`Chip`](https://mui.com/material-ui/react-chip/)と[`Badge`](https://mui.com/material-ui/react-badge/)は、どちらも丸みを帯びた小さな部品ですが、別コンポーネントです。Figmaでの見分け方は明快で、`Chip`はクリックや削除ができるインタラクティブな要素、`Badge`は`Avatar`やアイコンの右上に重ねて配置する通知ドット（アプリアイコンの赤丸の数字）です。

![MUI: Chip（操作できる）と Badge（見るだけ）](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-12.png)
*MUI: Chip（操作できる）と Badge（見るだけ）*

Ant Designでも[`Tag`](https://ant.design/components/tag/)（カテゴリやステータスのラベル）と[`Badge`](https://ant.design/components/badge/)（件数や状態を示すドット）は別コンポーネントとして提供されています。

![Ant Design: Tag と Badge](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-13.png)
*Ant Design: Tag と Badge*

見た目の類似ではなく、「触れるかどうか」「何を伝えるか」で分けることが実装上合理的な場合もあれば、スタイルの共用を念頭に共通化することのほうが組織の方針に適している場合もあります。

## ネイティブ要素とカスタムコンポーネント: OSの部品をどこまで活かすか

このセクションはモバイルアプリ中心の話です。

モバイルアプリの構築方法は大きく2つあります。

iOS/Androidそれぞれのネイティブ言語で作る方法と、[React Native](https://reactnative.dev/)やFlutterのようなクロスプラットフォームのフレームワークで一度に両方を作る方法です。どちらを選ぶかはエンジニアリングチームの判断要素が多いのですが、デザイナーとして知っておくべきポイントがあります。

いずれのフレームワークにも、ネイティブ要素が存在します。実装で悩みがちなのが、iOSやAndroidのネイティブ要素をどこまで活かすかという問題です。

たとえば、日付選択やセレクトボックス、トースト通知やアクションシート。Figmaではユースケースやブランドを反映した凝ったデザインを作りたくなりますが、これらをゼロからカスタム実装するコストは大きい。加えて、アクセシビリティやOSアップデートへの追従という面でもリスクを負います。

ネイティブUIを採用するメリットは、ユーザーが慣れ親しんだ操作感を提供できるだけでなく、OSのアップデートに自動で追従できることです。Appleが新しいデザイン言語を導入しても、Androidがインタラクションを改善しても、ネイティブUIを使っていればそのメリットを享受できます。

ただし、クロスプラットフォームフレームワーク（FlutterやReact Nativeなど）を使っている場合、事情が異なります。これらのフレームワークはネイティブUIを部分的に独自再現しているため、OSアップデートのメリットをそのまま受けられないことがあります。

いずれの構築方法であっても、デザイナーとして押さえておきたい方針は共通です。

- 基本的には、OS標準のUIをリスペクトする
- 独自性がブランドの核心でない限り、複雑な入力フォームなどはネイティブの挙動に寄せる
- どうしてもカスタムする場合でも、OS標準の挙動をベースにし、必要な部分だけを上書きすることで、挙動の安定性を確保する（Webの場合はHeadless UIの活用も有効）

ネイティブUIの活用方針やフレームワークの選定は、デザインだけでは決めきれない領域です。エンジニアリングチームの技術的な知見と、プロダクトの将来計画をふまえた組織的な判断が必要です。デザインの管理においては、ネイティブUIはデザインシステムのコンポーネントライブラリとは別の枠組みで参照用として用意しておくのが現実的です。

## 命名: デザインシステムで最も長く残るもの

命名は、デザインデータ上ではあまり意識しなくてもよいのですが、実装においては名前がすべてといっても過言ではありません。

Figmaでのコンポーネントはなんとなくインスタンスをコピー&ペーストで配置しますが、フロントエンドやモバイルの実装では、コンポーネント名でコンポーネントを呼び出します。名前を変更するということは、すべての呼び出し箇所を修正するということです。

一度決めたらなるべく変えない（ぐらいの気持ちで設計する）。議論になったことはその場でルール化してドキュメントに残しておかなければ、同じ議論や調整が繰り返されることになります。

コンポーネントの設計にはさまざまな命名が発生します。Frame 1 や Property 1 のような命名でFigmaデータを作っても、コード側では必ず命名がおこなわれます。であれば、デザイナーが意味や意図をもとに命名に参加することは意義深いはずです。

命名は設計の一部です。最初につけた名前がそのままコードに入り、ドキュメントに引用され、チームの会話に定着します。後から変えるコストは思った以上に高くなりがちです。

加えて、命名規則が整理されていると、[Cursor](https://www.cursor.com/)や[GitHub Copilot](https://github.com/features/copilot)などのAIコード生成ツールが自社の命名体系に沿った補完をします。逆に、命名がバラバラだとAIもバラバラなコードを生成し、不整合が増えます。

いくつかの勘所をご紹介します。

### 状態やバリエーションを名前に含めない

これは後述する変数の章でも扱う、コンポーネントの状態管理に直結する話です。先にここで概要を押さえておきましょう。

避けたいのは、コンポーネントの名前に状態やバリエーションを含めてしまうことです。たとえば、`RedButton` や `LoadingButton` ではなく、`Button` という名前にして、Figmaのバリアントで variant = danger、プロパティで isLoading = ON のように切り替える設計にします。

なぜかというと、状態やバリエーションを名前に含めると、組み合わせの数だけコンポーネントが増えていくからです。`RedButton` と `LoadingButton` と `SmallButton` が別々に存在していたら、`SmallRedLoadingButton` が必要になった瞬間に命名が破綻します。名前は何であるかだけを表し、いまどんな状態かはプロパティで表現する。この切り分けが管理のしやすさを決めます。

![命名: 状態を名前に含めると組み合わせが爆発する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-26.png)
*命名: 状態を名前に含めると組み合わせが爆発する*

ただし、利用可能範囲が広いコンポーネントに、1箇所の利用のための改変・拡張がおこなわれるような場合は切り出したほうが管理しやすい場合もあります。

プロパティ名や値の選択肢の命名については、変数の章でくわしく扱います。

見た目が近いコンポーネントをどう名付けるかは、実在するライブラリの判断が参考になります。Radix UIは`Dialog`（通常のダイアログ）と`AlertDialog`（警告を伴うダイアログ）で「意味の違い」を明示しています。外見はほぼ同じモーダルですが、名前を見るだけで用途の違いが伝わります。MUIは`Chip`（ユーザーが操作する部品）と`Badge`（見るだけの通知ドット）で「インタラクションの有無」を名前に反映しています。名前がコンポーネントの役割を正確に伝えるからこそ、使う側が迷わずに済みます。

### データモデルとAPI名称: コードの用語と揃える

実装の世界には、バックエンドのデータモデルやAPIで使われている用語体系があります。たとえば、ユーザーの情報は User、求人は Job、勤怠は Attendance といった名前で管理されており、APIのレスポンスにもこれらの名前がそのまま使われています。

ドメインコンポーネントを設計するとき、この用語体系と合わせるかどうかは重要な設計判断です。

ドメインコンポーネントの場合。APIが返す Shift というデータを表示するカードなら、`ShiftCard` と名付けるのが自然です。`ShiftCard` というコンポーネント名を見れば、Shift のデータを受け取って表示するのだなとすぐにわかります。

Figmaのコンポーネント名、コードのコンポーネント名、APIのデータ名が同じ語彙で通じていれば、会話のたびに頭の中で翻訳する手間がなくなります。

一方、汎用コンポーネントの場合。`Avatar`、`Card`、`Badge` といったUI Kit層の部品は、特定のデータモデルに依存しない名前をつけます。`UserAvatar` ではなく `Avatar`。`ShiftCard` ではなく `Card`。汎用コンポーネントの強みはどのデータにも使えることなので、特定のデータ名をつけた瞬間にその汎用性が失われます。

汎用の`Card`コンポーネントにデータモデルの名前を混ぜてしまうと、別のデータに使いたくなったときに名前が矛盾します。逆に、ドメインコンポーネントに抽象的な名前をつけると、何のデータを表示するのかがぱっと見で分からなくなります。

合わせるべきところで合わせ、離すべきところで離す。この判断の軸になるのは、そのコンポーネントが特定の情報やデータ構造に依存しているかどうかです。

ドメインコンポーネントの命名でAPIの用語体系と合わせたいとき、コード上でその概念がどう扱われているかをAIに聞けば簡単に確認できます。命名の整合性チェックとして取り入れやすい手段です。

ここまで、コンポーネントの分割・分類・命名という設計のルールを整理してきました。ルールだけでは対処しきれない現実もあります。次の章では、設計したルールが現実にぶつかったときにどう対処するかを扱います。

# 現実的な問題への対処: 壊れ方を設計する

完璧なデザインシステムは存在しない。でも、壊れ方を設計することはできる。

ここまではコンポーネントをどう設計するかを扱ってきました。ここからは、設計したコンポーネントを運用する中で直面する現実的な課題と、その対処法を見ていきます。

原則の章で触れた経路依存性——初期の選択が未来を制約する性質——がある以上、完璧な初期判断には限界があります。それでも、変更コストを下げる手立てはあります。ここでは3つの防御策を扱います。古いものを安全に終わらせるライフサイクル管理、既存の利用者を壊さない変更の作法、そして100%準拠を求めない例外の設計です。

![安全な変更と破壊的変更: 増やすのは簡単、変えるのは大変](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-27.png)
*安全な変更と破壊的変更: 増やすのは簡単、変えるのは大変*

## 安全な変更と破壊的変更: Figmaの修正がコードを壊すとき

コンポーネントのライフサイクルと密接に関わるのが、変更の安全性という概念です。

まず大前提として、増やすのは簡単で、減らすのと変えるのは大変です。棚に本を1冊追加するのは簡単ですが、すでに置いてある本の背ラベルを全部貼り替えるのは大変な作業です。コンポーネントの変更もまったく同じ構造をしています。デザイナーがFigma上で気軽におこなう修正が、コード側では既存の実装を壊す破壊的変更（Breaking Change）になり得ます。この感覚をデザイナーが持っているかどうかで、エンジニアとの連携のスムーズさが大きく変わります。

安全な変更とは、既存の実装に影響を与えない変更のことです。新しいバリアントの追加、新しい任意プロパティの追加がこれにあたります。たとえば、ボタンに variant = warning を新しく追加しても、いま使われている primary や secondary のボタンは何も変わりません。

一方、破壊的変更とは、既存のコードがエラーを起こしたり、意図しない見た目になったりする変更です。具体的には、プロパティ名の変更、Enumの選択肢の削除や名称変更、新しい必須プロパティの追加などが該当します。Figma上で typo を直したいだけだからとプロパティ名を変えると、コード側ではそのプロパティを参照しているすべての箇所でエラーが起きます。

この区別を知っていると、プロパティ名を変えたいけど今はやめておいて、次のメジャーアップデート（V2）で新旧並行稼働させながら移行しよう、といった判断ができるようになります。エンジニアがよく口にする後方互換性とは、まさにこの話です。これは、冒頭の原則で述べた拡張のしやすさと直結しています。既存を壊さない変更ができる設計は、新メンバーが安心して機能を追加できる土台になります。

Figmaではプロパティを自由に変更でき、インスタンスは自動で追従しますが、コードの世界ではそうはいきません。この非対称性を意識しておくだけで、変更の提案のしかたや移行計画の立て方が変わってきます。

## 例外を許容する設計: 100%準拠は目指さない

デザインシステムに100%準拠を最初から目指すと、運用の負荷が高くなりすぎることがあります。結果として、システム自体が使われなくなるケースも珍しくありません。

90%の定型と10%の例外を最初から織り込んでおくくらいがちょうどよいでしょう。FigmaとコードのUIが完全一致している必要もありません。インターフェース（プロパティの名前と型）が一致していることのほうが、チームの共通理解にとってはるかに重要です。

未整備な規則は後から一括で差し替えしやすいように作っておくこともできます。

たとえば、色の値をハードコードせずトークンで管理しておけば、後から一括変更できます。コンポーネント化されていない要素をいつコンポーネント化するかの基準も決めておくとよいでしょう。「3回以上同じUIが登場したらコンポーネント化を検討する」のようなシンプルなルールで十分です。

## 既存コンポーネントでは理想のデザインが実現できないとき

デザインシステムを運用していると、ありもののコンポーネントではやりたいデザインができない、という場面によく出くわします。

このとき、FigmaでいきなりDetach（コンポーネントとの紐付けを解除すること）してゼロから作り直すのではなく、段階的に検討できるオプションを整理しておくと、チーム全体の判断がブレにくくなります。判断の軸が共有されていれば、人によって対応が変わる問題を防げるためです。

1. 既存コンポーネントの組み合わせで解決できないか？ まず試すべきは、今あるコンポーネントの組み合わせやスロットの活用で目的を達成できないかの検討です。
2. バリアントやプロパティの追加で対応できないか？ 既存コンポーネントに新しいバリアントやプロパティを足すことで、ユースケースをカバーできることがあります。ただし、1つのコンポーネントに機能を詰め込みすぎると複雑になるので、追加が妥当かどうかはチームで判断します
3. 新しいコンポーネントとして切り出すべきか？ 既存とは明確に目的が異なるなら、別のコンポーネントとして新設するのが正解です。その際は命名やレイヤーの配置も含めて設計します
4. 一回限りの例外として許容するか？ 一度きりのキャンペーンページや実験的なUIなら、コンポーネント化せずに個別対応と割り切る選択肢もあります。ただし、同じ例外がN回発生したらコンポーネント化を検討する、というルールをセットにしておきます

このフローをチーム内で共有しておくだけで、サイレントなDetachが減り、デザインシステムへのフィードバックが仕組みとして回るようになります。

![既存コンポーネントで実現できないとき: 4つの選択肢](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-43.png)
*既存コンポーネントで実現できないとき: 4つの選択肢*

ただし、こうしたグレーゾーンはデザイナー間で連携せずにデザインシステムから外れた実装が増える原因になりがちです。例外への対処はしっかり共有・議論し、論点を資産にしていく姿勢をチーム全体で持ちたいところです。

デザインシステムから外れた実装が発生したとき、それを「失敗」と見なすか「データ」と見なすかで、チームの文化は大きく変わります。このコンポーネントだけ使えなかったという声は設計の盲点を示していますし、毎回カスタマイズが必要だったというパターンは新しいバリアントの候補を教えてくれています。逸脱を罰するのではなく、逸脱からシステムを改善するフィードバックループを回すことを目指したいです。

次にコンポーネントを変更するとき、エンジニアに「これは破壊的変更になりますか？」と聞いてみてください。その一言で、移行計画の議論がスムーズに始まります。

ここまで、コンポーネントの運用で直面する現実的な課題を扱いました。ここからは視点を変えて、コンポーネントが外側から受け取る設定値——プロパティ——の設計に踏み込みます。

## コンポーネントのライフサイクル: 終わらせる設計

デザイナーがコンポーネントの廃止プロセスを知っておくべき理由は、Figma上のマスターコンポーネントを消すとき、それがどこに影響するかを判断できるようになるためです。

コンポーネントは作ることに目が行きがちですが、システム運用で本当に難しいのは捨てることです。終わらせるタイミングは誰も教えてくれません。プロダクトが成長すれば、コンポーネントは必ず古くなります。そして、実装では、古い方を残したまま新しいものを追加し、徐々に移行することがよくおこなわれます。

新しいボタンを作ったとき、古いボタンをどう扱うか？

ここに方針がないと、使われなくなったコンポーネントがゾンビのように残り続けます。新メンバーがこれ使っていいんですか？と迷うことになります。

もう使わないでねという意思表示をシステムに組み込んでおく。Figmaなら、コンポーネント名の先頭に [Deprecated]（非推奨：もう使わないでねという印）をつけたり、説明欄に代わりの `NewButton` を明記したり、背景色を目立つ色にする方法があります。コード側でも同様の非推奨マークを付けることで、使おうとしたときに警告が出るしくみがあります。

たとえば、古い `ListItem` と新しい `ListItemV2` が両方存在しているとします。[Deprecated] マークがなければ、新しくチームに入ったデザイナーは2つを見比べて、どちらを使うべきか悩みます。そして多くの場合、慣れている古いほうを選んでしまう。こうして移行が進まなくなります。

[Deprecated]マークなしで新旧コンポーネントを並行運用した結果、1年後に`ListItem`（初代）と`ListItemV2`（改良版）と`NewListItem`（実験版）の3つが共存していたこともあります。新メンバーは最も新しそうな名前を選びますが、実は最新版は`ListItemV2`で、`NewListItem`は実験的に作られて放置されたものでした。

作る責任と同じくらい、終わらせる責任を持つこと。これがデザインシステムを長く健全に保つためのポイントです。

![コンポーネントのライフサイクル](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-22.png)
*コンポーネントのライフサイクル*

このことは、デザインシステムの所有権という問いにもつながります。大聖堂は完成したその日から、毎日の保守が始まります。雨漏りがないか、石が劣化していないか、新しい装飾を加えるべきか。デザインシステムも同じで、常に誰かが目を配り、育て続ける必要があります。その責任をデザインチームが持つのか、エンジニアリングチームが持つのか、それとも横断的なチームを置くのか。この所有権をあらかじめ明確にしておくことが、ライフサイクル管理を機能させる前提条件です。

# 変数: コンポーネントが受け取る設定値

Figmaのプロパティパネルは、コードの設計図そのものです。パネルに並ぶトグルやドロップダウン、あの一つひとつに型があることを意識したことはありますか？　この章を読むと、エンジニアに「このプロパティ、BooleanですかEnumですか？」と自分から確認できるようになります。型の会話ができるだけで、認識のズレによる手戻りが激減します。

## プロパティの型を解剖する: Figmaのパネルはコードの設計図

![Figma プロパティパネルとコードの対応関係](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-18.png)
*Figma プロパティパネルとコードの対応関係*

ここからは、コンポーネントが外側から受け取る設定値——プロパティ——をくわしく見ていきます。
Figmaのコンポーネントプロパティパネルに並んでいるトグルスイッチ、テキストフィールド、バリアントの切り替え。これらはコード上の変数と対応しています。

Notice: この章で変数、プロパティと呼んでいるのは、コンポーネントに渡す設定値のことです。FigmaのVariables機能（デザイントークンを管理するしくみ）とは別の概念です。混同しやすいので注意してください。

Figmaのプロパティパネルを整理することは、コードの設計図を書くことでもあります。この設計図はAIコード生成の精度にも直結します。型が明確に定義されていれば、AIに渡したときに自社のルールに沿った正確なコードが返ってきます。

プロパティには型（Type）があります。Figmaのプロパティパネルで、トグルスイッチなのか、テキスト入力なのか、バリアントの切り替えなのか——その入力方式の違いが、コードでは型として定義されています。

Notionのデータベースを思い浮かべてください。カラムを作るとき、テキスト・数値・チェックボックス・セレクト・日付……と種別を選びます。
あのカラムの種別が、ここでいう型にあたります。

Figmaのプロパティパネルでも同じことが起きています。トグルスイッチはBoolean、バリアント切り替えはEnum、テキスト入力はStringです。Figmaのプロパティパネルではテキスト入力欄に何でも自由に入れられますが、コードの世界では数値の 24 とテキストの "24" は別物です。このプロパティに入る値はテキストなのか、数字なのか、ON/OFFなのかを意識して設計すると、コードとの対応関係が明確になります。

ここでは、`Boolean`、`Enum`、`String`、`Number`、`Date`といった基本の型に加え、配列やオブジェクトといったデータの構造についても解説します。聞き慣れない用語もありますが、ひとつずつFigmaの操作に対応づけていきます。

型の選択を間違えると、Figmaのプロパティパネルは使いにくくなり、実装者は意図を汲み取れず、このコンポーネント、使い方がわからないという声が上がります。型は地味ですが、コンポーネントの使い心地を決定的に左右します。

![プロパティの型: Figma での見え方とコードの対応](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-17.png)
*プロパティの型: Figma での見え方とコードの対応*

以下の表は全体像です。まずはざっと眺めてみましょう。

| 型 | コードでの書き方（参考） | Figmaでの表現 | 設計時に自問すべきこと | よくある落とし穴 |
| -- | -- | -- | -- | -- |
| `Boolean` | `isDisabled: boolean`（ON/OFFの値） | トグルスイッチ | 本当に2択か？将来3択にならないか | 3つ以上並んだらEnumを検討 |
| `Enum` | `size: 'S' \| 'M' \| 'L'`（3つの中から1つ選ぶ） | バリアント（Variant） | 選択肢は網羅されているか | 追加は安全、削除は破壊的変更 |
| `String` | `label: string`（自由なテキスト） | テキスト入力 | 空・長文・改行時の振る舞いは？ | 選択肢があるならEnumにできないか |
| `Number` | `count: number`（数値） | テキスト入力 | 上限・下限・0のときの扱いは？ | 表示フォーマットの定義を忘れない |
| `Date` | `deadline: Date`（日付） | テキスト入力 | フォーマットは誰が決める？ | タイムゾーンの扱いを確認 |
| `Array` | `items: Item[]`（データの一覧） | Auto Layout内の繰り返し | 0件・1件・大量のときどうなる？ | 端のケースも含めてデザインする |
| `Object` | `user: User`（データのまとまり） | 複数プロパティの集合 | 個別の値か、まとまりか？ | 汎用コンポーネントには向かない |
| `Element` | `icon: ReactNode`（別の部品を差し込む） | Instance Swap | テキストだけで本当に十分か？ | 将来UIのかたまりが必要になるか |

### プロパティと値の命名: Figmaとコードの対応をスムーズにする

個々の型に入る前に、プロパティ名と値の命名ルールを整理しておきます。Figmaのプロパティパネルでの命名がそのままコードの変数名になるため、ここでの判断がチーム全体の語彙を決めます。

まず、否定形は避けます。Figmaでいえば、トグルスイッチの名前を無効ではないにするか無効にするかの違いです。isNotDisabled ではなく isDisabled。二重否定は読む人を混乱させます。

Boolean（トグル）は動詞で始めることが多いです。showIcon、hasBorder のように。is は状態（isDisabled）、has はあるかないか（hasBorder）、show は表示するかどうか（showIcon）を表します。

Enumの選択肢は、見た目ではなく意味で名付けます。size なら `S` / `M` / `L` のように体系的に、variant なら `primary` / `danger` のように役割で。`size: default` は曖昧で後から意味がわからなくなりますし、`variant: red` は色が変わった瞬間に破綻します。

表示位置のように複数の選択肢を切り替えたい場合は、Boolean を複数並べるよりもEnumひとつにまとめます。Figmaのプロパティパネルに「左アイコン表示」「右アイコン表示」の2つのトグルが並んでいて両方ONにできてしまう状態を想像してください。hasLeftIcon と hasRightIcon を別々に持つとこの矛盾が生じます。これを1つのドロップダウン iconPosition: 'left' / 'right' / 'none' にまとめれば、常にひとつだけが選ばれます。これがEnum化です。

選択肢の命名で広く使われているのがTシャツサイズです。small / medium / large という呼び方で、省略形なら s / m / l。基準となるサイズを medium に置き、そこから上下に展開していきます。

拡張が必要になったとき、上方向は x-large → 2x-large（xl → 2xl）、下方向は x-small → 2x-small（xs → 2xs）と伸ばせます。最初から全段階を用意する必要はありませんが、この拡張パスを頭に入れておくだけで、命名の破綻を防げます。

もうひとつ意識しておきたいのが、最も代表的な値をスケールの中に正しく位置づけることです。いま選択肢がひとつしかなくても、その値がスケールのどこにあるかを考えておく。

よくある失敗は、最初に作ったサイズを `size = Default` と名付けてしまうパターンです。1年後には Default / Small / Smaller / Tiny の4段階に膨れ上がり、DefaultがLargeなのかMiddleなのか答えられない——こうした事態は珍しくありません。

対策はシンプルです。最初に作るものがひとつであっても、スケールの中での位置を決めてmediumやlargeと名付けます。Defaultはスケール上の位置を表さない名前です。だからこそ、最も代表的な値にはmediumという明確な位置づけを与えておきましょう。

色についても同じことが言えます。variant = Blue としてしまうと、ブランドカラーが変わったときやダークモードに対応したときに名前と実際の色が矛盾します。色は意味で名付けると堅牢です。variant = Primary や variant = Danger のように、その色が果たす役割で呼ぶことで、中身の色が変わっても名前が壊れません。ボタンもバッジもタグも、同じセマンティックカラー体系に基づいて名付けることで、コンポーネント間の一貫性が保たれます。

### Boolean: 真偽値

スイッチのON/OFF、はい/いいえの2択です。コードではtrue/falseという値が入ります。
Figmaではプロパティパネルにあるトグルスイッチで指定するプロパティです。アイコンを表示するかどうか、読み込み中かどうか、といった存在や状態のオンオフを管理します。

たとえば、isRequired（必須かどうか）、isDisabled（操作できない状態かどうか）、showIcon（アイコンを表示するかどうか）。名前の通り、はい/いいえで答えられる性質をそのままプロパティにしたものです。

`Boolean`はシンプルで使いやすい反面、トグルが3つ以上並んだら設計を見直すサインです。トグルが3つあればON/OFFの組み合わせは8通り。そのほとんどは、ありえない状態や矛盾する状態を含んでいます。

たとえば、ボタンのサイズを isSmall と isLarge という2つのBooleanで管理したとします。どちらもOFFなら通常サイズ。では両方ONになったら？ 小さくて大きいボタンは存在しません。こうした矛盾が生まれる時点で、サイズは最初からEnum（Small / Medium / Large の選択式）にすべきだったということです。

![Boolean の矛盾: 2つのトグルより1つの Enum](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-42.png)
*Boolean の矛盾: 2つのトグルより1つの Enum*

Booleanを追加するときは、以下を確認してみてください。

- そのON/OFFは本当に2択か？ 将来3択以上に増える可能性はないか
- 他のBooleanと組み合わせたとき、ありえない状態が生まれないか
- Figmaのバリアント（Enum）で表現したほうがシンプルにならないか
- ひとつのコンポーネントにBooleanが3つ以上並んでいないか

もうひとつ知っておきたいのは、Booleanにはまだ決まっていないがないということです。Figmaのトグルスイッチと同じで、ONかOFFか、必ずどちらかの状態にあります。だからこそ、コンポーネントを新しく作ったとき、そのトグルの初期状態をONにするかOFFにするかをあらかじめ決めておく必要があります。

### Enum: 列挙型

あらかじめ用意された選択肢の中からひとつだけ選ぶ形式です。Notionデータベースのセレクトカラムと同じ考え方です。

FigmaのVariant（バリアント）がこれにあたります。たとえば、size なら small / medium / large のどれか、variant なら primary / secondary のどれか、というように選択肢をあらかじめ定義しておきます。Figmaのバリアントでサイズ = S / M / Lを選ぶ操作を思い浮かべてください。プロパティパネルのドロップダウンから選ぶあの操作そのものが、`Enum`の概念です。

Enumの価値は、あえて制約することにあります。

`String`型は何でも入力できますが、自由すぎるとチームのなかでバラつきが生まれます。`Enum`にして選択肢を絞ることで、迷う場面が減り本質に集中できるようになります。選択肢の体系が、コンポーネントの使い方を暗に伝えてくれます。

たとえば、余白をNumber型の自由入力にすると、14px、16px、18px…と微妙に違う値が画面ごとに増えていきます。これをSpacing Tokenにして Small / Medium / Large しか選べなくすれば、誰が組んでもリズムが整います。トークン化前は画面ごとに5種類以上の余白値が混在していたのが、トークン化後は3種類だけ——余白に関する議論がゼロになるのは、デザインシステム導入のわかりやすい成功指標です。

Enumを設計するときの確認ポイントです。

- 選択肢の名前は見た目ではなく意味で付けているか（Red ではなく Danger）
- 将来の拡張を見越した命名になっているか（新しい選択肢を追加しても既存の名前が不自然にならないか）
- 選択肢の数は適切か（7つ以上あるなら設計を見直すサイン。人が一度に比較できる選択肢は7±2が目安とされており、プロパティの選択肢でもこの感覚は参考になります）
- 同じ意味の選択肢が別の名前で重複していないか

Enumの力が特に発揮されるのが、`Tag`、`Badge`、`Callout` のように色とサイズの組み合わせをまとめて管理するコンポーネントです。

実際のライブラリでも、Enumの設計が見た目の似たコンポーネントを整理する武器になっています。Figmaでいえば、`Badge`と`Tag`の両方にsize（S / M）とcolorScheme（info / success / warning / error）というバリアント軸を揃えておき、`Tag`にだけ「×ボタン表示」のトグルを追加する設計です。

[Chakra UI](https://chakra-ui.com/)はまさにこの構造で、[`Badge`](https://chakra-ui.com/docs/components/badge)と[`Tag`](https://chakra-ui.com/docs/components/tag)が同じ色の体系（colorScheme）と表現の種類（variant）——塗りつぶし（solid）、薄い背景色（subtle）、枠線のみ（outline）——を共有しつつ、`Tag`にだけ閉じるボタンの有無を切り替えるBooleanが加わっています。色と強度の軸は共通の設計言語で揃え、機能の違いだけをBooleanで表現する。このパターンは自社のコンポーネント設計でもそのまま応用できます。

![Chakra UI: Badge と Tag の colorScheme バリエーション](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-16.png)
*Chakra UI: Badge と Tag の colorScheme バリエーション*

たとえば、`Tag`コンポーネントを考えてみてください。情報の種類を表す色（info: 青、success: 緑、warning: 黄、error: 赤）と、表示サイズ（small / medium）の掛け算になります。

これを色とサイズの2つのEnumで管理すれば、Figmaのバリアントは2軸のマトリクスになり、構造が明快です。

### String: 文字列

ボタンのラベルや入力欄のプレースホルダーなど、画面に表示されるテキストデータです。

ここでデザイナーが考えるべきはデータの不在です。もし文字列が空だったら、その領域は詰めるのか、あるいはプレースホルダーを出すのか。ユーザー名が極端に長かった場合、… で省略するのか、折り返すのか。これらはすべてプロパティの仕様として定義しておきたいところです。

文字列型のプロパティを追加するときに確認しておきたいことがあります。

- 空のとき何が起きるか決めたか（領域を詰める？ プレースホルダーを出す？）
- 最大文字数を超えたときの処理を決めたか（省略記号、折り返し、スクロール）
- 改行を含む可能性はあるか（1行テキストか複数行テキストか）
- 本当に自由入力が必要か（選択肢が決まっているならEnumにできないか）

日本語だけでデザインしていると見落としがちですが、同じ意味のテキストでも英語になると幅が1.5〜2倍に膨らむことがあります。たとえば、日本語で「確認」と表示していたボタンが、英語では「Confirm」になります。横幅が固定されたボタンでは、テキストが溢れるか省略されて読めなくなります。

多言語対応の予定がなくても、テキストの長さが変動する前提でコンポーネントを組んでおくことは、堅牢な設計につながります。

たとえば、アイコンとテキストが横に並ぶボタンで、テキストが長くなったときにどうするか。アイコンを非表示にしてテキストを優先するのか、テキストを省略記号で切るのか、折り返して高さを広げるのか。これはコンポーネントの仕様として事前に決めておきたい判断です。

もうひとつ気をつけたいのが、テキストの縦方向の振る舞いです。Figmaのテキストボックスは Auto Height に設定すれば中身に合わせて高さが変わりますが、コードでも同じ挙動になるかはフレームワークや実装方法によって異なります。行の高さ（Line Height）がコンポーネント全体の縦幅にどう影響するかは、デザインとコードで差が出やすいポイントです。

![String型: テキストの振る舞い6パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-33.png)
*String型: テキストの振る舞い6パターン*

### Number: 数値

バッジのカウント数（通知が3件あるときの「3」）や評価スコア（星4.5）など、数値を示すデータです。

文字列と数値の違いは、スプレッドシートを思い浮かべるとわかりやすいでしょう。

セルに数字を入れると右寄せになり、テキストを入れると左寄せになります。あの挙動が示すとおり、数字と文字列は根本的に異なるデータ型です。数値は合計や比較、フォーマット変換などの計算ができるのに対し、文字列はあくまで文字の並びにすぎません。

999+ のように上限を超えた場合の表示ルールや、0のときに非表示にするかどうかといった仕様も、数値型のプロパティに付随する重要な設計判断です。

数値型のプロパティを扱うときに確認しておきたいことです。

- 上限・下限を超えたときの表示を決めたか（999+、0件のときなど）
- 0のとき非表示にするか、0と表示するか
- マイナスの値はありえるか（ポイント残高、差分表示など）
- 単位の表示はコンポーネントの責任か、外から渡すか（円、件、%）

![Number型: 数値の表示ルール](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-45.png)
*Number型: 数値の表示ルール*

### Date: 日付と時刻

カレンダーの予定日、メッセージのタイムスタンプ、クーポンの有効期限。日付や時刻を扱うデータです。
これはFigmaでは表現することができないため、Stringのプロパティで扱うことになるでしょう。

私たちが画面上で見ている 2月17日 や 3日前 といった表示は、裏側では 2026-02-17T14:00:00Z のような機械が読む形式のデータを変換したものです。スプレッドシートでも、セルに日付を入れるとカレンダー形式で表示されますが、中身は数値データですよね。それと同じで、日付データには裏側のデータと画面に出す見た目という二層構造があります。

日付型のプロパティを設計するときの確認ポイントです。

- 日付のフォーマットはコンポーネント内部で決めるか、外部で決めてテキストとして渡されるか
- タイムゾーンの考慮は必要か（海外ユーザーがいるサービスでは要注意）
- 相対表示（3日前）と絶対表示（2月17日）のどちらを使うか、切り替えるか
- 未来の日付と過去の日付で表示を変える必要はあるか（締め切りのカウントダウン、イベント開始までの残り時間など）

ここまでの5つの型（Boolean / Enum / String / Number / Date）で、コンポーネント設計に必要な基礎は揃いました。以降のArray・Object・Elementは、複雑なデータを扱うときに必要になる発展的な型です。今すぐ必要でなければ次の章に進んでも構いません。読み進める方のために、ここからはデータの構造（まとまり方）に関する型を見ていきます。

ひとつ実践的なコツを補足します。たとえば、更新日: 2026/01/01 と表示するUIがあるとき、Figma上のプロパティは 2026/01/01 のテキストだけにし、更新日というラベルはコンポーネント内に固定しておくと、実装との対応が明確になります。

![Date型: 日付の表示形式と設計判断](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-46.png)
*Date型: 日付の表示形式と設計判断*

### Array: 配列（リスト）

同じ種類のデータが複数あるとき、コンポーネントにはそのリストをまるごとプロパティとして渡します。タグの一覧、通知リスト、メニューの項目——こうしたケースです。

Figmaでいえば、同じコンポーネントをAuto Layout内に繰り返し配置する操作にあたります。コードではこれを配列として扱います。

同じ器に異なるデータを流し込む——これが配列型のUIの特徴です。各要素のテキストの内容、`Tag`の有無、ステータスの色はそれぞれ異なりますが、コンポーネント自体は同じものが使い回されます。

ただし、Figmaでは3件分のデータを置くと3件で固定されますが、実際のアプリでは0件になったり100件になったりします。デザイナーが意識しておきたいのは、0件・1件・大量にあるときのそれぞれの見え方です。

- 0件のとき何を表示するか（空状態のデザインは用意したか）
- 上限はあるか（無限に増えるのか、最大表示件数を設けるか）
- 大量にあるとき、無限スクロールかページネーションか
- 並び順は固定か、ユーザーが変えられるか

![Array型: リストの4つの状態](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-34.png)
*Array型: リストの4つの状態*

### Object: オブジェクト（データのまとまり）

名前・アイコン・ステータスのような、複数の情報がひとかたまりになっているケースです。

Notionでいえば、データベースの1行がこれにあたります。ユーザーという1行に、名前・アイコン画像・ステータスがセットで入っているイメージです。

たとえば、ユーザーカードに渡すユーザーというデータを考えてみてください。名前、アイコン画像、ステータス。これらをバラバラのプロパティとして渡すこともできますが、ドメインコンポーネントではユーザーの情報一式としてまとめて渡すほうが自然です。

Figmaのプロパティパネルでは、こうしたデータのまとまりを直接表現する方法がありません。名前・アイコン・ステータスをバラバラのプロパティとして並べるしかないのです。しかし、コード側ではユーザーというひとつのまとまり（オブジェクト）として渡せます。

デザイナーが意識しておきたいのは、このコンポーネントに渡すデータは、個別の値なのか、まとまりなのか、という点です。`Avatar`なら画像URLだけで十分（個別の値）。`UserCard`ならユーザーの情報一式が前提（まとまり）。この判断が、コンポーネントを汎用にするかドメイン専用にするかの分かれ道です。

Figmaのプロパティパネルで見比べてみると、この違いがはっきりします。`Avatar`のパネルにはimage、altTextの2項目だけ。一方`UserCard`にはuserName、userImage、rating、status、isVerifiedとずらりと並びます。

プロパティが20個並んだコンポーネントは、使う側にとって何をどう設定すればいいかわからないものになります。逆に粒度が粗すぎると汎用性がなくなります。いま手元のFigmaで、プロパティが10個を超えているコンポーネントを探してみてください。それはドメイン専用として認識すべきサインかもしれません。

オブジェクトの中で特に気をつけたいのは、データの一部が欠けているケースです。ユーザー名はあるけどアイコン画像がない、評価スコアがまだ付いていない。こうした歯抜けのデータにどう対応するかを、コンポーネントの仕様として決めておく必要があります。

また、オブジェクトをまるごと受け取る設計は、そのコンポーネントが特定のドメインに紐づいていることを意味します。コンポーネント分割の章で触れたように、汎用コンポーネントは個々の値をバラバラに受け取り、ドメインコンポーネントはデータ一式をまとめて受け取るのが基本です。

Objectを受け取るコンポーネントを作ろうとしているなら、それはドメインコンポーネントとして位置づけるのが自然でしょう。

![Object型: 個別の値 vs データのまとまり](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-47.png)
*Object型: 個別の値 vs データのまとまり*

### Element: 要素

ここまでの型（`Boolean`、`Enum`、`String`、`Number`など）はすべて、テキストや数値といったデータを渡すものでした。しかし、プロパティに渡したいのがデータではなく別のコンポーネントであそのものというケースがあります。

Figmaで考えるとわかりやすいです。Instance Swap Propertyを使って、ある箇所にアイコンを差し込んだり、`Avatar`に差し替えたりしますよ。コードの世界ではこれをElement型と呼びます。好きなものを差し込める口を設けておく設計で、スロットとも呼ばれます。

たとえば、カードの説明文を表示する箇所を考えてみてください。通常はテキストを渡せば十分です。しかし、テキストの一部をリンクにしたい場合はどうでしょうか。String型ではここからここまでがリンクという情報を表現できません。リンクを含んだUIのかたまりをまるごと渡す必要があります。

あるいは、リストアイテムの左側に置くものが、ある画面ではアイコン、別の画面では`Avatar`。こうした場合にスロット（Element型のプロパティ）があれば、何を差し込むかは利用者に委ねられます。

スロットの威力がもっともわかりやすいのは、バリアントの爆発を防げる点です。

アイコン付きボタンの例で考えてみましょう。デザイナーは LeftIcon / RightIcon / BothIcons / NoIcon という4つのバリアントを作りがちです。しかし、スロットの発想を使えば、ボタンの左右に好きなものが入るエリアを用意するだけで済みます。アイコンでも、バッジでも、何も入れなくてもよい。

![Button のスロット構造: 差し込み口を設けることでバリアント爆発を防ぐ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-04.png)
*Button のスロット構造: 差し込み口を設けることでバリアント爆発を防ぐ*
Figmaでは、Instance Swap Propertyを使ってスロットを表現します。設計のポイントは2つです。

- 何も入れないを選択肢に含める。空のプレースホルダーコンポーネントを候補に入れておけば、アイコン不要な場面でも対応できる
- 差し込める対象を制約する。Instance Swap Propertyで差し替え候補を同じカテゴリに限定し、意図しない使い方を防ぐ

設計時に考えておきたいのは、その箇所にテキストを渡すだけで本当に十分か、それとも将来的にUIのかたまりを渡す必要が出てこないか、という点です。最初はStringで足りていても、後からリンクやアイコン付きテキストが必要になるケースは少なくありません。

![Element型（スロット）: 差し込み口で中身を自由に](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-48.png)
*Element型（スロット）: 差し込み口で中身を自由に*

ここまで個々の型を見てきました。ここからは、複数のプロパティが組み合わさったときにどう振る舞うかを考えます。

## プロパティの直交性: 組み合わせが壊れない設計

Figmaでバリアントを追加したとき、既存の組み合わせが意図しない見た目になった経験はないでしょうか。サイズを増やしたら色との組み合わせが崩れた。新しいプロパティを足したら、既存のプロパティとの関係が曖昧になった。

それはプロパティ同士が暗黙に依存していることが原因かもしれません。

ここまで個々の型を見てきましたが、実際のコンポーネントではプロパティが複数組み合わさって使われます。このとき大事になるのが、プロパティ同士が互いに干渉しないという考え方です。これを直交性と呼びます。Figmaでバリアントを設計するとき、この感覚があると組み合わせの破綻を未然に防げます。

あるプロパティの値を変えたとき、他のプロパティの意味や振る舞いまで変わってしまうなら、そのプロパティ同士は独立していません。独立したプロパティは、どんな組み合わせでもそれぞれが決まり通りにはたらきます。

Booleanの章で、小さいと大きいのトグルを別々に持つと矛盾するという話をしました。これは直交性が崩れた典型例です。ここではもう少し踏み込んで、Enum同士の設計でこの考え方がどう効いてくるかを見ていきます。

たとえば`Button`に`size`と`variant`の2つのプロパティがあるとします。`size`はS・M・Lの3段階、`variant`はprimary・secondary・destructiveの3種類。この2つが直交していれば、どの組み合わせでもそれぞれが決まり通りにはたらきます。

![直交性: size と variant の組み合わせがすべて成立する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-05.png)
*直交性: size と variant の組み合わせがすべて成立する*

sizeをSからLに変えてもvariantの見た目は変わらない。variantをdestructiveに変えてもsizeは影響を受けない。3×3＝9通りすべてが成立します。もし「destructiveのときはSが使えない」「secondaryのLだけ角丸が変わる」といった暗黙の制約があったら、組み合わせるたびにルール確認が必要になります。

Notionのデータベースで考えるとわかりやすいです。優先度と担当者という2つのカラムがあるとして、優先度を高に変えても、担当者のリストは何も変わりませんよね。これが独立している状態です。もし優先度を変えた瞬間に担当者の選択肢が勝手に絞り込まれたら、使う人は混乱します。コンポーネントのプロパティも同じです。

たとえば、タグの部品に色の種類と色の強さの2つのプロパティがあるとします。色の種類は情報・成功・警告・エラーといった意味を表し、色の強さは塗りつぶし・薄い背景・背景なしといった濃度を表します。この2つは独立しています。種類を変えても強さの振る舞いは変わらないし、強さを変えても種類の意味は変わりません。

![直交性: colorScheme と variant の組み合わせマトリクス](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-28.png)
*直交性: colorScheme と variant の組み合わせマトリクス*

ここで、背景なしを色の強さではなく形状のプロパティに入れてしまうとどうなるでしょうか。形状を変えただけなのに背景色が消え、色の種類と強さの組み合わせで決まるはずの配色システムが無効化されます。形状のプロパティが、色のシステムに暗黙的に優先してしまう。これが直交性の崩れです。

背景なしを色の強さ側に置いておけば、背景はないけど角丸はついているように、それぞれのプロパティが独立して動いた結果がそのまま反映されます。視覚的に意味が薄い組み合わせが生まれることはありますが、プロパティ間に暗黙の依存が生まれるよりもずっと健全です。

プロパティを設計するときに意識したいのは、この問いです。

- このプロパティの値を変えたとき、他のプロパティの意味や動きまで変わらないか
- 2つのプロパティの組み合わせに暗黙の優先順位が生まれていないか
- ひとつのプロパティが複数の関心事をまとめて扱っていないか

直交性が保たれていると、プロパティを追加するたびに既存の組み合わせを紐解く必要がありません。逆に、プロパティ間に暗黙の依存があると、機能を足すたびに優先順位の整理が必要になり、そのルールは時間とともにチーム内で忘れられていきます。

Figmaの[Propstar](https://www.figma.com/community/plugin/1116018586739867857/propstar)というプラグインを使うと、コンポーネントのすべてのプロパティ組み合わせを一覧表示できます。直交性が保たれているかの確認や、プロパティのヌケモレの発見に便利です。

## トークンの共有: 複数コンポーネントの一貫性を保つ

ここまでは個々のコンポーネントのプロパティ設計を見てきました。もう一歩引いて、複数のコンポーネントにまたがる設計について触れておきます。

色やサイジングの体系は、複数のコンポーネントで使い回せるように設計しておくと便利です。こうした共通の値に名前をつけて一元管理する仕組みをトークンと呼びます。Figmaでいえばスタイルやバリアブルに近い概念です。

Figmaでは、`Tag`の色を変えたければ`Tag`のスタイルを編集し、`Callout`の色も変えたければ`Callout`のスタイルも別途編集する——というコンポーネントごとの作業になりがちです。しかしコードの世界では、共通のトークンを参照する仕組みがあれば、トークンの値をひとつ変えるだけですべてのコンポーネントに反映されます。

たとえば、`Tag`の info と `Callout` の info が同じセマンティックカラーを参照していれば、色を変えたいときに一箇所の修正で両方に反映されます。バラバラに定義していると、デザイナーが個別に色を選ぶたびに微妙なズレが蓄積し、`Tag`は青いのに`Callout`は水色、という不一致がいつの間にか生まれます。

![トークンの共有: 複数コンポーネントの一貫性を保つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-06.png)
*トークンの共有: 複数コンポーネントの一貫性を保つ*
色だけの話ではありません。兄弟関係にあるコンポーネント（`Button` / `IconButton` / `CopyButton`など）では、縦幅やアイコンのサイズも共通のトークンを参照しておくと一貫性を保ちやすくなります。

こうしたトークンを一元管理しておけば、`Tag`の配色を微調整したいときに、共通構造を持つすべてのコンポーネントに変更が波及します。トークンを使わず個別のコンポーネントに値を直接書き込んでいたら、ひとつずつ直すことになります。

## UIスタック: コンポーネントが取りうる5つの状態

ここまでプロパティの型と組み合わせについて見てきました。ここからは、コンポーネントが取りうる状態の設計に移ります。

デザインするとき、データが完璧に入った理想的な状態を中心に描くのは自然なことです。しかし、コンポーネントを実装するときに必要になるのは、すべての状態の定義です。Empty stateをデザインしないまま実装に渡すと、データが0件のとき画面が真っ白になり、ユーザーは機能が壊れたと思います。

[Scott Hurff](https://www.scotthurff.com/posts/why-your-user-interface-is-awkward-youre-ignoring-the-ui-stack/)（UIデザイナー・著述家）が提唱したUIスタックという概念では、UIには以下の5つの状態があるとされています。

1. Ideal State: データが完璧に入った状態。Figmaで最初にデザインする状態
2. Empty State: データが空の状態。リストが0件のとき、`Avatar`の画像がないとき
3. Loading State: 読み込み中。スケルトンスクリーンやスピナー
4. Partial State: データが不完全な状態。ユーザー名はあるけどアイコンがない、商品情報はあるが画像が未登録、など
5. Error State: 読み込み失敗やバリデーションエラー

新しいコンポーネントを設計するとき、以下の5つの状態をすべて定義してから実装に渡してください。

この5つの状態の区別は、見た目が似たコンポーネントを分離する根拠にもなります。

MUIでは、ユーザーへのフィードバックという同じ目的を持ちながら、[`Alert`](https://mui.com/material-ui/react-alert/)（ページ内に常駐するお知らせ欄）、[`Snackbar`](https://mui.com/material-ui/react-snackbar/)（画面下部に一瞬だけ出る通知。トーストとも呼ばれます）、[`Dialog`](https://mui.com/material-ui/react-dialog/)（操作を中断して確認を求めるモーダル）を別々のコンポーネントとして提供しています。

`Alert`はError StateやPartial Stateの表示手段、`Snackbar`は操作完了後の一時通知、`Dialog`は操作前の確認。見た目が似ていても、UIスタックのどの層で使われるかが違えば、コンポーネントとして分けるのが自然です。

- □ Ideal State — データが揃った理想の見た目
- □ Empty State — データが0件のとき。「まだ○○がありません」のような案内を添える
- □ Loading State — 読み込み中。スケルトンかスピナーかを指定する
- □ Partial State — 一部のデータが欠けている場合の見た目（アイコン未設定、評価なし等）
- □ Error State — 読み込み失敗時。ユーザーが次に何をすればいいかを示す

ひとつでも欠けていると、実装者が独自に判断するか、差し戻しが発生します。

これら5つの状態は、以下のように遷移します。

![UIの5つの状態と遷移](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-07.png)
*UIの5つの状態と遷移*
ユーザーカードや求人リストなどのドメインコンポーネントでは、これらの状態をあらかじめ定義しておく必要があります。読み込み中、データが空、エラーといった状態ごとの見た目をFigmaのバリアントとしてデザインしておきます。たとえば、state というバリアント軸に ideal / empty / loading / error を用意する方法が一般的です。

成功したときの理想的な画面だけでなく、失敗時やデータ欠損時の見た目もコンポーネントの仕様に含めておくと、実装時にこの状態のデザインがありませんという差し戻しがなくなります。

特にPartial Stateはデザイナーが最も見落としやすい状態です。 Ideal StateとEmpty Stateは意識しやすい——データがあるか、ないか。しかし現実のデータはある/ないの二択ではなく、一部だけあることのほうが圧倒的に多いのです。

たとえば、ユーザープロフィールカードで考えてみてください。ユーザー名はあるがプロフィール画像を登録していない。評価スコアはあるがレビュー件数が0件。自己紹介文は入力されているが、スキルタグが未設定。

これらの組み合わせは膨大です。すべてをデザインするのは現実的ではありませんが、少なくとも各データ項目が欠けたとき、その領域をどう扱うかのルールは決めておく必要があります。

実践的な対処としては、データ項目ごとにフォールバック（代替表示）を定義しておくことです。

![Partial State: データ欠損時のフォールバック](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-35.png)
*Partial State: データ欠損時のフォールバック*

| データ項目 | 欠損時の代替表示 |
| -- | -- |
| プロフィール画像 | イニシャルアイコン |
| 評価スコア | 「—」を表示 |
| 自己紹介文 | 領域ごと詰める |
| スキルタグ | セクション非表示 |

こうしたルールがコンポーネントの仕様に含まれていれば、データが欠けても画面が壊れません。

ここでひとつ、デザイナーが混乱しやすいポイントがあります。

UIスタックで扱っている Loading や Error は、コンポーネントの状態です。これは前の章で扱った外から渡す設定値（プロパティ）とは性質が異なります。

違いを日常に置き換えてみます。信号機でいえば、この信号機は車道用であるというのが外から設定されるプロパティです。一方、いま赤か青かはその信号機自身が切り替える状態です。

Figma上では、プロパティもバリアントとして表現されます。しかしコードでは、外から渡す設定値（props）とコンポーネント自身が管理する状態（state）は明確に区別されます。

この区別をFigma上でも見分けやすくするために、Figma専用プロパティの命名規約の章で触れた `_` プレフィックスのように、状態を表すプロパティに目印をつけておくのが有効です。たとえば、`_state` や `_isLoading` のように命名しておけば、デザインと実装の間の認識のズレを防げます。

ここまで扱った Loading や Error はシステム側の状態——データの有無やAPIの成否によって決まるものでした。コンポーネントにはもうひとつ、ユーザーの操作に伴う見た目の変化があります。これもまた状態の一種ですが、性質が異なるので分けて整理します。

## インタラクション状態: ユーザーの操作に応じた見た目の変化

ボタンの上にマウスカーソルを乗せたとき、押し込んでいるとき、操作できない状態のとき。これらはそれぞれ Hover、Pressed、Disabled と呼ばれます。Figmaでは Interactive Components の機能で表現できます。

ここで大事なのは、こうしたインタラクション状態のルールをコンポーネントごとに個別に決めないことです。Hover時は現在の背景色に対してオーバーレイを8%重ねる、Disabled時は不透明度を38%に下げる——こうしたルールをトークンとして一元管理しておけば、新しいコンポーネントを作るときにゼロから設計する必要がなくなります。[Material Design 3のState Layer](https://m3.material.io/foundations/interaction/states/state-layers)がこの考え方の参考になります。

デザイナーが見落としがちなのがフォーカス状態です。マウスを使わずキーボードのTabキーで画面を操作するユーザーにとって、いまどの要素にフォーカスがあるかを示すフォーカスリング（枠線）は不可欠な手がかりです。フォーカスリングの色、太さ、オフセットをコンポーネント横断で統一しておくことが重要です。

すべてのインタラクティブなコンポーネントに対して、Hover、Pressed、Disabled、Focusの見た目を定義しておくと、実装の抜け漏れが減り、操作方法を問わず一貫した体験を提供できます。

![インタラクション状態: 5つの見た目を統一ルールで管理する](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-29.png)
*インタラクション状態: 5つの見た目を統一ルールで管理する*

### アクセシビリティ: コンポーネントに組み込む

アクセシビリティを個々の画面で毎回対応していくのは、現実的に大変です。だからこそ、コンポーネントに吸収できるところは吸収しておきたい。コンポーネントレベルで組み込んでおけば、使うだけで基準を満たせる状態が作れます。

たとえば、色のコントラスト比をトークンレベルで保証しておけば、そのトークンを使うすべてのコンポーネントが自動的に[WCAG](https://www.w3.org/WAI/standards-guidelines/wcag/)基準を満たします。前述のフォーカスリングも同じです。コンポーネント横断で統一しておけば、個別に対応する必要がなくなります。

アイコンやイラストに代替テキスト用のプロパティ（altText / ariaLabel）を設けておくことも、コンポーネントへの吸収のひとつです。スクリーンリーダーを使うユーザーにとって、この情報がなければアイコンは存在しないのと同じです。

こうした対応をコンポーネントの仕様に含めておくと、利用する側が個別に対応する手間がなくなり、プロダクト全体のアクセシビリティが底上げされます。

ただし、アクセシビリティはコンポーネント単体ですべて担保できるわけではありません。ページ全体の構造、読み上げ順序、ランドマークの設計など、コンポーネントの外で決まる要素も多くあります。コンポーネントに吸収できるところを吸収しつつ、プロダクト全体としてのアクセシビリティ方針は別途チームで議論しておく必要があります。

UIスタックとインタラクション状態でコンポーネントの状態設計を扱いました。ここからは、Figmaでは表現しきれないコードとの差分に踏み込みます。

## Figmaだけでは伝わらない変数の性質: コードとの差分を知る

ここまで紹介した型はFigmaのプロパティパネルでもある程度表現できます。しかし、コードの変数にはFigmaだけでは伝えきれない性質がいくつかあります。

知っておくだけで、エンジニアとの会話がぐっとスムーズになるポイントです。

### 必須と任意: デフォルト値で使いやすさが決まる

なぜこの区別が重要なのか。コンポーネントのプロパティが10個あるとき、そのすべてが毎回指定必須だとしたら、使うたびに10項目を埋める手間がかかります。

逆に、ほとんどが任意でデフォルト値を持っていれば、使う側は変えたいところだけを指定すればよい。必須と任意の設計は、コンポーネントの使いやすさを直接的に決めます。

必須を最小限にとどめ、よく使われる値をデフォルトに設定しておくことで、8割のユースケースは何も指定しなくてもそのまま使える状態を目指します。

コードでは、変数が必ず渡さなければならないか、省略してもよいかが明確に定義されます。省略できる変数には通常、デフォルト値が設定されています。省略された場合に自動的に使われる値のことです。

たとえば、ボタンコンポーネントの size が任意で、デフォルト値が Medium であれば、利用者が size を指定しなくても中サイズのボタンが表示されます。一方、label が必須であれば、テキストなしでボタンを使うことはできません。

Figmaのプロパティパネルには、この値は必須かどうか、省略時のデフォルトは何かを表現する仕組みがありません。すべてのプロパティに常に何らかの値が入った状態で表示されます。

そのため、何がデフォルトで何が意図的な指定なのかが区別できないのです。

これを補うには、Description欄に「デフォルト: Medium」のように明記しておくのがもっともシンプルです。また、何も指定しなかったときの見た目を最初のバリアントとして配置しておくと、利用者がこれがデフォルトかと直感的に理解できます。

ただし、デフォルト値は一度決めたら簡単には変えられません。コードの世界では、デフォルト値を変更すると、明示的に値を指定していなかったすべての箇所で表示が変わります。sizeのデフォルトをMediumからSmallに変えれば、何も指定していないボタンがすべて小さくなる。影響範囲が広いぶん、デフォルト値の決定はかなり慎重におこなう必要があります。

![必須と任意: デフォルト値で使いやすさが決まる](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-36.png)
*必須と任意: デフォルト値で使いやすさが決まる*

### 条件付き表示: Figmaとコードでプロパティの数がズレる理由

Figmaでコンポーネントを作るとき、ある要素を表示/非表示にするためにトグルを追加した経験はないでしょうか。エンジニアに「このトグル、コード側では要らないんですよ」と言われて戸惑ったことがあるかもしれません。Figmaの制約とコードの表現力の違いが現れる場面です。

たとえば、カードにサブタイトルを出すかどうかを切り替えたいケースを考えてみます。実はコード側では、この挙動をもっとシンプルに実現できます。

コード側ではサブタイトルのテキストというプロパティが1つあれば十分です。テキストが渡されれば表示し、渡されなければ領域ごと消える。1つのプロパティで中身と表示/非表示を同時に制御できます。

しかしFigmaでは、この挙動を再現するためにサブタイトルを表示するかどうかのトグルとサブタイトルのテキストという2つのプロパティが必要です。コードでは1つで済むことが、Figmaでは2つに分かれるわけです。

こうしたFigmaと実装のプロパティ数のズレは避けられません。大切なのは、このズレがあることをチームで認識し、ルール化しておくことです。認識が共有されていないとFigmaと実装でプロパティの数が合わないという無駄な議論が繰り返されるためです。

![条件付き表示: Figmaでは2つ、コードでは1つ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-37.png)
*条件付き表示: Figmaでは2つ、コードでは1つ*

ここまで、コンポーネントが何を受け取るかを扱いました。次はどこにどう置くか——レイアウトの設計です。

# レイアウト: コンポーネントの中身と置き方を分離する

変数の章ではコンポーネントが何を受け取るかを扱いました。ここからは、コンポーネントをどう配置するかという別の設計軸に移ります。

冒頭の原則で紹介した関心の分離が、もっとも具体的に効いてくる領域です。コンポーネントの中身と置き方を分離する——余白、区切り線、幅の振る舞いをどう設計するか。FigmaのAuto Layoutの設定をイメージしながら読むと理解しやすいでしょう。

核心はシンプルです。コンポーネントは自分の中身だけに責任を持ち、どこに置くかは親に任せる。

この分離が曖昧だと、ボタンをここに置いたら余白がおかしい、カードの幅が想定と違うという問題が再利用のたびに発生します。逆に、この原則が徹底されていれば、同じコンポーネントがどんなレイアウトの中に置かれても意図通りに振る舞います。

## 外側の余白: コンポーネントに含めない

コンポーネントの外側にmarginを含めるか含めないか。このひとつの判断で、再利用するたびに余白を手動で調整する手間がなくなります。

Figmaでコンポーネントを作るとき、ボタンの下に24pxの空白を含めた状態でコンポーネント化するケースは珍しくありません。Figma上では使いやすいのですが、コードに反映されると、別の場所で使うたびに余白の上書きが必要になります。

ここで大事な区別があります。コンポーネントの内側の余白（padding）は問題ありません。ボタンの中でテキストと枠の間に16pxの余白を取ること、カードの中でコンテンツと境界線の間に24pxの余白を取ること。これらはコンポーネント自身の見た目の一部です。

問題になるのは外側の余白（margin）です。実装の世界では、コンポーネントは自立した箱の中身であり、箱と箱の距離を決めるのは、それらを並べる親要素の仕事です。FigmaでいうAuto Layoutの間隔設定がまさにこれにあたります。

コンポーネントに外側の余白を持たせてしまうと、再利用のたびに余白が大きすぎる、もっと詰めたいという問題が起き、再利用性が失われます。

たとえば、ボタンコンポーネントに `margin-bottom: 24px` を含めて作ったとします。フォーム画面ではぴったりです。しかし、ダイアログの中に同じボタンを置いたら余白が広すぎる。カードの中に置いたら今度は間隔が合わない。

結局、3つの画面でそれぞれmarginを上書きすることになり、ボタンの余白が画面ごとに違うというバグチケットが1ヶ月で5件も上がりました。

外側の余白をコンポーネントから剥がして、親のAuto Layoutで `gap: 16px` を設定する方式に切り替えた日に、この種のバグは一掃されました。どこに置いても親が間隔を決めるので、ボタン側で上書きする必要がなくなったのです。

原則は、コンポーネントの内側のデザイン（padding、背景色、枠線など）はコンポーネントが責任を持ち、外側の配置（margin、隣の要素との距離、画面上の位置）はレイアウトを担当する親が決定する、という役割分担です。

- コンポーネントの責任: padding（内側の余白）、背景色・枠線、コンテンツの配置
- 親（レイアウト）の責任: margin（外側の余白）、要素間の間隔（gap）、画面上の位置

![padding（内側）と margin（外側）の責任分離](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-19.png)
*padding（内側）と margin（外側）の責任分離*

## 下線（区切り線）: コンポーネントに含めるか？

余白と同じくらい議論になるのが、リストアイテムの下に引く区切り線の扱いです。

たとえば、リストの各行の間に薄いグレーの線を入れるデザインを考えてみてください。設定画面のメニューリストでも、チャットの会話一覧でも、同じ問題が発生します。この線をリストアイテムのコンポーネントに含めるべきか、それともリストアイテムの外側で制御すべきか。

コンポーネントに下線を含めると、リストの最後の行にも下線がついてしまいます。あるいは、区切り線なしのレイアウトで使いたいときに線が消せません。余白の問題とまったく同じ構造です。

![区切り線: コンポーネントに含めるか、親が制御するか](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-38.png)
*区切り線: コンポーネントに含めるか、親が制御するか*

一方で、リストの中での区切り線はほぼセットで使うものなので、コンポーネントに含めたほうが配置の手間が減る、という判断もあります。

実務的な落としどころとしては、下線の表示を `Boolean` のプロパティ（showDivider: ON/OFF）として持たせる方法が有効です。デフォルトはONにしておき、最後の行や区切り線が不要な文脈ではOFFにできるようにします。

実装では、最後の要素だけshowDivider: falseにするのが一般的です。最後の要素の下に線があると、リストの終端がわかりにくくなるためです。

## 幅の振る舞い: Fill・Hug・Fixedの3パターン

もうひとつ、レイアウトに深く関わるのがコンポーネントの幅の扱いです。コンポーネントは、どんな幅の枠の中に置かれるかわかりません。サイドバーの狭いスペースかもしれないし、画面いっぱいの幅かもしれません。このとき、コンポーネントがどう振る舞うかを決めておく必要があります。

幅の振る舞いは、大きく3つのパターンがあります。

- 親の幅いっぱいに広がる（Fill）: 置かれた枠に合わせてコンポーネントの幅が変わる。FigmaでいうFill Containerの設定。テキスト入力フィールド、カード、`Divider`など、文脈に応じて幅が変わるべきコンポーネントはこれが基本
- 中身に合わせて自動で伸縮する（Hug）: テキストやアイコンの量に応じて幅が決まる。FigmaでいうHug Contentsの設定。ボタン、`Tag`、`Badge`など、内容量に幅が比例するコンポーネントに適している
- 固定幅（Fixed）: 特定のピクセル値で幅が決まっている。アイコン、`Avatar`、サムネイルなど、サイズが一定であるべきコンポーネントに適している

![Fill / Hug / Fixed の3パターン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-08.png)
*Fill / Hug / Fixed の3パターン*
デザイナーがFigmaでコンポーネントを作るとき、見た目は思い通りでも、そのまま実装すると画面サイズが変わったときに想定外の見た目をすることがあります。`Button`のデフォルトを Fixed Width にしてしまうと、利用者が画面幅いっぱいのボタンを作りたいときにいちいち設定を変えなければなりません。

ただし、同じコンポーネントでも文脈によって振る舞いが変わることがあります。ボタンはふだんは中身に合わせて伸縮するけれど、モバイルのフォーム画面では画面幅いっぱいに広げたい。

こうしたケースでは、コンポーネント自体は Hug をデフォルトにしておき、親のAuto Layout側で Fill に切り替える、というのが自然な設計です。コンポーネントの幅は自分では決めない、置かれた場所の枠が決める。これも余白の原則と同じ考え方です。

仕様として、このコンポーネントのデフォルトの幅の振る舞いは何かを明示しておくと、実装のブレが減ります。

# アセット: ビジュアルをシステムとして管理する

Figmaで描けたものが、そのまま実装できるとは限らない。

レイアウトではコンポーネントの配置と空間を扱いました。ここからは、コンポーネントに組み込まれるもうひとつの要素——ビジュアルアセットの管理に移ります。

*アイコン、イラスト、アニメーション。ビジュアルアセットをシステムとして管理するための実践知。*

コンポーネントやトークンに加えて、アイコン、イラストレーション、アニメーションといったビジュアルアセットもデザインシステムの重要な構成要素です。

これらはデザイナーが作って終わりではなく、実装に組み込まれ、長期的にメンテナンスされ続けるものです。ファイル形式の選択、命名規則、色の制御方法など、デザインと実装の接点で押さえるべきポイントが多くあります。

## コード実装か画像埋め込みか: 再現手段の選択

Figma上で描けたからといって、それがそのままCSSやコードで再現できるとは限りません。複雑なグラデーション、不規則な形状、繊細なテクスチャ表現などは、コードでの再現がむずかしく、手間もかなり大きくなります。

そのような場合、無理にコードで再現するよりも、SVGやWebPなどの画像として埋め込むほうが合理的です。

なぜこの判断が重要か。この選択は一度決めると覆しにくいからです。

コードで実装したビジュアルは、後からトークンで色を変えたり、アニメーションを追加したり、柔軟に制御できます。一方、画像として埋め込んだものは、変更のたびにデザイナーが書き出し直してエンジニアに渡す手順が発生します。

つまり、コード実装は変更コストが低く、画像埋め込みは初期コストが低い。この表現は今後変わる可能性があるかを軸に判断します。

たとえば、ライトモードで黒、ダークモードで白に切り替わるアイコンはコード実装が必須です。画像として埋め込んでいると、モード切り替えのたびにファイルを差し替える手間が発生します。一方、一度作ったら長期間変わらない装飾的なイラストは画像埋め込みで構いません。

コードで再現するか、アセットとして埋め込むかは、早い段階で実装方針をすり合わせておきたい論点です。

![コード実装かアセット埋め込みかの判断フロー](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-09.png)
*コード実装かアセット埋め込みかの判断フロー*
## アイコン管理: 既存ライブラリと独自制作のトレードオフ

アイコンはUIの中でよく使われるグラフィックのひとつです。まず考えるべきは、世の中にあるアイコンライブラリを使うのか、自社でゼロから作るのかという戦略です。

### 既存ライブラリを使う

実装コストがほぼゼロなのが大きな強みです。ライブラリを導入して名前を指定するだけで画面に配置できます。一貫性が保たれており、アイコンが足りなくて困ることもありません。

反面、ブランドの独自性は薄れます。どこかで見たことがあるアプリという印象になりがちですし、自社特有の概念を表現するアイコンがない場合、結局一部だけ自作することになります。

### 独自アイコンを制作する

ブランドの世界観を細部までコントロールでき、プロダクト独自のドメイン知識を視覚的に正しく伝えることが可能です。ただし、制作とメンテナンスのコストは大きいです。SVGのパスをきれいに掃除し、書き出し設定を整え、実装で使える形式で管理し続ける必要があります。

これらはハイブリッド運用することも可能です。矢印やゴミ箱などの汎用的なアイコンは既存のライブラリに頼り、プロダクトを象徴する重要なアイコンだけを自作する構成です。ただし、この場合は線の太さや角丸のルールをライブラリ側に寄せる配慮が欠かせません。統一感がないとここだけ浮いて見えるという問題が起きるためです。

![既存ライブラリ vs 独自アイコン](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-21.png)
*既存ライブラリ vs 独自アイコン*

## ベクターアイコンの活用: SVGとアイコンフォント

アイコンの管理にどんな形式を選ぶかは、日々の開発効率に影響する選択です。

意外と多いのが、アイコンをPNGやJPGなどのラスター画像で管理しているパターンです。この方式だと、色違いが必要になるたびに別ファイルを書き出す必要がありますし、ダークモード対応では同じアイコンの白版・黒版が倍々で増えていきます。さらに拡大表示でぼやけるという根本的な問題もあります。

現在の開発現場では、アイコンはSVGまたはアイコンフォントとして管理するのが標準です。こうした形式であれば、個別の画像ファイルを保存・呼び出しする必要がなく、アイコン名を指定するだけで表示できます。色やサイズもコードから自由に制御でき、ほとんどのケースではこの方式で十分です。

Figmaでの管理方法としては、アイコンそれぞれを個別のコンポーネントとして作成する方法と、Component Setでバリアントとしてまとめる方法があります。チームの規模やアイコンの数に応じて選択してください。

以下では、アイコンをSVGとして実装に渡す際に知っておきたい技術的仕様を紹介します。

## 色の制御: アイコンの色を自動で合わせるしくみ

Figma上でアイコンの色を変えるとき、塗りの色を直接変更しますよね。コードの世界でも同じことをしたいのですが、Figmaから書き出したSVGファイルの中身を覗くと、色が `#1A1A1A`（ほぼ黒のカラーコード）のような固定値で埋め込まれていることがあります。

この状態だと、ボタンの中に置いたアイコンの色をボタンの色に合わせて自動で切り替える、といったことができません。

ダークモードを導入した際にこの問題にぶつかるチームは少なくありません。ライトモードでは黒いアイコンがきちんと見えていたのに、ダークモードに切り替えた瞬間、黒い背景に黒いアイコンで何も見えない。原因は、SVGに色が固定値で埋め込まれていたことです。

理想は、SVGの中の色を固定値にせず、周囲のテキスト色に自動で合わせるという指定にしておくことです。白いテキストのボタンの中に置けば白に、青いリンクの中に置けば青に、と自動で色が変わります。Figmaでいえば、Variablesでアイコンの色をテキスト色トークンに紐づけておくのと近い考え方です。

![SVGの色制御: 固定色 vs currentColor](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-30.png)
*SVGの色制御: 固定色 vs currentColor*

運用ルールとしておすすめなのは、Figma上でアイコンコンポーネントを最初から黒一色で作ることです。コード側で`currentColor`（親要素のテキスト色を自動的に引き継ぐ仕組み）に置き換えることを前提にしておけば、Figma上で色をいちいち剥がす手間が省けます。

チームによっては、書き出し時に自動で色を除去するビルドスクリプトを用意しているケースもあります。チームで運用方法をすり合わせておきましょう。

# おわりに

長い記事にお付き合いいただき、ありがとうございます。

コンポーネントは単なるUIの見た目ではなく、チームの共通言語です。 この記事では、デザインシステムのコンポーネント設計を、原則から具体的な変数の型まで段階的に掘り下げてきました。

![本書の構成と知識の積み上げ](https://raw.githubusercontent.com/yasuhiro-y/component-design-guide-for-designers/main/illustrations/output/fig-10.png)
*本書の構成と知識の積み上げ*
一貫しているのは、コンポーネントは単なるUIの見た目ではなく、チームの共通言語であるということです。命名ひとつ、変数の型ひとつが、デザインと実装の間の翻訳コストを左右します。

## この記事のキーテイクアウェイ

### 原則
- **再利用性（SSOT）**: 一箇所を直せば全部直る。マスターコンポーネントを1つ持ち、全画面でインスタンスを使う
- **変更のしやすさ**: 変更コストを下げる設計を最初から意識する。後から変えるコストは想像以上に高い
- **拡張のしやすさ**: 既存を壊さずに新しいバリアントやプロパティを追加できる設計にする
- **経路依存性**: 初期の選択が未来を縛る。命名・ディレクトリ構造・ライブラリ選択——すべてに同じ力学が働く
- **関心の分離**: コンポーネントは中身だけに責任を持ち、配置は親に任せる

### コンポーネント分割
- コンポーネント化の判断基準は「一箇所を直せば全部直る状態にしたいか」
- Atomic Design（大きさで分ける）、FSD（目的で分ける）、フラット配置の3つのアプローチがある
- Atomic Designではmolecules/organismsの境界が人によってバラバラになりがち
- FSDの依存方向は一方通行: 上位レイヤーは下位を使えるが、逆はNG。`Button`が`UserCard`に依存してはいけない
- コンポーネント数が20〜30を超えたら階層化を検討する

### 汎用とドメインの分離
- **汎用コンポーネント**: 特定のデータ構造に依存しない。別のサービスでもそのまま使えるかが判断基準
- **ドメインコンポーネント**: 特定のデータ構造（オブジェクト）に特化する。データの表示ルールをコンポーネント内部に閉じ込められる
- 汎用コンポーネントにはビジネスロジックを含めない。表示テキストは呼び出し側が渡す
- 境界は一意に決まらないこともある。チームで判断基準を議論し、ケーススタディを積み重ねてナレッジにする
- オブジェクトをまるごと受け取る設計なら、ドメインコンポーネントとして位置づけるのが自然

### 早すぎる共通化の罠
- 見た目が似ていることと、目的やドメインが同じことは別の話
- 無理に統合すると互いに無関係なプロパティが混在し、複雑なコンポーネントになる
- 共通化の判断は、同じパターンが繰り返し現れてからでも遅くない（AHA原則）

### 命名
- **名前は設計の一部**: 最初につけた名前がコード・ドキュメント・チームの会話に定着する。後から変えるコストは高い
- 状態やバリエーションを名前に含めない。`RedButton`ではなく`Button`にして、バリアントで切り替える
- ドメインコンポーネントの名前はAPIのデータモデル名と揃える（`ShiftCard`など）
- 汎用コンポーネントにはデータモデル名を入れない（`UserAvatar`ではなく`Avatar`）
- 命名規則が整っているとAIコード生成ツールも自社の命名体系に沿った補完をする

### 変数の型
- **Boolean**: ON/OFFの2値。排他的な状態（Small/Large）をBooleanで分けると矛盾が生じる
- **Enum**: 決まった選択肢から1つ選ぶ。追加は安全、削除や名称変更は破壊的変更
- **String**: 自由入力テキスト。空文字列のケースを必ず定義する
- **Number**: 数値。上下限やステップを明示する
- **Array**: 配列。0件・1件・多数の3パターンを考慮する
- **Object**: 複数の情報のまとまり。ドメインコンポーネントはデータ一式をまとめて受け取る
- **Element（スロット）**: 差し込み口を設けてバリアント爆発を防ぐ。Instance Swap Propertyで表現する

### プロパティの直交性
- プロパティ同士が互いに干渉しない設計が重要
- あるプロパティの値を変えても、他のプロパティの意味や振る舞いが変わらないようにする
- 関心が異なるなら、見た目が似ていても別コンポーネントにする（例: Toggle vs Switch）
- ひとつのプロパティに複数の関心事をまとめて扱わない

### UIスタック: 5つの状態
- **Ideal / Empty / Loading / Partial / Error** の5状態をすべて定義してから実装に渡す
- **Partial Stateが最も見落としやすい**: データは「ある/ない」の二択ではなく、「一部だけある」ことのほうが多い
- データ項目ごとにフォールバック（代替表示）を定義しておく
- 外から渡す設定値（props）とコンポーネント自身が管理する状態（state）は区別する
- 状態を表すプロパティには `_` プレフィックスなど目印をつけると認識のズレを防げる

### インタラクション状態
- **Hover / Pressed / Disabled / Focus** の見た目をすべてのインタラクティブなコンポーネントに定義する
- ルールをトークンで一元管理し、コンポーネントごとに個別に決めない
- フォーカスリングの色・太さ・オフセットはコンポーネント横断で統一する

### Figmaとコードの差分
- **必須と任意**: デフォルト値で使いやすさが決まる。8割のユースケースは何も指定しなくても使える状態を目指す
- **条件付き表示**: Figmaではトグル＋テキストの2操作、コードでは値の有無で1つで制御。このズレを認識し、ルール化しておく
- デフォルト値は一度決めたら簡単に変えられない。影響範囲が広いため慎重に決定する

### レイアウト
- コンポーネントは自分の中身だけに責任を持ち、どこに置くかは親に任せる
- **外側の余白（margin）はコンポーネントに含めない**: 親のAuto Layout / gapで制御する
- **区切り線**: showDivider（Boolean）で制御するか、親のループで挿入するか方針を決める
- **幅の振る舞い**: Fill（親に合わせる）/ Hug（中身に合わせる）/ Fixed（固定）の3パターンをデフォルトとして明示する

### トークンの共有
- 色・サイズをトークンとして一元管理し、複数コンポーネントの一貫性を保つ
- セマンティックカラーを兄弟コンポーネント間で共有すれば、一箇所の修正で全体に反映される
- トークンを使わず個別に値を書き込むと、微妙なズレが蓄積する

### アクセシビリティ
- コンポーネントに組み込めるところは組み込む。使うだけで基準を満たせる状態を作る
- コントラスト比をトークンレベルで保証する
- アイコンやイラストに代替テキスト用のプロパティ（altText / ariaLabel）を設ける
- コンポーネント単体で全て担保できるわけではない。ページ構造や読み上げ順序は別途議論する

### アセット管理
- **コード実装 vs 画像埋め込み**: 今後変わる可能性があるかで判断する。変更が想定されるならコード実装
- アイコンはSVGまたはアイコンフォントで管理する。PNG/JPGは色違いのたびに別ファイルが増える
- SVGの色は固定値ではなく `currentColor` で親のテキスト色に自動追従させる
- 既存ライブラリ＋独自アイコンのハイブリッド運用では、線の太さや角丸のルールを統一する

### 安全な変更と破壊的変更
- **増やすのは簡単、変えるのは大変**: 新しいバリアント追加は安全、プロパティ名の変更は破壊的
- Figmaではプロパティを自由に変更でき、インスタンスは自動追従するが、コードではそうはいかない
- この非対称性を意識するだけで、変更の提案のしかたや移行計画の立て方が変わる

### ライフサイクル管理
- コンポーネントは作ることより、**終わらせることのほうが難しい**
- [Deprecated] マークで非推奨を明示し、代替コンポーネントを説明欄に記載する
- 方針がないと使われなくなったコンポーネントがゾンビのように残り続ける

### 例外の許容と現実的な対処
- 100%準拠を目指さない。90%の定型と10%の例外を最初から織り込む
- Detach（コンポーネント解除）の前に4つの選択肢を検討する: 組み合わせ → バリアント追加 → 新規作成 → 例外許容
- デザインシステムから外れた実装を「失敗」ではなく「データ」と見なし、フィードバックループを回す
- FigmaとコードのUIが完全一致している必要はない。インターフェース（プロパティの名前と型）が一致していることのほうが重要

### AI時代の設計
- 命名規則・型定義・UI状態の定義が整ったデザインシステムは、AIコード生成の精度を引き上げる
- デザイナーが仕組みを理解し、エンジニアと共通言語を持つことの価値は、AI時代にさらに高まる

デザインシステムのコンポーネント設計は、一度読んで完全に理解できるような分野ではありません。実際のプロダクト開発の中で議論し、手を動かし、失敗し、直していく中で少しずつ身についていくものです。

実装とデザインで会話が通じた瞬間や、Figmaのプロパティ設計がそのままコードに反映されたのを見た瞬間——そうした小さな手応えの積み重ねが、視野を広げてくれます。

この記事は、そのときに立ち返れるリファレンスとして使ってもらえればと思っています。全部を一気に取り入れる必要はありません。

いま自分のチームで課題になっている章から読み直してみる、チームの会話で、これ記事に書いてあったなと思い出す。そういった使い方で十分です。

そしていま、AIがコードを書く時代に入りつつあります。命名規則が整い、型が明確で、設計意図が言語化されたデザインシステムは、人間の開発者だけでなくAIにとっても最良のインプットになります。

